/**
 * START of DtnJ4yNw.js
 */

const __vite__mapDeps = (i, m=__vite__mapDeps, d=(m.f || (m.f = ["./CbZ2X_fh.js", "./DWjXqeLZ.js", "./BxJ63bii.js", "./ButtonTilt.LhO0V6bW.css", "./B8N-DhZm.js", "./YYe3JQAg.js", "./B9MQKUuF.js", "./D-Bk0yD0.js", "./PathBackground.7kG6BcV0.css", "./C4EeYDoX.js", "./miBiR62R.js", "./DMco0rdt.js", "./BorderHover.DW7kzidB.css", "./ContentExpander.DyRjkwat.css", "./linksResolver.CI6wRIV9.css", "./DY90oNe7.js", "./SiteFooter.DgxBm7Rk.css", "./CELweT10.js", "./BluaGfCy.js", "./about.D1pNVY42.css", "./BuBxfxJl.js", "./index.Dmdczd-I.css", "./BCRGQsX2.js", "./press.B61vp7VX.css", "./BxQ8Vkc_.js", "./config.CPLvtMWX.css", "./BIWO7QxN.js", "./system.CTpX0nZT.css", "./BbrcitPk.js", "./CKlxW_no.js", "./CrWOzmEA.js", "./Checkbox.DPiEluAk.css", "./CHiBhYu6.js", "./X2iQyDR3.js", "./CrossFlicker.CAQml9P2.css", "./D_MGx2mw.js", "./DSButton.CDEX4zNp.css", "./HeadingContent.yC39PRyF.css", "./careers.CR8DMtg0.css", "./C-BRwMMA.js", "./contact.xCr_ZgtQ.css", "./Bzlz6xBK.js", "./security.Bdas6sPx.css", "./CkF0v0bl.js", "./uf-KtDSq.js", "./Dtqi9rxa.js", "./privacy-policy.Cm1Upcwh.css", "./Br5iTxUS.js", "./terms-of-service.DA20Ye_Z.css", "./BqJij3jk.js", "./DSDropdownButton.CvAfSjzU.css", "./DuRqwrrY.js", "./DesignGrid.Di0usAye.css", "./-ncqVWPL.js", "./BNGIg-YS.js", "./HoverCard.TgLSNk3K.css", "./BFfbkEzJ.js", "./CLvGjMNs.js", "./Media.uC2ywchh.css", "./CRca66RA.js", "./TagButtonList.Dxgeffxm.css", "./BiKF1uHK.js", "./TextReveal.CTK1JXTk.css", "./DetfEEUb.js", "./TextRevealChar.k4zFTZsq.css", "./D5u-uEeA.js", "./AboutLeaders.BGkHGvSM.css", "./S5LwJpeA.js", "./i4Z45dCd.js", "./BlogCardSkeleton.Bf5Xlpvs.css", "./Bj9BJCNz.js", "./AllResources.CiRLUtjS.css", "./D2U9k6xf.js", "./COBiQGDO.js", "./NotchSection.CmaDBuu9.css", "./BigImageWithContent.CJIqM0wA.css", "./Bd3kFPqD.js", "./BigText.0JeCNRN4.css", "./Cis9g7J4.js", "./CaseStudy.wpPBBL5k.css", "./BcOJFtKS.js", "./CSQBpqcQ.js", "./ComparisonTable.palZatc7.css", "./DKxMU-wA.js", "./ContentExpanderStandAlone.31iPM3MR.css", "./BVtaWYQw.js", "./ExpandableFeatureCards.CRm5Weo2.css", "./DCfZCkD0.js", "./FeatureSection.B0YFQ_JC.css", "./Cl5NWGaN.js", "./FeaturedBlogPosts.Cqc5b9wy.css", "./Cys__Kp9.js", "./BeUK2rGw.js", "./CsgZCG33.js", "./FeaturesCarousel.BD2Y_59X.css", "./DKPMjus8.js", "./FeaturesCarouselExpandable.D1GmgyKF.css", "./Dd93XKWM.js", "./FeaturesGrid.Nc_0ch-R.css", "./D3129BPP.js", "./6zh_Ngfm.js", "./PaddedCounter.D_9jWspQ.css", "./FeaturesSteps.BVcE7YK6.css", "./JJ0bgXXV.js", "./FormBuilder.2s_5K16H.css", "./CSBK0bRj.js", "./C1uiNH32.js", "./FullscreenFeatures.D6ZYpDiv.css", "./DvDbbmhX.js", "./HeroImage.BthVimVc.css", "./DP-7vt3f.js", "./xrnGKAOC.js", "./BackgroundCanvas.Mu1ajYID.css", "./BW3zdkNM.js", "./InfoSection.B8RSaTi3.css", "./aKHjDkkP.js", "./D0GSe9oA.js", "./NewsSection.B8_G2Had.css", "./B9GCsJEt.js", "./LinksList.Dn_bPq3O.css", "./BhF38yHI.js", "./LogoGrid.q7LM8J_l.css", "./CXwOP54l.js", "./cJ4SfDLX.js", "./SectionIntroduction.B-98zZYX.css", "./Post.uViPkGYd.css", "./08tjNvWn.js", "./PressSection.DSVZTmjw.css", "./E4c-oP3M.js", "./ProofPoints.Ci2yWwFr.css", "./Ftaie4Kp.js", "./Quote.BktCJoG9.css", "./Ag6wi3mv.js", "./ResultsSection.CFPh_8W7.css", "./DZYxXXtm.js", "./SectionsGrid.BmU1CbFH.css", "./Cvqf3Hfi.js", "./SeparatorNotch.C7lDeGb1.css", "./COn8KyPB.js", "./CpI0mRSC.js", "./get-frames.BEFbNTY1.css", "./SolutionsFeatures.U8Psha3l.css", "./BSt46Xi-.js", "./SolutionsFull.AV3-HjHL.css", "./MtFr25ii.js", "./SolutionsValue.BrBjTbyi.css", "./CcUsvXqT.js", "./TabbedAccordion.CWtuEFfB.css", "./B_Pww068.js", "./VideoCarousel.wiIHwmc0.css", "./1VzHhDmg.js", "./YOSSection.Dhetld54.css", "./sBtd8UHQ.js", "./default.BcKJ6naG.css"]))) => i.map(i => d[i]);
var vy = Object.defineProperty;
var by = (e, t, n) => t in e ? vy(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : e[t] = n;
var St = (e, t, n) => by(e, typeof t != "symbol" ? t + "" : t, n);
(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
        return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        r(i);
    new MutationObserver(i => {
        for (const s of i)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity),
        i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
        i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function r(i) {
        if (i.ep)
            return;
        i.ep = !0;
        const s = n(i);
        fetch(i.href, s)
    }
}
)();
/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
function Vc(e) {
    const t = Object.create(null);
    for (const n of e.split(","))
        t[n] = 1;
    return n => n in t
}
const jn = {}
  , Xa = []
  , Ps = () => {}
  , wy = () => !1
  , Du = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97)
  , Wd = e => e.startsWith("onUpdate:")
  , vr = Object.assign
  , qd = (e, t) => {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}
  , Dy = Object.prototype.hasOwnProperty
  , Zn = (e, t) => Dy.call(e, t)
  , Qt = Array.isArray
  , Qa = e => gl(e) === "[object Map]"
  , Fa = e => gl(e) === "[object Set]"
  , Hh = e => gl(e) === "[object Date]"
  , Ey = e => gl(e) === "[object RegExp]"
  , dn = e => typeof e == "function"
  , Sr = e => typeof e == "string"
  , zs = e => typeof e == "symbol"
  , gr = e => e !== null && typeof e == "object"
  , Gd = e => (gr(e) || dn(e)) && dn(e.then) && dn(e.catch)
  , Wg = Object.prototype.toString
  , gl = e => Wg.call(e)
  , Cy = e => gl(e).slice(8, -1)
  , jc = e => gl(e) === "[object Object]"
  , Yd = e => Sr(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e
  , Ja = Vc(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , zc = e => {
    const t = Object.create(null);
    return n => t[n] || (t[n] = e(n))
}
  , xy = /-(\w)/g
  , Ei = zc(e => e.replace(xy, (t, n) => n ? n.toUpperCase() : ""))
  , Sy = /\B([A-Z])/g
  , cs = zc(e => e.replace(Sy, "-$1").toLowerCase())
  , _l = zc(e => e.charAt(0).toUpperCase() + e.slice(1))
  , Za = zc(e => e ? `on${_l(e)}` : "")
  , es = (e, t) => !Object.is(e, t)
  , el = (e, ...t) => {
    for (let n = 0; n < e.length; n++)
        e[n](...t)
}
  , qg = (e, t, n, r=!1) => {
    Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !1,
        writable: r,
        value: n
    })
}
  , gc = e => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
}
  , _c = e => {
    const t = Sr(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t
}
;
let Vh;
const Uc = () => Vh || (Vh = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {})
  , Ty = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol"
  , Py = Vc(Ty);
function ml(e) {
    if (Qt(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = e[n]
              , i = Sr(r) ? Oy(r) : ml(r);
            if (i)
                for (const s in i)
                    t[s] = i[s]
        }
        return t
    } else if (Sr(e) || gr(e))
        return e
}
const ky = /;(?![^(]*\))/g
  , Ay = /:([^]+)/
  , Ry = /\/\*[^]*?\*\//g;
function Oy(e) {
    const t = {};
    return e.replace(Ry, "").split(ky).forEach(n => {
        if (n) {
            const r = n.split(Ay);
            r.length > 1 && (t[r[0].trim()] = r[1].trim())
        }
    }
    ),
    t
}
function ks(e) {
    let t = "";
    if (Sr(e))
        t = e;
    else if (Qt(e))
        for (let n = 0; n < e.length; n++) {
            const r = ks(e[n]);
            r && (t += r + " ")
        }
    else if (gr(e))
        for (const n in e)
            e[n] && (t += n + " ");
    return t.trim()
}
function My(e) {
    if (!e)
        return null;
    let {class: t, style: n} = e;
    return t && !Sr(t) && (e.class = ks(t)),
    n && (e.style = ml(n)),
    e
}
const Ly = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , Fy = Vc(Ly);
function Gg(e) {
    return !!e || e === ""
}
function Iy(e, t) {
    if (e.length !== t.length)
        return !1;
    let n = !0;
    for (let r = 0; n && r < e.length; r++)
        n = ia(e[r], t[r]);
    return n
}
function ia(e, t) {
    if (e === t)
        return !0;
    let n = Hh(e)
      , r = Hh(t);
    if (n || r)
        return n && r ? e.getTime() === t.getTime() : !1;
    if (n = zs(e),
    r = zs(t),
    n || r)
        return e === t;
    if (n = Qt(e),
    r = Qt(t),
    n || r)
        return n && r ? Iy(e, t) : !1;
    if (n = gr(e),
    r = gr(t),
    n || r) {
        if (!n || !r)
            return !1;
        const i = Object.keys(e).length
          , s = Object.keys(t).length;
        if (i !== s)
            return !1;
        for (const o in e) {
            const l = e.hasOwnProperty(o)
              , u = t.hasOwnProperty(o);
            if (l && !u || !l && u || !ia(e[o], t[o]))
                return !1
        }
    }
    return String(e) === String(t)
}
function Wc(e, t) {
    return e.findIndex(n => ia(n, t))
}
const Yg = e => !!(e && e.__v_isRef === !0)
  , Ji = e => Sr(e) ? e : e == null ? "" : Qt(e) || gr(e) && (e.toString === Wg || !dn(e.toString)) ? Yg(e) ? Ji(e.value) : JSON.stringify(e, Kg, 2) : String(e)
  , Kg = (e, t) => Yg(t) ? Kg(e, t.value) : Qa(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce( (n, [r,i], s) => (n[Df(r, s) + " =>"] = i,
    n), {})
} : Fa(t) ? {
    [`Set(${t.size})`]: [...t.values()].map(n => Df(n))
} : zs(t) ? Df(t) : gr(t) && !Qt(t) && !jc(t) ? String(t) : t
  , Df = (e, t="") => {
    var n;
    return zs(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e
}
;
/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Zi;
class Kd {
    constructor(t=!1) {
        this.detached = t,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this._isPaused = !1,
        this.parent = Zi,
        !t && Zi && (this.index = (Zi.scopes || (Zi.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    pause() {
        if (this._active) {
            this._isPaused = !0;
            let t, n;
            if (this.scopes)
                for (t = 0,
                n = this.scopes.length; t < n; t++)
                    this.scopes[t].pause();
            for (t = 0,
            n = this.effects.length; t < n; t++)
                this.effects[t].pause()
        }
    }
    resume() {
        if (this._active && this._isPaused) {
            this._isPaused = !1;
            let t, n;
            if (this.scopes)
                for (t = 0,
                n = this.scopes.length; t < n; t++)
                    this.scopes[t].resume();
            for (t = 0,
            n = this.effects.length; t < n; t++)
                this.effects[t].resume()
        }
    }
    run(t) {
        if (this._active) {
            const n = Zi;
            try {
                return Zi = this,
                t()
            } finally {
                Zi = n
            }
        }
    }
    on() {
        Zi = this
    }
    off() {
        Zi = this.parent
    }
    stop(t) {
        if (this._active) {
            this._active = !1;
            let n, r;
            for (n = 0,
            r = this.effects.length; n < r; n++)
                this.effects[n].stop();
            for (this.effects.length = 0,
            n = 0,
            r = this.cleanups.length; n < r; n++)
                this.cleanups[n]();
            if (this.cleanups.length = 0,
            this.scopes) {
                for (n = 0,
                r = this.scopes.length; n < r; n++)
                    this.scopes[n].stop(!0);
                this.scopes.length = 0
            }
            if (!this.detached && this.parent && !t) {
                const i = this.parent.scopes.pop();
                i && i !== this && (this.parent.scopes[this.index] = i,
                i.index = this.index)
            }
            this.parent = void 0
        }
    }
}
function Ss(e) {
    return new Kd(e)
}
function Lo() {
    return Zi
}
function ds(e, t=!1) {
    Zi && Zi.cleanups.push(e)
}
let xr;
const Ef = new WeakSet;
class au {
    constructor(t) {
        this.fn = t,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 5,
        this.next = void 0,
        this.cleanup = void 0,
        this.scheduler = void 0,
        Zi && Zi.active && Zi.effects.push(this)
    }
    pause() {
        this.flags |= 64
    }
    resume() {
        this.flags & 64 && (this.flags &= -65,
        Ef.has(this) && (Ef.delete(this),
        this.trigger()))
    }
    notify() {
        this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Qg(this)
    }
    run() {
        if (!(this.flags & 1))
            return this.fn();
        this.flags |= 2,
        jh(this),
        Jg(this);
        const t = xr
          , n = js;
        xr = this,
        js = !0;
        try {
            return this.fn()
        } finally {
            Zg(this),
            xr = t,
            js = n,
            this.flags &= -3
        }
    }
    stop() {
        if (this.flags & 1) {
            for (let t = this.deps; t; t = t.nextDep)
                Jd(t);
            this.deps = this.depsTail = void 0,
            jh(this),
            this.onStop && this.onStop(),
            this.flags &= -2
        }
    }
    trigger() {
        this.flags & 64 ? Ef.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
    }
    runIfDirty() {
        Jf(this) && this.run()
    }
    get dirty() {
        return Jf(this)
    }
}
let Xg = 0, Xl, Ql;
function Qg(e, t=!1) {
    if (e.flags |= 8,
    t) {
        e.next = Ql,
        Ql = e;
        return
    }
    e.next = Xl,
    Xl = e
}
function Xd() {
    Xg++
}
function Qd() {
    if (--Xg > 0)
        return;
    if (Ql) {
        let t = Ql;
        for (Ql = void 0; t; ) {
            const n = t.next;
            t.next = void 0,
            t.flags &= -9,
            t = n
        }
    }
    let e;
    for (; Xl; ) {
        let t = Xl;
        for (Xl = void 0; t; ) {
            const n = t.next;
            if (t.next = void 0,
            t.flags &= -9,
            t.flags & 1)
                try {
                    t.trigger()
                } catch (r) {
                    e || (e = r)
                }
            t = n
        }
    }
    if (e)
        throw e
}
function Jg(e) {
    for (let t = e.deps; t; t = t.nextDep)
        t.version = -1,
        t.prevActiveLink = t.dep.activeLink,
        t.dep.activeLink = t
}
function Zg(e) {
    let t, n = e.depsTail, r = n;
    for (; r; ) {
        const i = r.prevDep;
        r.version === -1 ? (r === n && (n = i),
        Jd(r),
        Ny(r)) : t = r,
        r.dep.activeLink = r.prevActiveLink,
        r.prevActiveLink = void 0,
        r = i
    }
    e.deps = t,
    e.depsTail = n
}
function Jf(e) {
    for (let t = e.deps; t; t = t.nextDep)
        if (t.dep.version !== t.version || t.dep.computed && (e_(t.dep.computed) || t.dep.version !== t.version))
            return !0;
    return !!e._dirty
}
function e_(e) {
    if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17,
    e.globalVersion === lu))
        return;
    e.globalVersion = lu;
    const t = e.dep;
    if (e.flags |= 2,
    t.version > 0 && !e.isSSR && e.deps && !Jf(e)) {
        e.flags &= -3;
        return
    }
    const n = xr
      , r = js;
    xr = e,
    js = !0;
    try {
        Jg(e);
        const i = e.fn(e._value);
        (t.version === 0 || es(i, e._value)) && (e._value = i,
        t.version++)
    } catch (i) {
        throw t.version++,
        i
    } finally {
        xr = n,
        js = r,
        Zg(e),
        e.flags &= -3
    }
}
function Jd(e, t=!1) {
    const {dep: n, prevSub: r, nextSub: i} = e;
    if (r && (r.nextSub = i,
    e.prevSub = void 0),
    i && (i.prevSub = r,
    e.nextSub = void 0),
    n.subs === e && (n.subs = r,
    !r && n.computed)) {
        n.computed.flags &= -5;
        for (let s = n.computed.deps; s; s = s.nextDep)
            Jd(s, !0)
    }
    !t && !--n.sc && n.map && n.map.delete(n.key)
}
function Ny(e) {
    const {prevDep: t, nextDep: n} = e;
    t && (t.nextDep = n,
    e.prevDep = void 0),
    n && (n.prevDep = t,
    e.nextDep = void 0)
}
function $y(e, t) {
    e.effect instanceof au && (e = e.effect.fn);
    const n = new au(e);
    t && vr(n, t);
    try {
        n.run()
    } catch (i) {
        throw n.stop(),
        i
    }
    const r = n.run.bind(n);
    return r.effect = n,
    r
}
function By(e) {
    e.effect.stop()
}
let js = !0;
const t_ = [];
function oa() {
    t_.push(js),
    js = !1
}
function aa() {
    const e = t_.pop();
    js = e === void 0 ? !0 : e
}
function jh(e) {
    const {cleanup: t} = e;
    if (e.cleanup = void 0,
    t) {
        const n = xr;
        xr = void 0;
        try {
            t()
        } finally {
            xr = n
        }
    }
}
let lu = 0;
class Hy {
    constructor(t, n) {
        this.sub = t,
        this.dep = n,
        this.version = n.version,
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
    }
}
class qc {
    constructor(t) {
        this.computed = t,
        this.version = 0,
        this.activeLink = void 0,
        this.subs = void 0,
        this.map = void 0,
        this.key = void 0,
        this.sc = 0
    }
    track(t) {
        if (!xr || !js || xr === this.computed)
            return;
        let n = this.activeLink;
        if (n === void 0 || n.sub !== xr)
            n = this.activeLink = new Hy(xr,this),
            xr.deps ? (n.prevDep = xr.depsTail,
            xr.depsTail.nextDep = n,
            xr.depsTail = n) : xr.deps = xr.depsTail = n,
            n_(n);
        else if (n.version === -1 && (n.version = this.version,
        n.nextDep)) {
            const r = n.nextDep;
            r.prevDep = n.prevDep,
            n.prevDep && (n.prevDep.nextDep = r),
            n.prevDep = xr.depsTail,
            n.nextDep = void 0,
            xr.depsTail.nextDep = n,
            xr.depsTail = n,
            xr.deps === n && (xr.deps = r)
        }
        return n
    }
    trigger(t) {
        this.version++,
        lu++,
        this.notify(t)
    }
    notify(t) {
        Xd();
        try {
            for (let n = this.subs; n; n = n.prevSub)
                n.sub.notify() && n.sub.dep.notify()
        } finally {
            Qd()
        }
    }
}
function n_(e) {
    if (e.dep.sc++,
    e.sub.flags & 4) {
        const t = e.dep.computed;
        if (t && !e.dep.subs) {
            t.flags |= 20;
            for (let r = t.deps; r; r = r.nextDep)
                n_(r)
        }
        const n = e.dep.subs;
        n !== e && (e.prevSub = n,
        n && (n.nextSub = e)),
        e.dep.subs = e
    }
}
const mc = new WeakMap
  , Sa = Symbol("")
  , Zf = Symbol("")
  , uu = Symbol("");
function ji(e, t, n) {
    if (js && xr) {
        let r = mc.get(e);
        r || mc.set(e, r = new Map);
        let i = r.get(n);
        i || (r.set(n, i = new qc),
        i.map = r,
        i.key = n),
        i.track()
    }
}
function Eo(e, t, n, r, i, s) {
    const o = mc.get(e);
    if (!o) {
        lu++;
        return
    }
    const l = u => {
        u && u.trigger()
    }
    ;
    if (Xd(),
    t === "clear")
        o.forEach(l);
    else {
        const u = Qt(e)
          , p = u && Yd(n);
        if (u && n === "length") {
            const h = Number(r);
            o.forEach( (g, m) => {
                (m === "length" || m === uu || !zs(m) && m >= h) && l(g)
            }
            )
        } else
            switch ((n !== void 0 || o.has(void 0)) && l(o.get(n)),
            p && l(o.get(uu)),
            t) {
            case "add":
                u ? p && l(o.get("length")) : (l(o.get(Sa)),
                Qa(e) && l(o.get(Zf)));
                break;
            case "delete":
                u || (l(o.get(Sa)),
                Qa(e) && l(o.get(Zf)));
                break;
            case "set":
                Qa(e) && l(o.get(Sa));
                break
            }
    }
    Qd()
}
function Vy(e, t) {
    const n = mc.get(e);
    return n && n.get(t)
}
function ja(e) {
    const t = Nn(e);
    return t === e ? t : (ji(t, "iterate", uu),
    ms(e) ? t : t.map(zi))
}
function Gc(e) {
    return ji(e = Nn(e), "iterate", uu),
    e
}
const jy = {
    __proto__: null,
    [Symbol.iterator]() {
        return Cf(this, Symbol.iterator, zi)
    },
    concat(...e) {
        return ja(this).concat(...e.map(t => Qt(t) ? ja(t) : t))
    },
    entries() {
        return Cf(this, "entries", e => (e[1] = zi(e[1]),
        e))
    },
    every(e, t) {
        return yo(this, "every", e, t, void 0, arguments)
    },
    filter(e, t) {
        return yo(this, "filter", e, t, n => n.map(zi), arguments)
    },
    find(e, t) {
        return yo(this, "find", e, t, zi, arguments)
    },
    findIndex(e, t) {
        return yo(this, "findIndex", e, t, void 0, arguments)
    },
    findLast(e, t) {
        return yo(this, "findLast", e, t, zi, arguments)
    },
    findLastIndex(e, t) {
        return yo(this, "findLastIndex", e, t, void 0, arguments)
    },
    forEach(e, t) {
        return yo(this, "forEach", e, t, void 0, arguments)
    },
    includes(...e) {
        return xf(this, "includes", e)
    },
    indexOf(...e) {
        return xf(this, "indexOf", e)
    },
    join(e) {
        return ja(this).join(e)
    },
    lastIndexOf(...e) {
        return xf(this, "lastIndexOf", e)
    },
    map(e, t) {
        return yo(this, "map", e, t, void 0, arguments)
    },
    pop() {
        return Ol(this, "pop")
    },
    push(...e) {
        return Ol(this, "push", e)
    },
    reduce(e, ...t) {
        return zh(this, "reduce", e, t)
    },
    reduceRight(e, ...t) {
        return zh(this, "reduceRight", e, t)
    },
    shift() {
        return Ol(this, "shift")
    },
    some(e, t) {
        return yo(this, "some", e, t, void 0, arguments)
    },
    splice(...e) {
        return Ol(this, "splice", e)
    },
    toReversed() {
        return ja(this).toReversed()
    },
    toSorted(e) {
        return ja(this).toSorted(e)
    },
    toSpliced(...e) {
        return ja(this).toSpliced(...e)
    },
    unshift(...e) {
        return Ol(this, "unshift", e)
    },
    values() {
        return Cf(this, "values", zi)
    }
};
function Cf(e, t, n) {
    const r = Gc(e)
      , i = r[t]();
    return r !== e && !ms(e) && (i._next = i.next,
    i.next = () => {
        const s = i._next();
        return s.value && (s.value = n(s.value)),
        s
    }
    ),
    i
}
const zy = Array.prototype;
function yo(e, t, n, r, i, s) {
    const o = Gc(e)
      , l = o !== e && !ms(e)
      , u = o[t];
    if (u !== zy[t]) {
        const g = u.apply(e, s);
        return l ? zi(g) : g
    }
    let p = n;
    o !== e && (l ? p = function(g, m) {
        return n.call(this, zi(g), m, e)
    }
    : n.length > 2 && (p = function(g, m) {
        return n.call(this, g, m, e)
    }
    ));
    const h = u.call(o, p, r);
    return l && i ? i(h) : h
}
function zh(e, t, n, r) {
    const i = Gc(e);
    let s = n;
    return i !== e && (ms(e) ? n.length > 3 && (s = function(o, l, u) {
        return n.call(this, o, l, u, e)
    }
    ) : s = function(o, l, u) {
        return n.call(this, o, zi(l), u, e)
    }
    ),
    i[t](s, ...r)
}
function xf(e, t, n) {
    const r = Nn(e);
    ji(r, "iterate", uu);
    const i = r[t](...n);
    return (i === -1 || i === !1) && Xc(n[0]) ? (n[0] = Nn(n[0]),
    r[t](...n)) : i
}
function Ol(e, t, n=[]) {
    oa(),
    Xd();
    const r = Nn(e)[t].apply(e, n);
    return Qd(),
    aa(),
    r
}
const Uy = Vc("__proto__,__v_isRef,__isVue")
  , r_ = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(zs));
function Wy(e) {
    zs(e) || (e = String(e));
    const t = Nn(this);
    return ji(t, "has", e),
    t.hasOwnProperty(e)
}
class i_ {
    constructor(t=!1, n=!1) {
        this._isReadonly = t,
        this._isShallow = n
    }
    get(t, n, r) {
        if (n === "__v_skip")
            return t.__v_skip;
        const i = this._isReadonly
          , s = this._isShallow;
        if (n === "__v_isReactive")
            return !i;
        if (n === "__v_isReadonly")
            return i;
        if (n === "__v_isShallow")
            return s;
        if (n === "__v_raw")
            return r === (i ? s ? c_ : u_ : s ? l_ : a_).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(r) ? t : void 0;
        const o = Qt(t);
        if (!i) {
            let u;
            if (o && (u = jy[n]))
                return u;
            if (n === "hasOwnProperty")
                return Wy
        }
        const l = Reflect.get(t, n, sr(t) ? t : r);
        return (zs(n) ? r_.has(n) : Uy(n)) || (i || ji(t, "get", n),
        s) ? l : sr(l) ? o && Yd(n) ? l : l.value : gr(l) ? i ? yl(l) : Gr(l) : l
    }
}
class s_ extends i_ {
    constructor(t=!1) {
        super(!1, t)
    }
    set(t, n, r, i) {
        let s = t[n];
        if (!this._isShallow) {
            const u = Ao(s);
            if (!ms(r) && !Ao(r) && (s = Nn(s),
            r = Nn(r)),
            !Qt(t) && sr(s) && !sr(r))
                return u ? !1 : (s.value = r,
                !0)
        }
        const o = Qt(t) && Yd(n) ? Number(n) < t.length : Zn(t, n)
          , l = Reflect.set(t, n, r, sr(t) ? t : i);
        return t === Nn(i) && (o ? es(r, s) && Eo(t, "set", n, r) : Eo(t, "add", n, r)),
        l
    }
    deleteProperty(t, n) {
        const r = Zn(t, n);
        t[n];
        const i = Reflect.deleteProperty(t, n);
        return i && r && Eo(t, "delete", n, void 0),
        i
    }
    has(t, n) {
        const r = Reflect.has(t, n);
        return (!zs(n) || !r_.has(n)) && ji(t, "has", n),
        r
    }
    ownKeys(t) {
        return ji(t, "iterate", Qt(t) ? "length" : Sa),
        Reflect.ownKeys(t)
    }
}
class o_ extends i_ {
    constructor(t=!1) {
        super(!0, t)
    }
    set(t, n) {
        return !0
    }
    deleteProperty(t, n) {
        return !0
    }
}
const qy = new s_
  , Gy = new o_
  , Yy = new s_(!0)
  , Ky = new o_(!0)
  , ed = e => e
  , ju = e => Reflect.getPrototypeOf(e);
function Xy(e, t, n) {
    return function(...r) {
        const i = this.__v_raw
          , s = Nn(i)
          , o = Qa(s)
          , l = e === "entries" || e === Symbol.iterator && o
          , u = e === "keys" && o
          , p = i[e](...r)
          , h = n ? ed : t ? td : zi;
        return !t && ji(s, "iterate", u ? Zf : Sa),
        {
            next() {
                const {value: g, done: m} = p.next();
                return m ? {
                    value: g,
                    done: m
                } : {
                    value: l ? [h(g[0]), h(g[1])] : h(g),
                    done: m
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function zu(e) {
    return function(...t) {
        return e === "delete" ? !1 : e === "clear" ? void 0 : this
    }
}
function Qy(e, t) {
    const n = {
        get(i) {
            const s = this.__v_raw
              , o = Nn(s)
              , l = Nn(i);
            e || (es(i, l) && ji(o, "get", i),
            ji(o, "get", l));
            const {has: u} = ju(o)
              , p = t ? ed : e ? td : zi;
            if (u.call(o, i))
                return p(s.get(i));
            if (u.call(o, l))
                return p(s.get(l));
            s !== o && s.get(i)
        },
        get size() {
            const i = this.__v_raw;
            return !e && ji(Nn(i), "iterate", Sa),
            Reflect.get(i, "size", i)
        },
        has(i) {
            const s = this.__v_raw
              , o = Nn(s)
              , l = Nn(i);
            return e || (es(i, l) && ji(o, "has", i),
            ji(o, "has", l)),
            i === l ? s.has(i) : s.has(i) || s.has(l)
        },
        forEach(i, s) {
            const o = this
              , l = o.__v_raw
              , u = Nn(l)
              , p = t ? ed : e ? td : zi;
            return !e && ji(u, "iterate", Sa),
            l.forEach( (h, g) => i.call(s, p(h), p(g), o))
        }
    };
    return vr(n, e ? {
        add: zu("add"),
        set: zu("set"),
        delete: zu("delete"),
        clear: zu("clear")
    } : {
        add(i) {
            !t && !ms(i) && !Ao(i) && (i = Nn(i));
            const s = Nn(this);
            return ju(s).has.call(s, i) || (s.add(i),
            Eo(s, "add", i, i)),
            this
        },
        set(i, s) {
            !t && !ms(s) && !Ao(s) && (s = Nn(s));
            const o = Nn(this)
              , {has: l, get: u} = ju(o);
            let p = l.call(o, i);
            p || (i = Nn(i),
            p = l.call(o, i));
            const h = u.call(o, i);
            return o.set(i, s),
            p ? es(s, h) && Eo(o, "set", i, s) : Eo(o, "add", i, s),
            this
        },
        delete(i) {
            const s = Nn(this)
              , {has: o, get: l} = ju(s);
            let u = o.call(s, i);
            u || (i = Nn(i),
            u = o.call(s, i)),
            l && l.call(s, i);
            const p = s.delete(i);
            return u && Eo(s, "delete", i, void 0),
            p
        },
        clear() {
            const i = Nn(this)
              , s = i.size !== 0
              , o = i.clear();
            return s && Eo(i, "clear", void 0, void 0),
            o
        }
    }),
    ["keys", "values", "entries", Symbol.iterator].forEach(i => {
        n[i] = Xy(i, e, t)
    }
    ),
    n
}
function Yc(e, t) {
    const n = Qy(e, t);
    return (r, i, s) => i === "__v_isReactive" ? !e : i === "__v_isReadonly" ? e : i === "__v_raw" ? r : Reflect.get(Zn(n, i) && i in r ? n : r, i, s)
}
const Jy = {
    get: Yc(!1, !1)
}
  , Zy = {
    get: Yc(!1, !0)
}
  , ev = {
    get: Yc(!0, !1)
}
  , tv = {
    get: Yc(!0, !0)
}
  , a_ = new WeakMap
  , l_ = new WeakMap
  , u_ = new WeakMap
  , c_ = new WeakMap;
function nv(e) {
    switch (e) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function rv(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : nv(Cy(e))
}
function Gr(e) {
    return Ao(e) ? e : Kc(e, !1, qy, Jy, a_)
}
function Ts(e) {
    return Kc(e, !1, Yy, Zy, l_)
}
function yl(e) {
    return Kc(e, !0, Gy, ev, u_)
}
function Ca(e) {
    return Kc(e, !0, Ky, tv, c_)
}
function Kc(e, t, n, r, i) {
    if (!gr(e) || e.__v_raw && !(t && e.__v_isReactive))
        return e;
    const s = i.get(e);
    if (s)
        return s;
    const o = rv(e);
    if (o === 0)
        return e;
    const l = new Proxy(e,o === 2 ? r : n);
    return i.set(e, l),
    l
}
function so(e) {
    return Ao(e) ? so(e.__v_raw) : !!(e && e.__v_isReactive)
}
function Ao(e) {
    return !!(e && e.__v_isReadonly)
}
function ms(e) {
    return !!(e && e.__v_isShallow)
}
function Xc(e) {
    return e ? !!e.__v_raw : !1
}
function Nn(e) {
    const t = e && e.__v_raw;
    return t ? Nn(t) : e
}
function Eu(e) {
    return !Zn(e, "__v_skip") && Object.isExtensible(e) && qg(e, "__v_skip", !0),
    e
}
const zi = e => gr(e) ? Gr(e) : e
  , td = e => gr(e) ? yl(e) : e;
function sr(e) {
    return e ? e.__v_isRef === !0 : !1
}
function Ut(e) {
    return f_(e, !1)
}
function qr(e) {
    return f_(e, !0)
}
function f_(e, t) {
    return sr(e) ? e : new iv(e,t)
}
class iv {
    constructor(t, n) {
        this.dep = new qc,
        this.__v_isRef = !0,
        this.__v_isShallow = !1,
        this._rawValue = n ? t : Nn(t),
        this._value = n ? t : zi(t),
        this.__v_isShallow = n
    }
    get value() {
        return this.dep.track(),
        this._value
    }
    set value(t) {
        const n = this._rawValue
          , r = this.__v_isShallow || ms(t) || Ao(t);
        t = r ? t : Nn(t),
        es(t, n) && (this._rawValue = t,
        this._value = r ? t : zi(t),
        this.dep.trigger())
    }
}
function sv(e) {
    e.dep && e.dep.trigger()
}
function Re(e) {
    return sr(e) ? e.value : e
}
function Qr(e) {
    return dn(e) ? e() : Re(e)
}
const ov = {
    get: (e, t, n) => t === "__v_raw" ? e : Re(Reflect.get(e, t, n)),
    set: (e, t, n, r) => {
        const i = e[t];
        return sr(i) && !sr(n) ? (i.value = n,
        !0) : Reflect.set(e, t, n, r)
    }
};
function Zd(e) {
    return so(e) ? e : new Proxy(e,ov)
}
class av {
    constructor(t) {
        this.__v_isRef = !0,
        this._value = void 0;
        const n = this.dep = new qc
          , {get: r, set: i} = t(n.track.bind(n), n.trigger.bind(n));
        this._get = r,
        this._set = i
    }
    get value() {
        return this._value = this._get()
    }
    set value(t) {
        this._set(t)
    }
}
function Qc(e) {
    return new av(e)
}
function ol(e) {
    const t = Qt(e) ? new Array(e.length) : {};
    for (const n in e)
        t[n] = d_(e, n);
    return t
}
class lv {
    constructor(t, n, r) {
        this._object = t,
        this._key = n,
        this._defaultValue = r,
        this.__v_isRef = !0,
        this._value = void 0
    }
    get value() {
        const t = this._object[this._key];
        return this._value = t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
    get dep() {
        return Vy(Nn(this._object), this._key)
    }
}
class uv {
    constructor(t) {
        this._getter = t,
        this.__v_isRef = !0,
        this.__v_isReadonly = !0,
        this._value = void 0
    }
    get value() {
        return this._value = this._getter()
    }
}
function ko(e, t, n) {
    return sr(e) ? e : dn(e) ? new uv(e) : gr(e) && arguments.length > 1 ? d_(e, t, n) : Ut(e)
}
function d_(e, t, n) {
    const r = e[t];
    return sr(r) ? r : new lv(e,t,n)
}
class cv {
    constructor(t, n, r) {
        this.fn = t,
        this.setter = n,
        this._value = void 0,
        this.dep = new qc(this),
        this.__v_isRef = !0,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 16,
        this.globalVersion = lu - 1,
        this.next = void 0,
        this.effect = this,
        this.__v_isReadonly = !n,
        this.isSSR = r
    }
    notify() {
        if (this.flags |= 16,
        !(this.flags & 8) && xr !== this)
            return Qg(this, !0),
            !0
    }
    get value() {
        const t = this.dep.track();
        return e_(this),
        t && (t.version = this.dep.version),
        this._value
    }
    set value(t) {
        this.setter && this.setter(t)
    }
}
function fv(e, t, n=!1) {
    let r, i;
    return dn(e) ? r = e : (r = e.get,
    i = e.set),
    new cv(r,i,n)
}
const dv = {
    GET: "get",
    HAS: "has",
    ITERATE: "iterate"
}
  , hv = {
    SET: "set",
    ADD: "add",
    DELETE: "delete",
    CLEAR: "clear"
}
  , Uu = {}
  , yc = new WeakMap;
let Yo;
function h_() {
    return Yo
}
function Aa(e, t=!1, n=Yo) {
    if (n) {
        let r = yc.get(n);
        r || yc.set(n, r = []),
        r.push(e)
    }
}
function pv(e, t, n=jn) {
    const {immediate: r, deep: i, once: s, scheduler: o, augmentJob: l, call: u} = n
      , p = k => i ? k : ms(k) || i === !1 || i === 0 ? Co(k, 1) : Co(k);
    let h, g, m, w, E = !1, y = !1;
    if (sr(e) ? (g = () => e.value,
    E = ms(e)) : so(e) ? (g = () => p(e),
    E = !0) : Qt(e) ? (y = !0,
    E = e.some(k => so(k) || ms(k)),
    g = () => e.map(k => {
        if (sr(k))
            return k.value;
        if (so(k))
            return p(k);
        if (dn(k))
            return u ? u(k, 2) : k()
    }
    )) : dn(e) ? t ? g = u ? () => u(e, 2) : e : g = () => {
        if (m) {
            oa();
            try {
                m()
            } finally {
                aa()
            }
        }
        const k = Yo;
        Yo = h;
        try {
            return u ? u(e, 3, [w]) : e(w)
        } finally {
            Yo = k
        }
    }
    : g = Ps,
    t && i) {
        const k = g
          , S = i === !0 ? 1 / 0 : i;
        g = () => Co(k(), S)
    }
    const R = Lo()
      , P = () => {
        h.stop(),
        R && R.active && qd(R.effects, h)
    }
    ;
    if (s && t) {
        const k = t;
        t = (...S) => {
            k(...S),
            P()
        }
    }
    let x = y ? new Array(e.length).fill(Uu) : Uu;
    const v = k => {
        if (!(!(h.flags & 1) || !h.dirty && !k))
            if (t) {
                const S = h.run();
                if (i || E || (y ? S.some( (W, K) => es(W, x[K])) : es(S, x))) {
                    m && m();
                    const W = Yo;
                    Yo = h;
                    try {
                        const K = [S, x === Uu ? void 0 : y && x[0] === Uu ? [] : x, w];
                        u ? u(t, 3, K) : t(...K),
                        x = S
                    } finally {
                        Yo = W
                    }
                }
            } else
                h.run()
    }
    ;
    return l && l(v),
    h = new au(g),
    h.scheduler = o ? () => o(v, !1) : v,
    w = k => Aa(k, !1, h),
    m = h.onStop = () => {
        const k = yc.get(h);
        if (k) {
            if (u)
                u(k, 4);
            else
                for (const S of k)
                    S();
            yc.delete(h)
        }
    }
    ,
    t ? r ? v(!0) : x = h.run() : o ? o(v.bind(null, !0), !0) : h.run(),
    P.pause = h.pause.bind(h),
    P.resume = h.resume.bind(h),
    P.stop = P,
    P
}
function Co(e, t=1 / 0, n) {
    if (t <= 0 || !gr(e) || e.__v_skip || (n = n || new Set,
    n.has(e)))
        return e;
    if (n.add(e),
    t--,
    sr(e))
        Co(e.value, t, n);
    else if (Qt(e))
        for (let r = 0; r < e.length; r++)
            Co(e[r], t, n);
    else if (Fa(e) || Qa(e))
        e.forEach(r => {
            Co(r, t, n)
        }
        );
    else if (jc(e)) {
        for (const r in e)
            Co(e[r], t, n);
        for (const r of Object.getOwnPropertySymbols(e))
            Object.prototype.propertyIsEnumerable.call(e, r) && Co(e[r], t, n)
    }
    return e
}
/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const p_ = [];
function gv(e) {
    p_.push(e)
}
function _v() {
    p_.pop()
}
function mv(e, t) {}
const yv = {
    SETUP_FUNCTION: 0,
    0: "SETUP_FUNCTION",
    RENDER_FUNCTION: 1,
    1: "RENDER_FUNCTION",
    NATIVE_EVENT_HANDLER: 5,
    5: "NATIVE_EVENT_HANDLER",
    COMPONENT_EVENT_HANDLER: 6,
    6: "COMPONENT_EVENT_HANDLER",
    VNODE_HOOK: 7,
    7: "VNODE_HOOK",
    DIRECTIVE_HOOK: 8,
    8: "DIRECTIVE_HOOK",
    TRANSITION_HOOK: 9,
    9: "TRANSITION_HOOK",
    APP_ERROR_HANDLER: 10,
    10: "APP_ERROR_HANDLER",
    APP_WARN_HANDLER: 11,
    11: "APP_WARN_HANDLER",
    FUNCTION_REF: 12,
    12: "FUNCTION_REF",
    ASYNC_COMPONENT_LOADER: 13,
    13: "ASYNC_COMPONENT_LOADER",
    SCHEDULER: 14,
    14: "SCHEDULER",
    COMPONENT_UPDATE: 15,
    15: "COMPONENT_UPDATE",
    APP_UNMOUNT_CLEANUP: 16,
    16: "APP_UNMOUNT_CLEANUP"
}
  , vv = {
    sp: "serverPrefetch hook",
    bc: "beforeCreate hook",
    c: "created hook",
    bm: "beforeMount hook",
    m: "mounted hook",
    bu: "beforeUpdate hook",
    u: "updated",
    bum: "beforeUnmount hook",
    um: "unmounted hook",
    a: "activated hook",
    da: "deactivated hook",
    ec: "errorCaptured hook",
    rtc: "renderTracked hook",
    rtg: "renderTriggered hook",
    0: "setup function",
    1: "render function",
    2: "watcher getter",
    3: "watcher callback",
    4: "watcher cleanup function",
    5: "native event handler",
    6: "component event handler",
    7: "vnode hook",
    8: "directive hook",
    9: "transition hook",
    10: "app errorHandler",
    11: "app warnHandler",
    12: "ref function",
    13: "async component loader",
    14: "scheduler flush",
    15: "component update",
    16: "app unmount cleanup function"
};
function vl(e, t, n, r) {
    try {
        return r ? e(...r) : e()
    } catch (i) {
        Ia(i, t, n)
    }
}
function Rs(e, t, n, r) {
    if (dn(e)) {
        const i = vl(e, t, n, r);
        return i && Gd(i) && i.catch(s => {
            Ia(s, t, n)
        }
        ),
        i
    }
    if (Qt(e)) {
        const i = [];
        for (let s = 0; s < e.length; s++)
            i.push(Rs(e[s], t, n, r));
        return i
    }
}
function Ia(e, t, n, r=!0) {
    const i = t ? t.vnode : null
      , {errorHandler: s, throwUnhandledErrorInProduction: o} = t && t.appContext.config || jn;
    if (t) {
        let l = t.parent;
        const u = t.proxy
          , p = `https://vuejs.org/error-reference/#runtime-${n}`;
        for (; l; ) {
            const h = l.ec;
            if (h) {
                for (let g = 0; g < h.length; g++)
                    if (h[g](e, u, p) === !1)
                        return
            }
            l = l.parent
        }
        if (s) {
            oa(),
            vl(s, null, 10, [e, u, p]),
            aa();
            return
        }
    }
    bv(e, n, i, r, o)
}
function bv(e, t, n, r=!0, i=!1) {
    if (i)
        throw e;
    console.error(e)
}
const ts = [];
let no = -1;
const tl = [];
let Ko = null
  , qa = 0;
const g_ = Promise.resolve();
let vc = null;
function Ci(e) {
    const t = vc || g_;
    return e ? t.then(this ? e.bind(this) : e) : t
}
function wv(e) {
    let t = no + 1
      , n = ts.length;
    for (; t < n; ) {
        const r = t + n >>> 1
          , i = ts[r]
          , s = fu(i);
        s < e || s === e && i.flags & 2 ? t = r + 1 : n = r
    }
    return t
}
function eh(e) {
    if (!(e.flags & 1)) {
        const t = fu(e)
          , n = ts[ts.length - 1];
        !n || !(e.flags & 2) && t >= fu(n) ? ts.push(e) : ts.splice(wv(t), 0, e),
        e.flags |= 1,
        __()
    }
}
function __() {
    vc || (vc = g_.then(m_))
}
function cu(e) {
    Qt(e) ? tl.push(...e) : Ko && e.id === -1 ? Ko.splice(qa + 1, 0, e) : e.flags & 1 || (tl.push(e),
    e.flags |= 1),
    __()
}
function Uh(e, t, n=no + 1) {
    for (; n < ts.length; n++) {
        const r = ts[n];
        if (r && r.flags & 2) {
            if (e && r.id !== e.uid)
                continue;
            ts.splice(n, 1),
            n--,
            r.flags & 4 && (r.flags &= -2),
            r(),
            r.flags & 4 || (r.flags &= -2)
        }
    }
}
function bc(e) {
    if (tl.length) {
        const t = [...new Set(tl)].sort( (n, r) => fu(n) - fu(r));
        if (tl.length = 0,
        Ko) {
            Ko.push(...t);
            return
        }
        for (Ko = t,
        qa = 0; qa < Ko.length; qa++) {
            const n = Ko[qa];
            n.flags & 4 && (n.flags &= -2),
            n.flags & 8 || n(),
            n.flags &= -2
        }
        Ko = null,
        qa = 0
    }
}
const fu = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
function m_(e) {
    try {
        for (no = 0; no < ts.length; no++) {
            const t = ts[no];
            t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2),
            vl(t, t.i, t.i ? 15 : 14),
            t.flags & 4 || (t.flags &= -2))
        }
    } finally {
        for (; no < ts.length; no++) {
            const t = ts[no];
            t && (t.flags &= -2)
        }
        no = -1,
        ts.length = 0,
        bc(),
        vc = null,
        (ts.length || tl.length) && m_()
    }
}
let Ga, Wu = [];
function y_(e, t) {
    var n, r;
    Ga = e,
    Ga ? (Ga.enabled = !0,
    Wu.forEach( ({event: i, args: s}) => Ga.emit(i, ...s)),
    Wu = []) : typeof window < "u" && window.HTMLElement && !((r = (n = window.navigator) == null ? void 0 : n.userAgent) != null && r.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(s => {
        y_(s, t)
    }
    ),
    setTimeout( () => {
        Ga || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null,
        Wu = [])
    }
    , 3e3)) : Wu = []
}
let Di = null
  , Jc = null;
function du(e) {
    const t = Di;
    return Di = e,
    Jc = e && e.type.__scopeId || null,
    t
}
function Dv(e) {
    Jc = e
}
function Ev() {
    Jc = null
}
const Cv = e => Tn;
function Tn(e, t=Di, n) {
    if (!t || e._n)
        return e;
    const r = (...i) => {
        r._d && ud(-1);
        const s = du(t);
        let o;
        try {
            o = e(...i)
        } finally {
            du(s),
            r._d && ud(1)
        }
        return o
    }
    ;
    return r._n = !0,
    r._c = !0,
    r._d = !0,
    r
}
function xv(e, t) {
    if (Di === null)
        return e;
    const n = Su(Di)
      , r = e.dirs || (e.dirs = []);
    for (let i = 0; i < t.length; i++) {
        let[s,o,l,u=jn] = t[i];
        s && (dn(s) && (s = {
            mounted: s,
            updated: s
        }),
        s.deep && Co(o),
        r.push({
            dir: s,
            instance: n,
            value: o,
            oldValue: void 0,
            arg: l,
            modifiers: u
        }))
    }
    return e
}
function ro(e, t, n, r) {
    const i = e.dirs
      , s = t && t.dirs;
    for (let o = 0; o < i.length; o++) {
        const l = i[o];
        s && (l.oldValue = s[o].value);
        let u = l.dir[r];
        u && (oa(),
        Rs(u, n, 8, [e.el, l, e, t]),
        aa())
    }
}
const v_ = Symbol("_vte")
  , b_ = e => e.__isTeleport
  , Jl = e => e && (e.disabled || e.disabled === "")
  , Wh = e => e && (e.defer || e.defer === "")
  , qh = e => typeof SVGElement < "u" && e instanceof SVGElement
  , Gh = e => typeof MathMLElement == "function" && e instanceof MathMLElement
  , nd = (e, t) => {
    const n = e && e.to;
    return Sr(n) ? t ? t(n) : null : n
}
  , w_ = {
    name: "Teleport",
    __isTeleport: !0,
    process(e, t, n, r, i, s, o, l, u, p) {
        const {mc: h, pc: g, pbc: m, o: {insert: w, querySelector: E, createText: y, createComment: R}} = p
          , P = Jl(t.props);
        let {shapeFlag: x, children: v, dynamicChildren: k} = t;
        if (e == null) {
            const S = t.el = y("")
              , W = t.anchor = y("");
            w(S, n, r),
            w(W, n, r);
            const K = (fe, ge) => {
                x & 16 && (i && i.isCE && (i.ce._teleportTarget = fe),
                h(v, fe, ge, i, s, o, l, u))
            }
              , be = () => {
                const fe = t.target = nd(t.props, E)
                  , ge = E_(fe, t, y, w);
                fe && (o !== "svg" && qh(fe) ? o = "svg" : o !== "mathml" && Gh(fe) && (o = "mathml"),
                P || (K(fe, ge),
                lc(t, !1)))
            }
            ;
            P && (K(n, W),
            lc(t, !0)),
            Wh(t.props) ? bi( () => {
                be(),
                t.el.__isMounted = !0
            }
            , s) : be()
        } else {
            if (Wh(t.props) && !e.el.__isMounted) {
                bi( () => {
                    w_.process(e, t, n, r, i, s, o, l, u, p),
                    delete e.el.__isMounted
                }
                , s);
                return
            }
            t.el = e.el,
            t.targetStart = e.targetStart;
            const S = t.anchor = e.anchor
              , W = t.target = e.target
              , K = t.targetAnchor = e.targetAnchor
              , be = Jl(e.props)
              , fe = be ? n : W
              , ge = be ? S : K;
            if (o === "svg" || qh(W) ? o = "svg" : (o === "mathml" || Gh(W)) && (o = "mathml"),
            k ? (m(e.dynamicChildren, k, fe, i, s, o, l),
            ph(e, t, !0)) : u || g(e, t, fe, ge, i, s, o, l, !1),
            P)
                be ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : qu(t, n, S, p, 1);
            else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                const J = t.target = nd(t.props, E);
                J && qu(t, J, null, p, 0)
            } else
                be && qu(t, W, K, p, 1);
            lc(t, P)
        }
    },
    remove(e, t, n, {um: r, o: {remove: i}}, s) {
        const {shapeFlag: o, children: l, anchor: u, targetStart: p, targetAnchor: h, target: g, props: m} = e;
        if (g && (i(p),
        i(h)),
        s && i(u),
        o & 16) {
            const w = s || !Jl(m);
            for (let E = 0; E < l.length; E++) {
                const y = l[E];
                r(y, t, n, w, !!y.dynamicChildren)
            }
        }
    },
    move: qu,
    hydrate: Sv
};
function qu(e, t, n, {o: {insert: r}, m: i}, s=2) {
    s === 0 && r(e.targetAnchor, t, n);
    const {el: o, anchor: l, shapeFlag: u, children: p, props: h} = e
      , g = s === 2;
    if (g && r(o, t, n),
    (!g || Jl(h)) && u & 16)
        for (let m = 0; m < p.length; m++)
            i(p[m], t, n, 2);
    g && r(l, t, n)
}
function Sv(e, t, n, r, i, s, {o: {nextSibling: o, parentNode: l, querySelector: u, insert: p, createText: h}}, g) {
    const m = t.target = nd(t.props, u);
    if (m) {
        const w = Jl(t.props)
          , E = m._lpa || m.firstChild;
        if (t.shapeFlag & 16)
            if (w)
                t.anchor = g(o(e), t, l(e), n, r, i, s),
                t.targetStart = E,
                t.targetAnchor = E && o(E);
            else {
                t.anchor = o(e);
                let y = E;
                for (; y; ) {
                    if (y && y.nodeType === 8) {
                        if (y.data === "teleport start anchor")
                            t.targetStart = y;
                        else if (y.data === "teleport anchor") {
                            t.targetAnchor = y,
                            m._lpa = t.targetAnchor && o(t.targetAnchor);
                            break
                        }
                    }
                    y = o(y)
                }
                t.targetAnchor || E_(m, t, h, p),
                g(E && o(E), t, m, n, r, i, s)
            }
        lc(t, w)
    }
    return t.anchor && o(t.anchor)
}
const D_ = w_;
function lc(e, t) {
    const n = e.ctx;
    if (n && n.ut) {
        let r, i;
        for (t ? (r = e.el,
        i = e.anchor) : (r = e.targetStart,
        i = e.targetAnchor); r && r !== i; )
            r.nodeType === 1 && r.setAttribute("data-v-owner", n.uid),
            r = r.nextSibling;
        n.ut()
    }
}
function E_(e, t, n, r) {
    const i = t.targetStart = n("")
      , s = t.targetAnchor = n("");
    return i[v_] = s,
    e && (r(i, e),
    r(s, e)),
    s
}
const Xo = Symbol("_leaveCb")
  , Gu = Symbol("_enterCb");
function th() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return xi( () => {
        e.isMounted = !0
    }
    ),
    Io( () => {
        e.isUnmounting = !0
    }
    ),
    e
}
const Es = [Function, Array]
  , nh = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Es,
    onEnter: Es,
    onAfterEnter: Es,
    onEnterCancelled: Es,
    onBeforeLeave: Es,
    onLeave: Es,
    onAfterLeave: Es,
    onLeaveCancelled: Es,
    onBeforeAppear: Es,
    onAppear: Es,
    onAfterAppear: Es,
    onAppearCancelled: Es
}
  , C_ = e => {
    const t = e.subTree;
    return t.component ? C_(t.component) : t
}
  , Tv = {
    name: "BaseTransition",
    props: nh,
    setup(e, {slots: t}) {
        const n = Or()
          , r = th();
        return () => {
            const i = t.default && Zc(t.default(), !0);
            if (!i || !i.length)
                return;
            const s = x_(i)
              , o = Nn(e)
              , {mode: l} = o;
            if (r.isLeaving)
                return Sf(s);
            const u = Yh(s);
            if (!u)
                return Sf(s);
            let p = al(u, o, r, n, g => p = g);
            u.type !== si && Ro(u, p);
            let h = n.subTree && Yh(n.subTree);
            if (h && h.type !== si && !Vs(u, h) && C_(n).type !== si) {
                let g = al(h, o, r, n);
                if (Ro(h, g),
                l === "out-in" && u.type !== si)
                    return r.isLeaving = !0,
                    g.afterLeave = () => {
                        r.isLeaving = !1,
                        n.job.flags & 8 || n.update(),
                        delete g.afterLeave,
                        h = void 0
                    }
                    ,
                    Sf(s);
                l === "in-out" && u.type !== si ? g.delayLeave = (m, w, E) => {
                    const y = T_(r, h);
                    y[String(h.key)] = h,
                    m[Xo] = () => {
                        w(),
                        m[Xo] = void 0,
                        delete p.delayedLeave,
                        h = void 0
                    }
                    ,
                    p.delayedLeave = () => {
                        E(),
                        delete p.delayedLeave,
                        h = void 0
                    }
                }
                : h = void 0
            } else
                h && (h = void 0);
            return s
        }
    }
};
function x_(e) {
    let t = e[0];
    if (e.length > 1) {
        for (const n of e)
            if (n.type !== si) {
                t = n;
                break
            }
    }
    return t
}
const S_ = Tv;
function T_(e, t) {
    const {leavingVNodes: n} = e;
    let r = n.get(t.type);
    return r || (r = Object.create(null),
    n.set(t.type, r)),
    r
}
function al(e, t, n, r, i) {
    const {appear: s, mode: o, persisted: l=!1, onBeforeEnter: u, onEnter: p, onAfterEnter: h, onEnterCancelled: g, onBeforeLeave: m, onLeave: w, onAfterLeave: E, onLeaveCancelled: y, onBeforeAppear: R, onAppear: P, onAfterAppear: x, onAppearCancelled: v} = t
      , k = String(e.key)
      , S = T_(n, e)
      , W = (fe, ge) => {
        fe && Rs(fe, r, 9, ge)
    }
      , K = (fe, ge) => {
        const J = ge[1];
        W(fe, ge),
        Qt(fe) ? fe.every(re => re.length <= 1) && J() : fe.length <= 1 && J()
    }
      , be = {
        mode: o,
        persisted: l,
        beforeEnter(fe) {
            let ge = u;
            if (!n.isMounted)
                if (s)
                    ge = R || u;
                else
                    return;
            fe[Xo] && fe[Xo](!0);
            const J = S[k];
            J && Vs(e, J) && J.el[Xo] && J.el[Xo](),
            W(ge, [fe])
        },
        enter(fe) {
            let ge = p
              , J = h
              , re = g;
            if (!n.isMounted)
                if (s)
                    ge = P || p,
                    J = x || h,
                    re = v || g;
                else
                    return;
            let ee = !1;
            const Y = fe[Gu] = Z => {
                ee || (ee = !0,
                Z ? W(re, [fe]) : W(J, [fe]),
                be.delayedLeave && be.delayedLeave(),
                fe[Gu] = void 0)
            }
            ;
            ge ? K(ge, [fe, Y]) : Y()
        },
        leave(fe, ge) {
            const J = String(e.key);
            if (fe[Gu] && fe[Gu](!0),
            n.isUnmounting)
                return ge();
            W(m, [fe]);
            let re = !1;
            const ee = fe[Xo] = Y => {
                re || (re = !0,
                ge(),
                Y ? W(y, [fe]) : W(E, [fe]),
                fe[Xo] = void 0,
                S[J] === e && delete S[J])
            }
            ;
            S[J] = e,
            w ? K(w, [fe, ee]) : ee()
        },
        clone(fe) {
            const ge = al(fe, t, n, r, i);
            return i && i(ge),
            ge
        }
    };
    return be
}
function Sf(e) {
    if (Cu(e))
        return e = Us(e),
        e.children = null,
        e
}
function Yh(e) {
    if (!Cu(e))
        return b_(e.type) && e.children ? x_(e.children) : e;
    const {shapeFlag: t, children: n} = e;
    if (n) {
        if (t & 16)
            return n[0];
        if (t & 32 && dn(n.default))
            return n.default()
    }
}
function Ro(e, t) {
    e.shapeFlag & 6 && e.component ? (e.transition = t,
    Ro(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent),
    e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function Zc(e, t=!1, n) {
    let r = []
      , i = 0;
    for (let s = 0; s < e.length; s++) {
        let o = e[s];
        const l = n == null ? o.key : String(n) + String(o.key != null ? o.key : s);
        o.type === er ? (o.patchFlag & 128 && i++,
        r = r.concat(Zc(o.children, t, l))) : (t || o.type !== si) && r.push(l != null ? Us(o, {
            key: l
        }) : o)
    }
    if (i > 1)
        for (let s = 0; s < r.length; s++)
            r[s].patchFlag = -2;
    return r
}
/*! #__NO_SIDE_EFFECTS__ */
function Mn(e, t) {
    return dn(e) ? vr({
        name: e.name
    }, t, {
        setup: e
    }) : e
}
function Zl() {
    const e = Or();
    return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : ""
}
function rh(e) {
    e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0]
}
function Un(e) {
    const t = Or()
      , n = qr(null);
    if (t) {
        const i = t.refs === jn ? t.refs = {} : t.refs;
        Object.defineProperty(i, e, {
            enumerable: !0,
            get: () => n.value,
            set: s => n.value = s
        })
    }
    return n
}
function hu(e, t, n, r, i=!1) {
    if (Qt(e)) {
        e.forEach( (E, y) => hu(E, t && (Qt(t) ? t[y] : t), n, r, i));
        return
    }
    if (ta(r) && !i) {
        r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && hu(e, t, n, r.component.subTree);
        return
    }
    const s = r.shapeFlag & 4 ? Su(r.component) : r.el
      , o = i ? null : s
      , {i: l, r: u} = e
      , p = t && t.r
      , h = l.refs === jn ? l.refs = {} : l.refs
      , g = l.setupState
      , m = Nn(g)
      , w = g === jn ? () => !1 : E => Zn(m, E);
    if (p != null && p !== u && (Sr(p) ? (h[p] = null,
    w(p) && (g[p] = null)) : sr(p) && (p.value = null)),
    dn(u))
        vl(u, l, 12, [o, h]);
    else {
        const E = Sr(u)
          , y = sr(u);
        if (E || y) {
            const R = () => {
                if (e.f) {
                    const P = E ? w(u) ? g[u] : h[u] : u.value;
                    i ? Qt(P) && qd(P, s) : Qt(P) ? P.includes(s) || P.push(s) : E ? (h[u] = [s],
                    w(u) && (g[u] = h[u])) : (u.value = [s],
                    e.k && (h[e.k] = u.value))
                } else
                    E ? (h[u] = o,
                    w(u) && (g[u] = o)) : y && (u.value = o,
                    e.k && (h[e.k] = o))
            }
            ;
            o ? (R.id = -1,
            bi(R, n)) : R()
        }
    }
}
let Kh = !1;
const za = () => {
    Kh || (console.error("Hydration completed but contains mismatches."),
    Kh = !0)
}
  , Pv = e => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject"
  , kv = e => e.namespaceURI.includes("MathML")
  , Yu = e => {
    if (e.nodeType === 1) {
        if (Pv(e))
            return "svg";
        if (kv(e))
            return "mathml"
    }
}
  , Ka = e => e.nodeType === 8;
function Av(e) {
    const {mt: t, p: n, o: {patchProp: r, createText: i, nextSibling: s, parentNode: o, remove: l, insert: u, createComment: p}} = e
      , h = (v, k) => {
        if (!k.hasChildNodes()) {
            n(null, v, k),
            bc(),
            k._vnode = v;
            return
        }
        g(k.firstChild, v, null, null, null),
        bc(),
        k._vnode = v
    }
      , g = (v, k, S, W, K, be=!1) => {
        be = be || !!k.dynamicChildren;
        const fe = Ka(v) && v.data === "["
          , ge = () => y(v, k, S, W, K, fe)
          , {type: J, ref: re, shapeFlag: ee, patchFlag: Y} = k;
        let Z = v.nodeType;
        k.el = v,
        Y === -2 && (be = !1,
        k.dynamicChildren = null);
        let Q = null;
        switch (J) {
        case na:
            Z !== 3 ? k.children === "" ? (u(k.el = i(""), o(v), v),
            Q = v) : Q = ge() : (v.data !== k.children && (za(),
            v.data = k.children),
            Q = s(v));
            break;
        case si:
            x(v) ? (Q = s(v),
            P(k.el = v.content.firstChild, v, S)) : Z !== 8 || fe ? Q = ge() : Q = s(v);
            break;
        case Pa:
            if (fe && (v = s(v),
            Z = v.nodeType),
            Z === 1 || Z === 3) {
                Q = v;
                const ue = !k.children.length;
                for (let se = 0; se < k.staticCount; se++)
                    ue && (k.children += Q.nodeType === 1 ? Q.outerHTML : Q.data),
                    se === k.staticCount - 1 && (k.anchor = Q),
                    Q = s(Q);
                return fe ? s(Q) : Q
            } else
                ge();
            break;
        case er:
            fe ? Q = E(v, k, S, W, K, be) : Q = ge();
            break;
        default:
            if (ee & 1)
                (Z !== 1 || k.type.toLowerCase() !== v.tagName.toLowerCase()) && !x(v) ? Q = ge() : Q = m(v, k, S, W, K, be);
            else if (ee & 6) {
                k.slotScopeIds = K;
                const ue = o(v);
                if (fe ? Q = R(v) : Ka(v) && v.data === "teleport start" ? Q = R(v, v.data, "teleport end") : Q = s(v),
                t(k, ue, null, S, W, Yu(ue), be),
                ta(k) && !k.type.__asyncResolved) {
                    let se;
                    fe ? (se = tn(er),
                    se.anchor = Q ? Q.previousSibling : ue.lastChild) : se = v.nodeType === 3 ? To("") : tn("div"),
                    se.el = v,
                    k.component.subTree = se
                }
            } else
                ee & 64 ? Z !== 8 ? Q = ge() : Q = k.type.hydrate(v, k, S, W, K, be, e, w) : ee & 128 && (Q = k.type.hydrate(v, k, S, W, Yu(o(v)), K, be, e, g))
        }
        return re != null && hu(re, null, W, k),
        Q
    }
      , m = (v, k, S, W, K, be) => {
        be = be || !!k.dynamicChildren;
        const {type: fe, props: ge, patchFlag: J, shapeFlag: re, dirs: ee, transition: Y} = k
          , Z = fe === "input" || fe === "option";
        if (Z || J !== -1) {
            ee && ro(k, null, S, "created");
            let Q = !1;
            if (x(v)) {
                Q = X_(null, Y) && S && S.vnode.props && S.vnode.props.appear;
                const se = v.content.firstChild;
                Q && Y.beforeEnter(se),
                P(se, v, S),
                k.el = v = se
            }
            if (re & 16 && !(ge && (ge.innerHTML || ge.textContent))) {
                let se = w(v.firstChild, k, v, S, W, K, be);
                for (; se; ) {
                    Ku(v, 1) || za();
                    const ye = se;
                    se = se.nextSibling,
                    l(ye)
                }
            } else if (re & 8) {
                let se = k.children;
                se[0] === `
` && (v.tagName === "PRE" || v.tagName === "TEXTAREA") && (se = se.slice(1)),
                v.textContent !== se && (Ku(v, 0) || za(),
                v.textContent = k.children)
            }
            if (ge) {
                if (Z || !be || J & 48) {
                    const se = v.tagName.includes("-");
                    for (const ye in ge)
                        (Z && (ye.endsWith("value") || ye === "indeterminate") || Du(ye) && !Ja(ye) || ye[0] === "." || se) && r(v, ye, null, ge[ye], void 0, S)
                } else if (ge.onClick)
                    r(v, "onClick", null, ge.onClick, void 0, S);
                else if (J & 4 && so(ge.style))
                    for (const se in ge.style)
                        ge.style[se]
            }
            let ue;
            (ue = ge && ge.onVnodeBeforeMount) && ls(ue, S, k),
            ee && ro(k, null, S, "beforeMount"),
            ((ue = ge && ge.onVnodeMounted) || ee || Q) && sm( () => {
                ue && ls(ue, S, k),
                Q && Y.enter(v),
                ee && ro(k, null, S, "mounted")
            }
            , W)
        }
        return v.nextSibling
    }
      , w = (v, k, S, W, K, be, fe) => {
        fe = fe || !!k.dynamicChildren;
        const ge = k.children
          , J = ge.length;
        for (let re = 0; re < J; re++) {
            const ee = fe ? ge[re] : ge[re] = us(ge[re])
              , Y = ee.type === na;
            v ? (Y && !fe && re + 1 < J && us(ge[re + 1]).type === na && (u(i(v.data.slice(ee.children.length)), S, s(v)),
            v.data = ee.children),
            v = g(v, ee, W, K, be, fe)) : Y && !ee.children ? u(ee.el = i(""), S) : (Ku(S, 1) || za(),
            n(null, ee, S, null, W, K, Yu(S), be))
        }
        return v
    }
      , E = (v, k, S, W, K, be) => {
        const {slotScopeIds: fe} = k;
        fe && (K = K ? K.concat(fe) : fe);
        const ge = o(v)
          , J = w(s(v), k, ge, S, W, K, be);
        return J && Ka(J) && J.data === "]" ? s(k.anchor = J) : (za(),
        u(k.anchor = p("]"), ge, J),
        J)
    }
      , y = (v, k, S, W, K, be) => {
        if (Ku(v.parentElement, 1) || za(),
        k.el = null,
        be) {
            const J = R(v);
            for (; ; ) {
                const re = s(v);
                if (re && re !== J)
                    l(re);
                else
                    break
            }
        }
        const fe = s(v)
          , ge = o(v);
        return l(v),
        n(null, k, ge, fe, S, W, Yu(ge), K),
        S && (S.vnode.el = k.el,
        rf(S, k.el)),
        fe
    }
      , R = (v, k="[", S="]") => {
        let W = 0;
        for (; v; )
            if (v = s(v),
            v && Ka(v) && (v.data === k && W++,
            v.data === S)) {
                if (W === 0)
                    return s(v);
                W--
            }
        return v
    }
      , P = (v, k, S) => {
        const W = k.parentNode;
        W && W.replaceChild(v, k);
        let K = S;
        for (; K; )
            K.vnode.el === k && (K.vnode.el = K.subTree.el = v),
            K = K.parent
    }
      , x = v => v.nodeType === 1 && v.tagName === "TEMPLATE";
    return [h, g]
}
const Xh = "data-allow-mismatch"
  , Rv = {
    0: "text",
    1: "children",
    2: "class",
    3: "style",
    4: "attribute"
};
function Ku(e, t) {
    if (t === 0 || t === 1)
        for (; e && !e.hasAttribute(Xh); )
            e = e.parentElement;
    const n = e && e.getAttribute(Xh);
    if (n == null)
        return !1;
    if (n === "")
        return !0;
    {
        const r = n.split(",");
        return t === 0 && r.includes("children") ? !0 : n.split(",").includes(Rv[t])
    }
}
const Ov = Uc().requestIdleCallback || (e => setTimeout(e, 1))
  , Mv = Uc().cancelIdleCallback || (e => clearTimeout(e))
  , Lv = (e=1e4) => t => {
    const n = Ov(t, {
        timeout: e
    });
    return () => Mv(n)
}
;
function Fv(e) {
    const {top: t, left: n, bottom: r, right: i} = e.getBoundingClientRect()
      , {innerHeight: s, innerWidth: o} = window;
    return (t > 0 && t < s || r > 0 && r < s) && (n > 0 && n < o || i > 0 && i < o)
}
const Iv = e => (t, n) => {
    const r = new IntersectionObserver(i => {
        for (const s of i)
            if (s.isIntersecting) {
                r.disconnect(),
                t();
                break
            }
    }
    ,e);
    return n(i => {
        if (i instanceof Element) {
            if (Fv(i))
                return t(),
                r.disconnect(),
                !1;
            r.observe(i)
        }
    }
    ),
    () => r.disconnect()
}
  , Nv = e => t => {
    if (e) {
        const n = matchMedia(e);
        if (n.matches)
            t();
        else
            return n.addEventListener("change", t, {
                once: !0
            }),
            () => n.removeEventListener("change", t)
    }
}
  , $v = (e=[]) => (t, n) => {
    Sr(e) && (e = [e]);
    let r = !1;
    const i = o => {
        r || (r = !0,
        s(),
        t(),
        o.target.dispatchEvent(new o.constructor(o.type,o)))
    }
      , s = () => {
        n(o => {
            for (const l of e)
                o.removeEventListener(l, i)
        }
        )
    }
    ;
    return n(o => {
        for (const l of e)
            o.addEventListener(l, i, {
                once: !0
            })
    }
    ),
    s
}
;
function Bv(e, t) {
    if (Ka(e) && e.data === "[") {
        let n = 1
          , r = e.nextSibling;
        for (; r; ) {
            if (r.nodeType === 1) {
                if (t(r) === !1)
                    break
            } else if (Ka(r))
                if (r.data === "]") {
                    if (--n === 0)
                        break
                } else
                    r.data === "[" && n++;
            r = r.nextSibling
        }
    } else
        t(e)
}
const ta = e => !!e.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
function Xt(e) {
    dn(e) && (e = {
        loader: e
    });
    const {loader: t, loadingComponent: n, errorComponent: r, delay: i=200, hydrate: s, timeout: o, suspensible: l=!0, onError: u} = e;
    let p = null, h, g = 0;
    const m = () => (g++,
    p = null,
    w())
      , w = () => {
        let E;
        return p || (E = p = t().catch(y => {
            if (y = y instanceof Error ? y : new Error(String(y)),
            u)
                return new Promise( (R, P) => {
                    u(y, () => R(m()), () => P(y), g + 1)
                }
                );
            throw y
        }
        ).then(y => E !== p && p ? p : (y && (y.__esModule || y[Symbol.toStringTag] === "Module") && (y = y.default),
        h = y,
        y)))
    }
    ;
    return Mn({
        name: "AsyncComponentWrapper",
        __asyncLoader: w,
        __asyncHydrate(E, y, R) {
            const P = s ? () => {
                const x = s(R, v => Bv(E, v));
                x && (y.bum || (y.bum = [])).push(x)
            }
            : R;
            h ? P() : w().then( () => !y.isUnmounted && P())
        },
        get __asyncResolved() {
            return h
        },
        setup() {
            const E = wi;
            if (rh(E),
            h)
                return () => Tf(h, E);
            const y = v => {
                p = null,
                Ia(v, E, 13, !r)
            }
            ;
            if (l && E.suspense || ll)
                return w().then(v => () => Tf(v, E)).catch(v => (y(v),
                () => r ? tn(r, {
                    error: v
                }) : null));
            const R = Ut(!1)
              , P = Ut()
              , x = Ut(!!i);
            return i && setTimeout( () => {
                x.value = !1
            }
            , i),
            o != null && setTimeout( () => {
                if (!R.value && !P.value) {
                    const v = new Error(`Async component timed out after ${o}ms.`);
                    y(v),
                    P.value = v
                }
            }
            , o),
            w().then( () => {
                R.value = !0,
                E.parent && Cu(E.parent.vnode) && E.parent.update()
            }
            ).catch(v => {
                y(v),
                P.value = v
            }
            ),
            () => {
                if (R.value && h)
                    return Tf(h, E);
                if (P.value && r)
                    return tn(r, {
                        error: P.value
                    });
                if (n && !x.value)
                    return tn(n)
            }
        }
    })
}
function Tf(e, t) {
    const {ref: n, props: r, children: i, ce: s} = t.vnode
      , o = tn(e, r, i);
    return o.ref = n,
    o.ce = s,
    delete t.vnode.ce,
    o
}
const Cu = e => e.type.__isKeepAlive
  , Hv = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(e, {slots: t}) {
        const n = Or()
          , r = n.ctx;
        if (!r.renderer)
            return () => {
                const x = t.default && t.default();
                return x && x.length === 1 ? x[0] : x
            }
            ;
        const i = new Map
          , s = new Set;
        let o = null;
        const l = n.suspense
          , {renderer: {p: u, m: p, um: h, o: {createElement: g}}} = r
          , m = g("div");
        r.activate = (x, v, k, S, W) => {
            const K = x.component;
            p(x, v, k, 0, l),
            u(K.vnode, x, v, k, K, l, S, x.slotScopeIds, W),
            bi( () => {
                K.isDeactivated = !1,
                K.a && el(K.a);
                const be = x.props && x.props.onVnodeMounted;
                be && ls(be, K.parent, x)
            }
            , l)
        }
        ,
        r.deactivate = x => {
            const v = x.component;
            Ec(v.m),
            Ec(v.a),
            p(x, m, null, 1, l),
            bi( () => {
                v.da && el(v.da);
                const k = x.props && x.props.onVnodeUnmounted;
                k && ls(k, v.parent, x),
                v.isDeactivated = !0
            }
            , l)
        }
        ;
        function w(x) {
            Pf(x),
            h(x, n, l, !0)
        }
        function E(x) {
            i.forEach( (v, k) => {
                const S = pd(v.type);
                S && !x(S) && y(k)
            }
            )
        }
        function y(x) {
            const v = i.get(x);
            v && (!o || !Vs(v, o)) ? w(v) : o && Pf(o),
            i.delete(x),
            s.delete(x)
        }
        tr( () => [e.include, e.exclude], ([x,v]) => {
            x && E(k => $l(x, k)),
            v && E(k => !$l(v, k))
        }
        , {
            flush: "post",
            deep: !0
        });
        let R = null;
        const P = () => {
            R != null && (Cc(n.subTree.type) ? bi( () => {
                i.set(R, Xu(n.subTree))
            }
            , n.subTree.suspense) : i.set(R, Xu(n.subTree)))
        }
        ;
        return xi(P),
        tf(P),
        Io( () => {
            i.forEach(x => {
                const {subTree: v, suspense: k} = n
                  , S = Xu(v);
                if (x.type === S.type && x.key === S.key) {
                    Pf(S);
                    const W = S.component.da;
                    W && bi(W, k);
                    return
                }
                w(x)
            }
            )
        }
        ),
        () => {
            if (R = null,
            !t.default)
                return o = null;
            const x = t.default()
              , v = x[0];
            if (x.length > 1)
                return o = null,
                x;
            if (!Oo(v) || !(v.shapeFlag & 4) && !(v.shapeFlag & 128))
                return o = null,
                v;
            let k = Xu(v);
            if (k.type === si)
                return o = null,
                k;
            const S = k.type
              , W = pd(ta(k) ? k.type.__asyncResolved || {} : S)
              , {include: K, exclude: be, max: fe} = e;
            if (K && (!W || !$l(K, W)) || be && W && $l(be, W))
                return k.shapeFlag &= -257,
                o = k,
                v;
            const ge = k.key == null ? S : k.key
              , J = i.get(ge);
            return k.el && (k = Us(k),
            v.shapeFlag & 128 && (v.ssContent = k)),
            R = ge,
            J ? (k.el = J.el,
            k.component = J.component,
            k.transition && Ro(k, k.transition),
            k.shapeFlag |= 512,
            s.delete(ge),
            s.add(ge)) : (s.add(ge),
            fe && s.size > parseInt(fe, 10) && y(s.values().next().value)),
            k.shapeFlag |= 256,
            o = k,
            Cc(v.type) ? v : k
        }
    }
}
  , P_ = Hv;
function $l(e, t) {
    return Qt(e) ? e.some(n => $l(n, t)) : Sr(e) ? e.split(",").includes(t) : Ey(e) ? (e.lastIndex = 0,
    e.test(t)) : !1
}
function ih(e, t) {
    k_(e, "a", t)
}
function sh(e, t) {
    k_(e, "da", t)
}
function k_(e, t, n=wi) {
    const r = e.__wdc || (e.__wdc = () => {
        let i = n;
        for (; i; ) {
            if (i.isDeactivated)
                return;
            i = i.parent
        }
        return e()
    }
    );
    if (ef(t, r, n),
    n) {
        let i = n.parent;
        for (; i && i.parent; )
            Cu(i.parent.vnode) && Vv(r, t, n, i),
            i = i.parent
    }
}
function Vv(e, t, n, r) {
    const i = ef(t, e, r, !0);
    bl( () => {
        qd(r[t], i)
    }
    , n)
}
function Pf(e) {
    e.shapeFlag &= -257,
    e.shapeFlag &= -513
}
function Xu(e) {
    return e.shapeFlag & 128 ? e.ssContent : e
}
function ef(e, t, n=wi, r=!1) {
    if (n) {
        const i = n[e] || (n[e] = [])
          , s = t.__weh || (t.__weh = (...o) => {
            oa();
            const l = Oa(n)
              , u = Rs(t, n, e, o);
            return l(),
            aa(),
            u
        }
        );
        return r ? i.unshift(s) : i.push(s),
        s
    }
}
const Fo = e => (t, n=wi) => {
    (!ll || e === "sp") && ef(e, (...r) => t(...r), n)
}
  , oh = Fo("bm")
  , xi = Fo("m")
  , ah = Fo("bu")
  , tf = Fo("u")
  , Io = Fo("bum")
  , bl = Fo("um")
  , A_ = Fo("sp")
  , R_ = Fo("rtg")
  , O_ = Fo("rtc");
function lh(e, t=wi) {
    ef("ec", e, t)
}
const uh = "components"
  , jv = "directives";
function wc(e, t) {
    return ch(uh, e, !0, t) || e
}
const M_ = Symbol.for("v-ndc");
function nl(e) {
    return Sr(e) ? ch(uh, e, !1) || e : e || M_
}
function zv(e) {
    return ch(jv, e)
}
function ch(e, t, n=!0, r=!1) {
    const i = Di || wi;
    if (i) {
        const s = i.type;
        if (e === uh) {
            const l = pd(s, !1);
            if (l && (l === t || l === Ei(t) || l === _l(Ei(t))))
                return s
        }
        const o = Qh(i[e] || s[e], t) || Qh(i.appContext[e], t);
        return !o && r ? s : o
    }
}
function Qh(e, t) {
    return e && (e[t] || e[Ei(t)] || e[_l(Ei(t))])
}
function So(e, t, n, r) {
    let i;
    const s = n && n[r]
      , o = Qt(e);
    if (o || Sr(e)) {
        const l = o && so(e);
        let u = !1;
        l && (u = !ms(e),
        e = Gc(e)),
        i = new Array(e.length);
        for (let p = 0, h = e.length; p < h; p++)
            i[p] = t(u ? zi(e[p]) : e[p], p, void 0, s && s[p])
    } else if (typeof e == "number") {
        i = new Array(e);
        for (let l = 0; l < e; l++)
            i[l] = t(l + 1, l, void 0, s && s[l])
    } else if (gr(e))
        if (e[Symbol.iterator])
            i = Array.from(e, (l, u) => t(l, u, void 0, s && s[u]));
        else {
            const l = Object.keys(e);
            i = new Array(l.length);
            for (let u = 0, p = l.length; u < p; u++) {
                const h = l[u];
                i[u] = t(e[h], h, u, s && s[u])
            }
        }
    else
        i = [];
    return n && (n[r] = i),
    i
}
function Uv(e, t) {
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (Qt(r))
            for (let i = 0; i < r.length; i++)
                e[r[i].name] = r[i].fn;
        else
            r && (e[r.name] = r.key ? (...i) => {
                const s = r.fn(...i);
                return s && (s.key = r.key),
                s
            }
            : r.fn)
    }
    return e
}
function ys(e, t, n={}, r, i) {
    if (Di.ce || Di.parent && ta(Di.parent) && Di.parent.ce)
        return t !== "default" && (n.name = t),
        It(),
        Wn(er, null, [tn("slot", n, r && r())], 64);
    let s = e[t];
    s && s._c && (s._d = !1),
    It();
    const o = s && fh(s(n))
      , l = n.key || o && o.key
      , u = Wn(er, {
        key: (l && !zs(l) ? l : `_${t}`) + (!o && r ? "_fb" : "")
    }, o || (r ? r() : []), o && e._ === 1 ? 64 : -2);
    return !i && u.scopeId && (u.slotScopeIds = [u.scopeId + "-s"]),
    s && s._c && (s._d = !0),
    u
}
function fh(e) {
    return e.some(t => Oo(t) ? !(t.type === si || t.type === er && !fh(t.children)) : !0) ? e : null
}
function Wv(e, t) {
    const n = {};
    for (const r in e)
        n[t && /[A-Z]/.test(r) ? `on:${r}` : Za(r)] = e[r];
    return n
}
const rd = e => e ? fm(e) ? Su(e) : rd(e.parent) : null
  , eu = vr(Object.create(null), {
    $: e => e,
    $el: e => e.vnode.el,
    $data: e => e.data,
    $props: e => e.props,
    $attrs: e => e.attrs,
    $slots: e => e.slots,
    $refs: e => e.refs,
    $parent: e => rd(e.parent),
    $root: e => rd(e.root),
    $host: e => e.ce,
    $emit: e => e.emit,
    $options: e => dh(e),
    $forceUpdate: e => e.f || (e.f = () => {
        eh(e.update)
    }
    ),
    $nextTick: e => e.n || (e.n = Ci.bind(e.proxy)),
    $watch: e => b1.bind(e)
})
  , kf = (e, t) => e !== jn && !e.__isScriptSetup && Zn(e, t)
  , id = {
    get({_: e}, t) {
        if (t === "__v_skip")
            return !0;
        const {ctx: n, setupState: r, data: i, props: s, accessCache: o, type: l, appContext: u} = e;
        let p;
        if (t[0] !== "$") {
            const w = o[t];
            if (w !== void 0)
                switch (w) {
                case 1:
                    return r[t];
                case 2:
                    return i[t];
                case 4:
                    return n[t];
                case 3:
                    return s[t]
                }
            else {
                if (kf(r, t))
                    return o[t] = 1,
                    r[t];
                if (i !== jn && Zn(i, t))
                    return o[t] = 2,
                    i[t];
                if ((p = e.propsOptions[0]) && Zn(p, t))
                    return o[t] = 3,
                    s[t];
                if (n !== jn && Zn(n, t))
                    return o[t] = 4,
                    n[t];
                sd && (o[t] = 0)
            }
        }
        const h = eu[t];
        let g, m;
        if (h)
            return t === "$attrs" && ji(e.attrs, "get", ""),
            h(e);
        if ((g = l.__cssModules) && (g = g[t]))
            return g;
        if (n !== jn && Zn(n, t))
            return o[t] = 4,
            n[t];
        if (m = u.config.globalProperties,
        Zn(m, t))
            return m[t]
    },
    set({_: e}, t, n) {
        const {data: r, setupState: i, ctx: s} = e;
        return kf(i, t) ? (i[t] = n,
        !0) : r !== jn && Zn(r, t) ? (r[t] = n,
        !0) : Zn(e.props, t) || t[0] === "$" && t.slice(1)in e ? !1 : (s[t] = n,
        !0)
    },
    has({_: {data: e, setupState: t, accessCache: n, ctx: r, appContext: i, propsOptions: s}}, o) {
        let l;
        return !!n[o] || e !== jn && Zn(e, o) || kf(t, o) || (l = s[0]) && Zn(l, o) || Zn(r, o) || Zn(eu, o) || Zn(i.config.globalProperties, o)
    },
    defineProperty(e, t, n) {
        return n.get != null ? e._.accessCache[t] = 0 : Zn(n, "value") && this.set(e, t, n.value, null),
        Reflect.defineProperty(e, t, n)
    }
}
  , qv = vr({}, id, {
    get(e, t) {
        if (t !== Symbol.unscopables)
            return id.get(e, t, e)
    },
    has(e, t) {
        return t[0] !== "_" && !Py(t)
    }
});
function Gv() {
    return null
}
function Yv() {
    return null
}
function Kv(e) {}
function Xv(e) {}
function Qv() {
    return null
}
function Jv() {}
function Zv(e, t) {
    return null
}
function e1() {
    return L_().slots
}
function t1() {
    return L_().attrs
}
function L_() {
    const e = Or();
    return e.setupContext || (e.setupContext = pm(e))
}
function pu(e) {
    return Qt(e) ? e.reduce( (t, n) => (t[n] = null,
    t), {}) : e
}
function n1(e, t) {
    const n = pu(e);
    for (const r in t) {
        if (r.startsWith("__skip"))
            continue;
        let i = n[r];
        i ? Qt(i) || dn(i) ? i = n[r] = {
            type: i,
            default: t[r]
        } : i.default = t[r] : i === null && (i = n[r] = {
            default: t[r]
        }),
        i && t[`__skip_${r}`] && (i.skipFactory = !0)
    }
    return n
}
function r1(e, t) {
    return !e || !t ? e || t : Qt(e) && Qt(t) ? e.concat(t) : vr({}, pu(e), pu(t))
}
function i1(e, t) {
    const n = {};
    for (const r in e)
        t.includes(r) || Object.defineProperty(n, r, {
            enumerable: !0,
            get: () => e[r]
        });
    return n
}
function F_(e) {
    const t = Or();
    let n = e();
    return fd(),
    Gd(n) && (n = n.catch(r => {
        throw Oa(t),
        r
    }
    )),
    [n, () => Oa(t)]
}
let sd = !0;
function s1(e) {
    const t = dh(e)
      , n = e.proxy
      , r = e.ctx;
    sd = !1,
    t.beforeCreate && Jh(t.beforeCreate, e, "bc");
    const {data: i, computed: s, methods: o, watch: l, provide: u, inject: p, created: h, beforeMount: g, mounted: m, beforeUpdate: w, updated: E, activated: y, deactivated: R, beforeDestroy: P, beforeUnmount: x, destroyed: v, unmounted: k, render: S, renderTracked: W, renderTriggered: K, errorCaptured: be, serverPrefetch: fe, expose: ge, inheritAttrs: J, components: re, directives: ee, filters: Y} = t;
    if (p && o1(p, r, null),
    o)
        for (const ue in o) {
            const se = o[ue];
            dn(se) && (r[ue] = se.bind(n))
        }
    if (i) {
        const ue = i.call(n, n);
        gr(ue) && (e.data = Gr(ue))
    }
    if (sd = !0,
    s)
        for (const ue in s) {
            const se = s[ue]
              , ye = dn(se) ? se.bind(n, n) : dn(se.get) ? se.get.bind(n, n) : Ps
              , Ze = !dn(se) && dn(se.set) ? se.set.bind(n) : Ps
              , qe = zt({
                get: ye,
                set: Ze
            });
            Object.defineProperty(r, ue, {
                enumerable: !0,
                configurable: !0,
                get: () => qe.value,
                set: nt => qe.value = nt
            })
        }
    if (l)
        for (const ue in l)
            I_(l[ue], r, n, ue);
    if (u) {
        const ue = dn(u) ? u.call(n) : u;
        Reflect.ownKeys(ue).forEach(se => {
            ns(se, ue[se])
        }
        )
    }
    h && Jh(h, e, "c");
    function Q(ue, se) {
        Qt(se) ? se.forEach(ye => ue(ye.bind(n))) : se && ue(se.bind(n))
    }
    if (Q(oh, g),
    Q(xi, m),
    Q(ah, w),
    Q(tf, E),
    Q(ih, y),
    Q(sh, R),
    Q(lh, be),
    Q(O_, W),
    Q(R_, K),
    Q(Io, x),
    Q(bl, k),
    Q(A_, fe),
    Qt(ge))
        if (ge.length) {
            const ue = e.exposed || (e.exposed = {});
            ge.forEach(se => {
                Object.defineProperty(ue, se, {
                    get: () => n[se],
                    set: ye => n[se] = ye
                })
            }
            )
        } else
            e.exposed || (e.exposed = {});
    S && e.render === Ps && (e.render = S),
    J != null && (e.inheritAttrs = J),
    re && (e.components = re),
    ee && (e.directives = ee),
    fe && rh(e)
}
function o1(e, t, n=Ps) {
    Qt(e) && (e = od(e));
    for (const r in e) {
        const i = e[r];
        let s;
        gr(i) ? "default"in i ? s = pr(i.from || r, i.default, !0) : s = pr(i.from || r) : s = pr(i),
        sr(s) ? Object.defineProperty(t, r, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: o => s.value = o
        }) : t[r] = s
    }
}
function Jh(e, t, n) {
    Rs(Qt(e) ? e.map(r => r.bind(t.proxy)) : e.bind(t.proxy), t, n)
}
function I_(e, t, n, r) {
    let i = r.includes(".") ? tm(n, r) : () => n[r];
    if (Sr(e)) {
        const s = t[e];
        dn(s) && tr(i, s)
    } else if (dn(e))
        tr(i, e.bind(n));
    else if (gr(e))
        if (Qt(e))
            e.forEach(s => I_(s, t, n, r));
        else {
            const s = dn(e.handler) ? e.handler.bind(n) : t[e.handler];
            dn(s) && tr(i, s, e)
        }
}
function dh(e) {
    const t = e.type
      , {mixins: n, extends: r} = t
      , {mixins: i, optionsCache: s, config: {optionMergeStrategies: o}} = e.appContext
      , l = s.get(t);
    let u;
    return l ? u = l : !i.length && !n && !r ? u = t : (u = {},
    i.length && i.forEach(p => Dc(u, p, o, !0)),
    Dc(u, t, o)),
    gr(t) && s.set(t, u),
    u
}
function Dc(e, t, n, r=!1) {
    const {mixins: i, extends: s} = t;
    s && Dc(e, s, n, !0),
    i && i.forEach(o => Dc(e, o, n, !0));
    for (const o in t)
        if (!(r && o === "expose")) {
            const l = a1[o] || n && n[o];
            e[o] = l ? l(e[o], t[o]) : t[o]
        }
    return e
}
const a1 = {
    data: Zh,
    props: ep,
    emits: ep,
    methods: Bl,
    computed: Bl,
    beforeCreate: Qi,
    created: Qi,
    beforeMount: Qi,
    mounted: Qi,
    beforeUpdate: Qi,
    updated: Qi,
    beforeDestroy: Qi,
    beforeUnmount: Qi,
    destroyed: Qi,
    unmounted: Qi,
    activated: Qi,
    deactivated: Qi,
    errorCaptured: Qi,
    serverPrefetch: Qi,
    components: Bl,
    directives: Bl,
    watch: u1,
    provide: Zh,
    inject: l1
};
function Zh(e, t) {
    return t ? e ? function() {
        return vr(dn(e) ? e.call(this, this) : e, dn(t) ? t.call(this, this) : t)
    }
    : t : e
}
function l1(e, t) {
    return Bl(od(e), od(t))
}
function od(e) {
    if (Qt(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++)
            t[e[n]] = e[n];
        return t
    }
    return e
}
function Qi(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}
function Bl(e, t) {
    return e ? vr(Object.create(null), e, t) : t
}
function ep(e, t) {
    return e ? Qt(e) && Qt(t) ? [...new Set([...e, ...t])] : vr(Object.create(null), pu(e), pu(t ?? {})) : t
}
function u1(e, t) {
    if (!e)
        return t;
    if (!t)
        return e;
    const n = vr(Object.create(null), e);
    for (const r in t)
        n[r] = Qi(e[r], t[r]);
    return n
}
function N_() {
    return {
        app: null,
        config: {
            isNativeTag: wy,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let c1 = 0;
function f1(e, t) {
    return function(r, i=null) {
        dn(r) || (r = vr({}, r)),
        i != null && !gr(i) && (i = null);
        const s = N_()
          , o = new WeakSet
          , l = [];
        let u = !1;
        const p = s.app = {
            _uid: c1++,
            _component: r,
            _props: i,
            _container: null,
            _context: s,
            _instance: null,
            version: _m,
            get config() {
                return s.config
            },
            set config(h) {},
            use(h, ...g) {
                return o.has(h) || (h && dn(h.install) ? (o.add(h),
                h.install(p, ...g)) : dn(h) && (o.add(h),
                h(p, ...g))),
                p
            },
            mixin(h) {
                return s.mixins.includes(h) || s.mixins.push(h),
                p
            },
            component(h, g) {
                return g ? (s.components[h] = g,
                p) : s.components[h]
            },
            directive(h, g) {
                return g ? (s.directives[h] = g,
                p) : s.directives[h]
            },
            mount(h, g, m) {
                if (!u) {
                    const w = p._ceVNode || tn(r, i);
                    return w.appContext = s,
                    m === !0 ? m = "svg" : m === !1 && (m = void 0),
                    g && t ? t(w, h) : e(w, h, m),
                    u = !0,
                    p._container = h,
                    h.__vue_app__ = p,
                    Su(w.component)
                }
            },
            onUnmount(h) {
                l.push(h)
            },
            unmount() {
                u && (Rs(l, p._instance, 16),
                e(null, p._container),
                delete p._container.__vue_app__)
            },
            provide(h, g) {
                return s.provides[h] = g,
                p
            },
            runWithContext(h) {
                const g = Ta;
                Ta = p;
                try {
                    return h()
                } finally {
                    Ta = g
                }
            }
        };
        return p
    }
}
let Ta = null;
function ns(e, t) {
    if (wi) {
        let n = wi.provides;
        const r = wi.parent && wi.parent.provides;
        r === n && (n = wi.provides = Object.create(r)),
        n[e] = t
    }
}
function pr(e, t, n=!1) {
    const r = wi || Di;
    if (r || Ta) {
        const i = Ta ? Ta._context.provides : r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
        if (i && e in i)
            return i[e];
        if (arguments.length > 1)
            return n && dn(t) ? t.call(r && r.proxy) : t
    }
}
function Na() {
    return !!(wi || Di || Ta)
}
const $_ = {}
  , B_ = () => Object.create($_)
  , H_ = e => Object.getPrototypeOf(e) === $_;
function d1(e, t, n, r=!1) {
    const i = {}
      , s = B_();
    e.propsDefaults = Object.create(null),
    V_(e, t, i, s);
    for (const o in e.propsOptions[0])
        o in i || (i[o] = void 0);
    n ? e.props = r ? i : Ts(i) : e.type.props ? e.props = i : e.props = s,
    e.attrs = s
}
function h1(e, t, n, r) {
    const {props: i, attrs: s, vnode: {patchFlag: o}} = e
      , l = Nn(i)
      , [u] = e.propsOptions;
    let p = !1;
    if ((r || o > 0) && !(o & 16)) {
        if (o & 8) {
            const h = e.vnode.dynamicProps;
            for (let g = 0; g < h.length; g++) {
                let m = h[g];
                if (nf(e.emitsOptions, m))
                    continue;
                const w = t[m];
                if (u)
                    if (Zn(s, m))
                        w !== s[m] && (s[m] = w,
                        p = !0);
                    else {
                        const E = Ei(m);
                        i[E] = ad(u, l, E, w, e, !1)
                    }
                else
                    w !== s[m] && (s[m] = w,
                    p = !0)
            }
        }
    } else {
        V_(e, t, i, s) && (p = !0);
        let h;
        for (const g in l)
            (!t || !Zn(t, g) && ((h = cs(g)) === g || !Zn(t, h))) && (u ? n && (n[g] !== void 0 || n[h] !== void 0) && (i[g] = ad(u, l, g, void 0, e, !0)) : delete i[g]);
        if (s !== l)
            for (const g in s)
                (!t || !Zn(t, g)) && (delete s[g],
                p = !0)
    }
    p && Eo(e.attrs, "set", "")
}
function V_(e, t, n, r) {
    const [i,s] = e.propsOptions;
    let o = !1, l;
    if (t)
        for (let u in t) {
            if (Ja(u))
                continue;
            const p = t[u];
            let h;
            i && Zn(i, h = Ei(u)) ? !s || !s.includes(h) ? n[h] = p : (l || (l = {}))[h] = p : nf(e.emitsOptions, u) || (!(u in r) || p !== r[u]) && (r[u] = p,
            o = !0)
        }
    if (s) {
        const u = Nn(n)
          , p = l || jn;
        for (let h = 0; h < s.length; h++) {
            const g = s[h];
            n[g] = ad(i, u, g, p[g], e, !Zn(p, g))
        }
    }
    return o
}
function ad(e, t, n, r, i, s) {
    const o = e[n];
    if (o != null) {
        const l = Zn(o, "default");
        if (l && r === void 0) {
            const u = o.default;
            if (o.type !== Function && !o.skipFactory && dn(u)) {
                const {propsDefaults: p} = i;
                if (n in p)
                    r = p[n];
                else {
                    const h = Oa(i);
                    r = p[n] = u.call(null, t),
                    h()
                }
            } else
                r = u;
            i.ce && i.ce._setProp(n, r)
        }
        o[0] && (s && !l ? r = !1 : o[1] && (r === "" || r === cs(n)) && (r = !0))
    }
    return r
}
const p1 = new WeakMap;
function j_(e, t, n=!1) {
    const r = n ? p1 : t.propsCache
      , i = r.get(e);
    if (i)
        return i;
    const s = e.props
      , o = {}
      , l = [];
    let u = !1;
    if (!dn(e)) {
        const h = g => {
            u = !0;
            const [m,w] = j_(g, t, !0);
            vr(o, m),
            w && l.push(...w)
        }
        ;
        !n && t.mixins.length && t.mixins.forEach(h),
        e.extends && h(e.extends),
        e.mixins && e.mixins.forEach(h)
    }
    if (!s && !u)
        return gr(e) && r.set(e, Xa),
        Xa;
    if (Qt(s))
        for (let h = 0; h < s.length; h++) {
            const g = Ei(s[h]);
            tp(g) && (o[g] = jn)
        }
    else if (s)
        for (const h in s) {
            const g = Ei(h);
            if (tp(g)) {
                const m = s[h]
                  , w = o[g] = Qt(m) || dn(m) ? {
                    type: m
                } : vr({}, m)
                  , E = w.type;
                let y = !1
                  , R = !0;
                if (Qt(E))
                    for (let P = 0; P < E.length; ++P) {
                        const x = E[P]
                          , v = dn(x) && x.name;
                        if (v === "Boolean") {
                            y = !0;
                            break
                        } else
                            v === "String" && (R = !1)
                    }
                else
                    y = dn(E) && E.name === "Boolean";
                w[0] = y,
                w[1] = R,
                (y || Zn(w, "default")) && l.push(g)
            }
        }
    const p = [o, l];
    return gr(e) && r.set(e, p),
    p
}
function tp(e) {
    return e[0] !== "$" && !Ja(e)
}
const z_ = e => e[0] === "_" || e === "$stable"
  , hh = e => Qt(e) ? e.map(us) : [us(e)]
  , g1 = (e, t, n) => {
    if (t._n)
        return t;
    const r = Tn( (...i) => hh(t(...i)), n);
    return r._c = !1,
    r
}
  , U_ = (e, t, n) => {
    const r = e._ctx;
    for (const i in e) {
        if (z_(i))
            continue;
        const s = e[i];
        if (dn(s))
            t[i] = g1(i, s, r);
        else if (s != null) {
            const o = hh(s);
            t[i] = () => o
        }
    }
}
  , W_ = (e, t) => {
    const n = hh(t);
    e.slots.default = () => n
}
  , q_ = (e, t, n) => {
    for (const r in t)
        (n || r !== "_") && (e[r] = t[r])
}
  , _1 = (e, t, n) => {
    const r = e.slots = B_();
    if (e.vnode.shapeFlag & 32) {
        const i = t._;
        i ? (q_(r, t, n),
        n && qg(r, "_", i, !0)) : U_(t, r)
    } else
        t && W_(e, t)
}
  , m1 = (e, t, n) => {
    const {vnode: r, slots: i} = e;
    let s = !0
      , o = jn;
    if (r.shapeFlag & 32) {
        const l = t._;
        l ? n && l === 1 ? s = !1 : q_(i, t, n) : (s = !t.$stable,
        U_(t, i)),
        o = t
    } else
        t && (W_(e, t),
        o = {
            default: 1
        });
    if (s)
        for (const l in i)
            !z_(l) && o[l] == null && delete i[l]
}
  , bi = sm;
function G_(e) {
    return K_(e)
}
function Y_(e) {
    return K_(e, Av)
}
function K_(e, t) {
    const n = Uc();
    n.__VUE__ = !0;
    const {insert: r, remove: i, patchProp: s, createElement: o, createText: l, createComment: u, setText: p, setElementText: h, parentNode: g, nextSibling: m, setScopeId: w=Ps, insertStaticContent: E} = e
      , y = (I, $, de, Me=null, Te=null, Ne=null, lt=void 0, st=null, Ue=!!$.dynamicChildren) => {
        if (I === $)
            return;
        I && !Vs(I, $) && (Me = he(I),
        nt(I, Te, Ne, !0),
        I = null),
        $.patchFlag === -2 && (Ue = !1,
        $.dynamicChildren = null);
        const {type: Ge, ref: wt, shapeFlag: rt} = $;
        switch (Ge) {
        case na:
            R(I, $, de, Me);
            break;
        case si:
            P(I, $, de, Me);
            break;
        case Pa:
            I == null && x($, de, Me, lt);
            break;
        case er:
            re(I, $, de, Me, Te, Ne, lt, st, Ue);
            break;
        default:
            rt & 1 ? S(I, $, de, Me, Te, Ne, lt, st, Ue) : rt & 6 ? ee(I, $, de, Me, Te, Ne, lt, st, Ue) : (rt & 64 || rt & 128) && Ge.process(I, $, de, Me, Te, Ne, lt, st, Ue, ze)
        }
        wt != null && Te && hu(wt, I && I.ref, Ne, $ || I, !$)
    }
      , R = (I, $, de, Me) => {
        if (I == null)
            r($.el = l($.children), de, Me);
        else {
            const Te = $.el = I.el;
            $.children !== I.children && p(Te, $.children)
        }
    }
      , P = (I, $, de, Me) => {
        I == null ? r($.el = u($.children || ""), de, Me) : $.el = I.el
    }
      , x = (I, $, de, Me) => {
        [I.el,I.anchor] = E(I.children, $, de, Me, I.el, I.anchor)
    }
      , v = ({el: I, anchor: $}, de, Me) => {
        let Te;
        for (; I && I !== $; )
            Te = m(I),
            r(I, de, Me),
            I = Te;
        r($, de, Me)
    }
      , k = ({el: I, anchor: $}) => {
        let de;
        for (; I && I !== $; )
            de = m(I),
            i(I),
            I = de;
        i($)
    }
      , S = (I, $, de, Me, Te, Ne, lt, st, Ue) => {
        $.type === "svg" ? lt = "svg" : $.type === "math" && (lt = "mathml"),
        I == null ? W($, de, Me, Te, Ne, lt, st, Ue) : fe(I, $, Te, Ne, lt, st, Ue)
    }
      , W = (I, $, de, Me, Te, Ne, lt, st) => {
        let Ue, Ge;
        const {props: wt, shapeFlag: rt, transition: Dt, dirs: xt} = I;
        if (Ue = I.el = o(I.type, Ne, wt && wt.is, wt),
        rt & 8 ? h(Ue, I.children) : rt & 16 && be(I.children, Ue, null, Me, Te, Af(I, Ne), lt, st),
        xt && ro(I, null, Me, "created"),
        K(Ue, I, I.scopeId, lt, Me),
        wt) {
            for (const Jt in wt)
                Jt !== "value" && !Ja(Jt) && s(Ue, Jt, null, wt[Jt], Ne, Me);
            "value"in wt && s(Ue, "value", null, wt.value, Ne),
            (Ge = wt.onVnodeBeforeMount) && ls(Ge, Me, I)
        }
        xt && ro(I, null, Me, "beforeMount");
        const Lt = X_(Te, Dt);
        Lt && Dt.beforeEnter(Ue),
        r(Ue, $, de),
        ((Ge = wt && wt.onVnodeMounted) || Lt || xt) && bi( () => {
            Ge && ls(Ge, Me, I),
            Lt && Dt.enter(Ue),
            xt && ro(I, null, Me, "mounted")
        }
        , Te)
    }
      , K = (I, $, de, Me, Te) => {
        if (de && w(I, de),
        Me)
            for (let Ne = 0; Ne < Me.length; Ne++)
                w(I, Me[Ne]);
        if (Te) {
            let Ne = Te.subTree;
            if ($ === Ne || Cc(Ne.type) && (Ne.ssContent === $ || Ne.ssFallback === $)) {
                const lt = Te.vnode;
                K(I, lt, lt.scopeId, lt.slotScopeIds, Te.parent)
            }
        }
    }
      , be = (I, $, de, Me, Te, Ne, lt, st, Ue=0) => {
        for (let Ge = Ue; Ge < I.length; Ge++) {
            const wt = I[Ge] = st ? Qo(I[Ge]) : us(I[Ge]);
            y(null, wt, $, de, Me, Te, Ne, lt, st)
        }
    }
      , fe = (I, $, de, Me, Te, Ne, lt) => {
        const st = $.el = I.el;
        let {patchFlag: Ue, dynamicChildren: Ge, dirs: wt} = $;
        Ue |= I.patchFlag & 16;
        const rt = I.props || jn
          , Dt = $.props || jn;
        let xt;
        if (de && ba(de, !1),
        (xt = Dt.onVnodeBeforeUpdate) && ls(xt, de, $, I),
        wt && ro($, I, de, "beforeUpdate"),
        de && ba(de, !0),
        (rt.innerHTML && Dt.innerHTML == null || rt.textContent && Dt.textContent == null) && h(st, ""),
        Ge ? ge(I.dynamicChildren, Ge, st, de, Me, Af($, Te), Ne) : lt || se(I, $, st, null, de, Me, Af($, Te), Ne, !1),
        Ue > 0) {
            if (Ue & 16)
                J(st, rt, Dt, de, Te);
            else if (Ue & 2 && rt.class !== Dt.class && s(st, "class", null, Dt.class, Te),
            Ue & 4 && s(st, "style", rt.style, Dt.style, Te),
            Ue & 8) {
                const Lt = $.dynamicProps;
                for (let Jt = 0; Jt < Lt.length; Jt++) {
                    const fn = Lt[Jt]
                      , Fn = rt[fn]
                      , hn = Dt[fn];
                    (hn !== Fn || fn === "value") && s(st, fn, Fn, hn, Te, de)
                }
            }
            Ue & 1 && I.children !== $.children && h(st, $.children)
        } else
            !lt && Ge == null && J(st, rt, Dt, de, Te);
        ((xt = Dt.onVnodeUpdated) || wt) && bi( () => {
            xt && ls(xt, de, $, I),
            wt && ro($, I, de, "updated")
        }
        , Me)
    }
      , ge = (I, $, de, Me, Te, Ne, lt) => {
        for (let st = 0; st < $.length; st++) {
            const Ue = I[st]
              , Ge = $[st]
              , wt = Ue.el && (Ue.type === er || !Vs(Ue, Ge) || Ue.shapeFlag & 70) ? g(Ue.el) : de;
            y(Ue, Ge, wt, null, Me, Te, Ne, lt, !0)
        }
    }
      , J = (I, $, de, Me, Te) => {
        if ($ !== de) {
            if ($ !== jn)
                for (const Ne in $)
                    !Ja(Ne) && !(Ne in de) && s(I, Ne, $[Ne], null, Te, Me);
            for (const Ne in de) {
                if (Ja(Ne))
                    continue;
                const lt = de[Ne]
                  , st = $[Ne];
                lt !== st && Ne !== "value" && s(I, Ne, st, lt, Te, Me)
            }
            "value"in de && s(I, "value", $.value, de.value, Te)
        }
    }
      , re = (I, $, de, Me, Te, Ne, lt, st, Ue) => {
        const Ge = $.el = I ? I.el : l("")
          , wt = $.anchor = I ? I.anchor : l("");
        let {patchFlag: rt, dynamicChildren: Dt, slotScopeIds: xt} = $;
        xt && (st = st ? st.concat(xt) : xt),
        I == null ? (r(Ge, de, Me),
        r(wt, de, Me),
        be($.children || [], de, wt, Te, Ne, lt, st, Ue)) : rt > 0 && rt & 64 && Dt && I.dynamicChildren ? (ge(I.dynamicChildren, Dt, de, Te, Ne, lt, st),
        ($.key != null || Te && $ === Te.subTree) && ph(I, $, !0)) : se(I, $, de, wt, Te, Ne, lt, st, Ue)
    }
      , ee = (I, $, de, Me, Te, Ne, lt, st, Ue) => {
        $.slotScopeIds = st,
        I == null ? $.shapeFlag & 512 ? Te.ctx.activate($, de, Me, lt, Ue) : Y($, de, Me, Te, Ne, lt, Ue) : Z(I, $, Ue)
    }
      , Y = (I, $, de, Me, Te, Ne, lt) => {
        const st = I.component = cm(I, Me, Te);
        if (Cu(I) && (st.ctx.renderer = ze),
        dm(st, !1, lt),
        st.asyncDep) {
            if (Te && Te.registerDep(st, Q, lt),
            !I.el) {
                const Ue = st.subTree = tn(si);
                P(null, Ue, $, de)
            }
        } else
            Q(st, I, $, de, Te, Ne, lt)
    }
      , Z = (I, $, de) => {
        const Me = $.component = I.component;
        if (S1(I, $, de))
            if (Me.asyncDep && !Me.asyncResolved) {
                ue(Me, $, de);
                return
            } else
                Me.next = $,
                Me.update();
        else
            $.el = I.el,
            Me.vnode = $
    }
      , Q = (I, $, de, Me, Te, Ne, lt) => {
        const st = () => {
            if (I.isMounted) {
                let {next: rt, bu: Dt, u: xt, parent: Lt, vnode: Jt} = I;
                {
                    const Kn = Q_(I);
                    if (Kn) {
                        rt && (rt.el = Jt.el,
                        ue(I, rt, lt)),
                        Kn.asyncDep.then( () => {
                            I.isUnmounted || st()
                        }
                        );
                        return
                    }
                }
                let fn = rt, Fn;
                ba(I, !1),
                rt ? (rt.el = Jt.el,
                ue(I, rt, lt)) : rt = Jt,
                Dt && el(Dt),
                (Fn = rt.props && rt.props.onVnodeBeforeUpdate) && ls(Fn, Lt, rt, Jt),
                ba(I, !0);
                const hn = uc(I)
                  , Ln = I.subTree;
                I.subTree = hn,
                y(Ln, hn, g(Ln.el), he(Ln), I, Te, Ne),
                rt.el = hn.el,
                fn === null && rf(I, hn.el),
                xt && bi(xt, Te),
                (Fn = rt.props && rt.props.onVnodeUpdated) && bi( () => ls(Fn, Lt, rt, Jt), Te)
            } else {
                let rt;
                const {el: Dt, props: xt} = $
                  , {bm: Lt, m: Jt, parent: fn, root: Fn, type: hn} = I
                  , Ln = ta($);
                if (ba(I, !1),
                Lt && el(Lt),
                !Ln && (rt = xt && xt.onVnodeBeforeMount) && ls(rt, fn, $),
                ba(I, !0),
                Dt && Je) {
                    const Kn = () => {
                        I.subTree = uc(I),
                        Je(Dt, I.subTree, I, Te, null)
                    }
                    ;
                    Ln && hn.__asyncHydrate ? hn.__asyncHydrate(Dt, I, Kn) : Kn()
                } else {
                    Fn.ce && Fn.ce._injectChildStyle(hn);
                    const Kn = I.subTree = uc(I);
                    y(null, Kn, de, Me, I, Te, Ne),
                    $.el = Kn.el
                }
                if (Jt && bi(Jt, Te),
                !Ln && (rt = xt && xt.onVnodeMounted)) {
                    const Kn = $;
                    bi( () => ls(rt, fn, Kn), Te)
                }
                ($.shapeFlag & 256 || fn && ta(fn.vnode) && fn.vnode.shapeFlag & 256) && I.a && bi(I.a, Te),
                I.isMounted = !0,
                $ = de = Me = null
            }
        }
        ;
        I.scope.on();
        const Ue = I.effect = new au(st);
        I.scope.off();
        const Ge = I.update = Ue.run.bind(Ue)
          , wt = I.job = Ue.runIfDirty.bind(Ue);
        wt.i = I,
        wt.id = I.uid,
        Ue.scheduler = () => eh(wt),
        ba(I, !0),
        Ge()
    }
      , ue = (I, $, de) => {
        $.component = I;
        const Me = I.vnode.props;
        I.vnode = $,
        I.next = null,
        h1(I, $.props, Me, de),
        m1(I, $.children, de),
        oa(),
        Uh(I),
        aa()
    }
      , se = (I, $, de, Me, Te, Ne, lt, st, Ue=!1) => {
        const Ge = I && I.children
          , wt = I ? I.shapeFlag : 0
          , rt = $.children
          , {patchFlag: Dt, shapeFlag: xt} = $;
        if (Dt > 0) {
            if (Dt & 128) {
                Ze(Ge, rt, de, Me, Te, Ne, lt, st, Ue);
                return
            } else if (Dt & 256) {
                ye(Ge, rt, de, Me, Te, Ne, lt, st, Ue);
                return
            }
        }
        xt & 8 ? (wt & 16 && Tt(Ge, Te, Ne),
        rt !== Ge && h(de, rt)) : wt & 16 ? xt & 16 ? Ze(Ge, rt, de, Me, Te, Ne, lt, st, Ue) : Tt(Ge, Te, Ne, !0) : (wt & 8 && h(de, ""),
        xt & 16 && be(rt, de, Me, Te, Ne, lt, st, Ue))
    }
      , ye = (I, $, de, Me, Te, Ne, lt, st, Ue) => {
        I = I || Xa,
        $ = $ || Xa;
        const Ge = I.length
          , wt = $.length
          , rt = Math.min(Ge, wt);
        let Dt;
        for (Dt = 0; Dt < rt; Dt++) {
            const xt = $[Dt] = Ue ? Qo($[Dt]) : us($[Dt]);
            y(I[Dt], xt, de, null, Te, Ne, lt, st, Ue)
        }
        Ge > wt ? Tt(I, Te, Ne, !0, !1, rt) : be($, de, Me, Te, Ne, lt, st, Ue, rt)
    }
      , Ze = (I, $, de, Me, Te, Ne, lt, st, Ue) => {
        let Ge = 0;
        const wt = $.length;
        let rt = I.length - 1
          , Dt = wt - 1;
        for (; Ge <= rt && Ge <= Dt; ) {
            const xt = I[Ge]
              , Lt = $[Ge] = Ue ? Qo($[Ge]) : us($[Ge]);
            if (Vs(xt, Lt))
                y(xt, Lt, de, null, Te, Ne, lt, st, Ue);
            else
                break;
            Ge++
        }
        for (; Ge <= rt && Ge <= Dt; ) {
            const xt = I[rt]
              , Lt = $[Dt] = Ue ? Qo($[Dt]) : us($[Dt]);
            if (Vs(xt, Lt))
                y(xt, Lt, de, null, Te, Ne, lt, st, Ue);
            else
                break;
            rt--,
            Dt--
        }
        if (Ge > rt) {
            if (Ge <= Dt) {
                const xt = Dt + 1
                  , Lt = xt < wt ? $[xt].el : Me;
                for (; Ge <= Dt; )
                    y(null, $[Ge] = Ue ? Qo($[Ge]) : us($[Ge]), de, Lt, Te, Ne, lt, st, Ue),
                    Ge++
            }
        } else if (Ge > Dt)
            for (; Ge <= rt; )
                nt(I[Ge], Te, Ne, !0),
                Ge++;
        else {
            const xt = Ge
              , Lt = Ge
              , Jt = new Map;
            for (Ge = Lt; Ge <= Dt; Ge++) {
                const X = $[Ge] = Ue ? Qo($[Ge]) : us($[Ge]);
                X.key != null && Jt.set(X.key, Ge)
            }
            let fn, Fn = 0;
            const hn = Dt - Lt + 1;
            let Ln = !1
              , Kn = 0;
            const lr = new Array(hn);
            for (Ge = 0; Ge < hn; Ge++)
                lr[Ge] = 0;
            for (Ge = xt; Ge <= rt; Ge++) {
                const X = I[Ge];
                if (Fn >= hn) {
                    nt(X, Te, Ne, !0);
                    continue
                }
                let ie;
                if (X.key != null)
                    ie = Jt.get(X.key);
                else
                    for (fn = Lt; fn <= Dt; fn++)
                        if (lr[fn - Lt] === 0 && Vs(X, $[fn])) {
                            ie = fn;
                            break
                        }
                ie === void 0 ? nt(X, Te, Ne, !0) : (lr[ie - Lt] = Ge + 1,
                ie >= Kn ? Kn = ie : Ln = !0,
                y(X, $[ie], de, null, Te, Ne, lt, st, Ue),
                Fn++)
            }
            const ht = Ln ? y1(lr) : Xa;
            for (fn = ht.length - 1,
            Ge = hn - 1; Ge >= 0; Ge--) {
                const X = Lt + Ge
                  , ie = $[X]
                  , _e = X + 1 < wt ? $[X + 1].el : Me;
                lr[Ge] === 0 ? y(null, ie, de, _e, Te, Ne, lt, st, Ue) : Ln && (fn < 0 || Ge !== ht[fn] ? qe(ie, de, _e, 2) : fn--)
            }
        }
    }
      , qe = (I, $, de, Me, Te=null) => {
        const {el: Ne, type: lt, transition: st, children: Ue, shapeFlag: Ge} = I;
        if (Ge & 6) {
            qe(I.component.subTree, $, de, Me);
            return
        }
        if (Ge & 128) {
            I.suspense.move($, de, Me);
            return
        }
        if (Ge & 64) {
            lt.move(I, $, de, ze);
            return
        }
        if (lt === er) {
            r(Ne, $, de);
            for (let rt = 0; rt < Ue.length; rt++)
                qe(Ue[rt], $, de, Me);
            r(I.anchor, $, de);
            return
        }
        if (lt === Pa) {
            v(I, $, de);
            return
        }
        if (Me !== 2 && Ge & 1 && st)
            if (Me === 0)
                st.beforeEnter(Ne),
                r(Ne, $, de),
                bi( () => st.enter(Ne), Te);
            else {
                const {leave: rt, delayLeave: Dt, afterLeave: xt} = st
                  , Lt = () => r(Ne, $, de)
                  , Jt = () => {
                    rt(Ne, () => {
                        Lt(),
                        xt && xt()
                    }
                    )
                }
                ;
                Dt ? Dt(Ne, Lt, Jt) : Jt()
            }
        else
            r(Ne, $, de)
    }
      , nt = (I, $, de, Me=!1, Te=!1) => {
        const {type: Ne, props: lt, ref: st, children: Ue, dynamicChildren: Ge, shapeFlag: wt, patchFlag: rt, dirs: Dt, cacheIndex: xt} = I;
        if (rt === -2 && (Te = !1),
        st != null && hu(st, null, de, I, !0),
        xt != null && ($.renderCache[xt] = void 0),
        wt & 256) {
            $.ctx.deactivate(I);
            return
        }
        const Lt = wt & 1 && Dt
          , Jt = !ta(I);
        let fn;
        if (Jt && (fn = lt && lt.onVnodeBeforeUnmount) && ls(fn, $, I),
        wt & 6)
            At(I.component, de, Me);
        else {
            if (wt & 128) {
                I.suspense.unmount(de, Me);
                return
            }
            Lt && ro(I, null, $, "beforeUnmount"),
            wt & 64 ? I.type.remove(I, $, de, ze, Me) : Ge && !Ge.hasOnce && (Ne !== er || rt > 0 && rt & 64) ? Tt(Ge, $, de, !1, !0) : (Ne === er && rt & 384 || !Te && wt & 16) && Tt(Ue, $, de),
            Me && mt(I)
        }
        (Jt && (fn = lt && lt.onVnodeUnmounted) || Lt) && bi( () => {
            fn && ls(fn, $, I),
            Lt && ro(I, null, $, "unmounted")
        }
        , de)
    }
      , mt = I => {
        const {type: $, el: de, anchor: Me, transition: Te} = I;
        if ($ === er) {
            yt(de, Me);
            return
        }
        if ($ === Pa) {
            k(I);
            return
        }
        const Ne = () => {
            i(de),
            Te && !Te.persisted && Te.afterLeave && Te.afterLeave()
        }
        ;
        if (I.shapeFlag & 1 && Te && !Te.persisted) {
            const {leave: lt, delayLeave: st} = Te
              , Ue = () => lt(de, Ne);
            st ? st(I.el, Ne, Ue) : Ue()
        } else
            Ne()
    }
      , yt = (I, $) => {
        let de;
        for (; I !== $; )
            de = m(I),
            i(I),
            I = de;
        i($)
    }
      , At = (I, $, de) => {
        const {bum: Me, scope: Te, job: Ne, subTree: lt, um: st, m: Ue, a: Ge} = I;
        Ec(Ue),
        Ec(Ge),
        Me && el(Me),
        Te.stop(),
        Ne && (Ne.flags |= 8,
        nt(lt, I, $, de)),
        st && bi(st, $),
        bi( () => {
            I.isUnmounted = !0
        }
        , $),
        $ && $.pendingBranch && !$.isUnmounted && I.asyncDep && !I.asyncResolved && I.suspenseId === $.pendingId && ($.deps--,
        $.deps === 0 && $.resolve())
    }
      , Tt = (I, $, de, Me=!1, Te=!1, Ne=0) => {
        for (let lt = Ne; lt < I.length; lt++)
            nt(I[lt], $, de, Me, Te)
    }
      , he = I => {
        if (I.shapeFlag & 6)
            return he(I.component.subTree);
        if (I.shapeFlag & 128)
            return I.suspense.next();
        const $ = m(I.anchor || I.el)
          , de = $ && $[v_];
        return de ? m(de) : $
    }
    ;
    let ve = !1;
    const ae = (I, $, de) => {
        I == null ? $._vnode && nt($._vnode, null, null, !0) : y($._vnode || null, I, $, null, null, null, de),
        $._vnode = I,
        ve || (ve = !0,
        Uh(),
        bc(),
        ve = !1)
    }
      , ze = {
        p: y,
        um: nt,
        m: qe,
        r: mt,
        mt: Y,
        mc: be,
        pc: se,
        pbc: ge,
        n: he,
        o: e
    };
    let Se, Je;
    return t && ([Se,Je] = t(ze)),
    {
        render: ae,
        hydrate: Se,
        createApp: f1(ae, Se)
    }
}
function Af({type: e, props: t}, n) {
    return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n
}
function ba({effect: e, job: t}, n) {
    n ? (e.flags |= 32,
    t.flags |= 4) : (e.flags &= -33,
    t.flags &= -5)
}
function X_(e, t) {
    return (!e || e && !e.pendingBranch) && t && !t.persisted
}
function ph(e, t, n=!1) {
    const r = e.children
      , i = t.children;
    if (Qt(r) && Qt(i))
        for (let s = 0; s < r.length; s++) {
            const o = r[s];
            let l = i[s];
            l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = i[s] = Qo(i[s]),
            l.el = o.el),
            !n && l.patchFlag !== -2 && ph(o, l)),
            l.type === na && (l.el = o.el)
        }
}
function y1(e) {
    const t = e.slice()
      , n = [0];
    let r, i, s, o, l;
    const u = e.length;
    for (r = 0; r < u; r++) {
        const p = e[r];
        if (p !== 0) {
            if (i = n[n.length - 1],
            e[i] < p) {
                t[r] = i,
                n.push(r);
                continue
            }
            for (s = 0,
            o = n.length - 1; s < o; )
                l = s + o >> 1,
                e[n[l]] < p ? s = l + 1 : o = l;
            p < e[n[s]] && (s > 0 && (t[r] = n[s - 1]),
            n[s] = r)
        }
    }
    for (s = n.length,
    o = n[s - 1]; s-- > 0; )
        n[s] = o,
        o = t[o];
    return n
}
function Q_(e) {
    const t = e.subTree.component;
    if (t)
        return t.asyncDep && !t.asyncResolved ? t : Q_(t)
}
function Ec(e) {
    if (e)
        for (let t = 0; t < e.length; t++)
            e[t].flags |= 8
}
const J_ = Symbol.for("v-scx")
  , Z_ = () => pr(J_);
function fs(e, t) {
    return xu(e, null, t)
}
function v1(e, t) {
    return xu(e, null, {
        flush: "post"
    })
}
function em(e, t) {
    return xu(e, null, {
        flush: "sync"
    })
}
function tr(e, t, n) {
    return xu(e, t, n)
}
function xu(e, t, n=jn) {
    const {immediate: r, deep: i, flush: s, once: o} = n
      , l = vr({}, n)
      , u = t && r || !t && s !== "post";
    let p;
    if (ll) {
        if (s === "sync") {
            const w = Z_();
            p = w.__watcherHandles || (w.__watcherHandles = [])
        } else if (!u) {
            const w = () => {}
            ;
            return w.stop = Ps,
            w.resume = Ps,
            w.pause = Ps,
            w
        }
    }
    const h = wi;
    l.call = (w, E, y) => Rs(w, h, E, y);
    let g = !1;
    s === "post" ? l.scheduler = w => {
        bi(w, h && h.suspense)
    }
    : s !== "sync" && (g = !0,
    l.scheduler = (w, E) => {
        E ? w() : eh(w)
    }
    ),
    l.augmentJob = w => {
        t && (w.flags |= 4),
        g && (w.flags |= 2,
        h && (w.id = h.uid,
        w.i = h))
    }
    ;
    const m = pv(e, t, l);
    return ll && (p ? p.push(m) : u && m()),
    m
}
function b1(e, t, n) {
    const r = this.proxy
      , i = Sr(e) ? e.includes(".") ? tm(r, e) : () => r[e] : e.bind(r, r);
    let s;
    dn(t) ? s = t : (s = t.handler,
    n = t);
    const o = Oa(this)
      , l = xu(i, s.bind(r), n);
    return o(),
    l
}
function tm(e, t) {
    const n = t.split(".");
    return () => {
        let r = e;
        for (let i = 0; i < n.length && r; i++)
            r = r[n[i]];
        return r
    }
}
function w1(e, t, n=jn) {
    const r = Or()
      , i = Ei(t)
      , s = cs(t)
      , o = nm(e, i)
      , l = Qc( (u, p) => {
        let h, g = jn, m;
        return em( () => {
            const w = e[i];
            es(h, w) && (h = w,
            p())
        }
        ),
        {
            get() {
                return u(),
                n.get ? n.get(h) : h
            },
            set(w) {
                const E = n.set ? n.set(w) : w;
                if (!es(E, h) && !(g !== jn && es(w, g)))
                    return;
                const y = r.vnode.props;
                y && (t in y || i in y || s in y) && (`onUpdate:${t}`in y || `onUpdate:${i}`in y || `onUpdate:${s}`in y) || (h = w,
                p()),
                r.emit(`update:${t}`, E),
                es(w, E) && es(w, g) && !es(E, m) && p(),
                g = w,
                m = E
            }
        }
    }
    );
    return l[Symbol.iterator] = () => {
        let u = 0;
        return {
            next() {
                return u < 2 ? {
                    value: u++ ? o || jn : l,
                    done: !1
                } : {
                    done: !0
                }
            }
        }
    }
    ,
    l
}
const nm = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${Ei(t)}Modifiers`] || e[`${cs(t)}Modifiers`];
function D1(e, t, ...n) {
    if (e.isUnmounted)
        return;
    const r = e.vnode.props || jn;
    let i = n;
    const s = t.startsWith("update:")
      , o = s && nm(r, t.slice(7));
    o && (o.trim && (i = n.map(h => Sr(h) ? h.trim() : h)),
    o.number && (i = n.map(gc)));
    let l, u = r[l = Za(t)] || r[l = Za(Ei(t))];
    !u && s && (u = r[l = Za(cs(t))]),
    u && Rs(u, e, 6, i);
    const p = r[l + "Once"];
    if (p) {
        if (!e.emitted)
            e.emitted = {};
        else if (e.emitted[l])
            return;
        e.emitted[l] = !0,
        Rs(p, e, 6, i)
    }
}
function rm(e, t, n=!1) {
    const r = t.emitsCache
      , i = r.get(e);
    if (i !== void 0)
        return i;
    const s = e.emits;
    let o = {}
      , l = !1;
    if (!dn(e)) {
        const u = p => {
            const h = rm(p, t, !0);
            h && (l = !0,
            vr(o, h))
        }
        ;
        !n && t.mixins.length && t.mixins.forEach(u),
        e.extends && u(e.extends),
        e.mixins && e.mixins.forEach(u)
    }
    return !s && !l ? (gr(e) && r.set(e, null),
    null) : (Qt(s) ? s.forEach(u => o[u] = null) : vr(o, s),
    gr(e) && r.set(e, o),
    o)
}
function nf(e, t) {
    return !e || !Du(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""),
    Zn(e, t[0].toLowerCase() + t.slice(1)) || Zn(e, cs(t)) || Zn(e, t))
}
function uc(e) {
    const {type: t, vnode: n, proxy: r, withProxy: i, propsOptions: [s], slots: o, attrs: l, emit: u, render: p, renderCache: h, props: g, data: m, setupState: w, ctx: E, inheritAttrs: y} = e
      , R = du(e);
    let P, x;
    try {
        if (n.shapeFlag & 4) {
            const k = i || r
              , S = k;
            P = us(p.call(S, k, h, g, w, m, E)),
            x = l
        } else {
            const k = t;
            P = us(k.length > 1 ? k(g, {
                attrs: l,
                slots: o,
                emit: u
            }) : k(g, null)),
            x = t.props ? l : C1(l)
        }
    } catch (k) {
        tu.length = 0,
        Ia(k, e, 1),
        P = tn(si)
    }
    let v = P;
    if (x && y !== !1) {
        const k = Object.keys(x)
          , {shapeFlag: S} = v;
        k.length && S & 7 && (s && k.some(Wd) && (x = x1(x, s)),
        v = Us(v, x, !1, !0))
    }
    return n.dirs && (v = Us(v, null, !1, !0),
    v.dirs = v.dirs ? v.dirs.concat(n.dirs) : n.dirs),
    n.transition && Ro(v, n.transition),
    P = v,
    du(R),
    P
}
function E1(e, t=!0) {
    let n;
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        if (Oo(i)) {
            if (i.type !== si || i.children === "v-if") {
                if (n)
                    return;
                n = i
            }
        } else
            return
    }
    return n
}
const C1 = e => {
    let t;
    for (const n in e)
        (n === "class" || n === "style" || Du(n)) && ((t || (t = {}))[n] = e[n]);
    return t
}
  , x1 = (e, t) => {
    const n = {};
    for (const r in e)
        (!Wd(r) || !(r.slice(9)in t)) && (n[r] = e[r]);
    return n
}
;
function S1(e, t, n) {
    const {props: r, children: i, component: s} = e
      , {props: o, children: l, patchFlag: u} = t
      , p = s.emitsOptions;
    if (t.dirs || t.transition)
        return !0;
    if (n && u >= 0) {
        if (u & 1024)
            return !0;
        if (u & 16)
            return r ? np(r, o, p) : !!o;
        if (u & 8) {
            const h = t.dynamicProps;
            for (let g = 0; g < h.length; g++) {
                const m = h[g];
                if (o[m] !== r[m] && !nf(p, m))
                    return !0
            }
        }
    } else
        return (i || l) && (!l || !l.$stable) ? !0 : r === o ? !1 : r ? o ? np(r, o, p) : !0 : !!o;
    return !1
}
function np(e, t, n) {
    const r = Object.keys(t);
    if (r.length !== Object.keys(e).length)
        return !0;
    for (let i = 0; i < r.length; i++) {
        const s = r[i];
        if (t[s] !== e[s] && !nf(n, s))
            return !0
    }
    return !1
}
function rf({vnode: e, parent: t}, n) {
    for (; t; ) {
        const r = t.subTree;
        if (r.suspense && r.suspense.activeBranch === e && (r.el = e.el),
        r === e)
            (e = t.vnode).el = n,
            t = t.parent;
        else
            break
    }
}
const Cc = e => e.__isSuspense;
let ld = 0;
const T1 = {
    name: "Suspense",
    __isSuspense: !0,
    process(e, t, n, r, i, s, o, l, u, p) {
        if (e == null)
            P1(t, n, r, i, s, o, l, u, p);
        else {
            if (s && s.deps > 0 && !e.suspense.isInFallback) {
                t.suspense = e.suspense,
                t.suspense.vnode = t,
                t.el = e.el;
                return
            }
            k1(e, t, n, r, i, o, l, u, p)
        }
    },
    hydrate: A1,
    normalize: R1
}
  , sf = T1;
function gu(e, t) {
    const n = e.props && e.props[t];
    dn(n) && n()
}
function P1(e, t, n, r, i, s, o, l, u) {
    const {p, o: {createElement: h}} = u
      , g = h("div")
      , m = e.suspense = im(e, i, r, t, g, n, s, o, l, u);
    p(null, m.pendingBranch = e.ssContent, g, null, r, m, s, o),
    m.deps > 0 ? (gu(e, "onPending"),
    gu(e, "onFallback"),
    p(null, e.ssFallback, t, n, r, null, s, o),
    rl(m, e.ssFallback)) : m.resolve(!1, !0)
}
function k1(e, t, n, r, i, s, o, l, {p: u, um: p, o: {createElement: h}}) {
    const g = t.suspense = e.suspense;
    g.vnode = t,
    t.el = e.el;
    const m = t.ssContent
      , w = t.ssFallback
      , {activeBranch: E, pendingBranch: y, isInFallback: R, isHydrating: P} = g;
    if (y)
        g.pendingBranch = m,
        Vs(m, y) ? (u(y, m, g.hiddenContainer, null, i, g, s, o, l),
        g.deps <= 0 ? g.resolve() : R && (P || (u(E, w, n, r, i, null, s, o, l),
        rl(g, w)))) : (g.pendingId = ld++,
        P ? (g.isHydrating = !1,
        g.activeBranch = y) : p(y, i, g),
        g.deps = 0,
        g.effects.length = 0,
        g.hiddenContainer = h("div"),
        R ? (u(null, m, g.hiddenContainer, null, i, g, s, o, l),
        g.deps <= 0 ? g.resolve() : (u(E, w, n, r, i, null, s, o, l),
        rl(g, w))) : E && Vs(m, E) ? (u(E, m, n, r, i, g, s, o, l),
        g.resolve(!0)) : (u(null, m, g.hiddenContainer, null, i, g, s, o, l),
        g.deps <= 0 && g.resolve()));
    else if (E && Vs(m, E))
        u(E, m, n, r, i, g, s, o, l),
        rl(g, m);
    else if (gu(t, "onPending"),
    g.pendingBranch = m,
    m.shapeFlag & 512 ? g.pendingId = m.component.suspenseId : g.pendingId = ld++,
    u(null, m, g.hiddenContainer, null, i, g, s, o, l),
    g.deps <= 0)
        g.resolve();
    else {
        const {timeout: x, pendingId: v} = g;
        x > 0 ? setTimeout( () => {
            g.pendingId === v && g.fallback(w)
        }
        , x) : x === 0 && g.fallback(w)
    }
}
function im(e, t, n, r, i, s, o, l, u, p, h=!1) {
    const {p: g, m, um: w, n: E, o: {parentNode: y, remove: R}} = p;
    let P;
    const x = O1(e);
    x && t && t.pendingBranch && (P = t.pendingId,
    t.deps++);
    const v = e.props ? _c(e.props.timeout) : void 0
      , k = s
      , S = {
        vnode: e,
        parent: t,
        parentComponent: n,
        namespace: o,
        container: r,
        hiddenContainer: i,
        deps: 0,
        pendingId: ld++,
        timeout: typeof v == "number" ? v : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !h,
        isHydrating: h,
        isUnmounted: !1,
        effects: [],
        resolve(W=!1, K=!1) {
            const {vnode: be, activeBranch: fe, pendingBranch: ge, pendingId: J, effects: re, parentComponent: ee, container: Y} = S;
            let Z = !1;
            S.isHydrating ? S.isHydrating = !1 : W || (Z = fe && ge.transition && ge.transition.mode === "out-in",
            Z && (fe.transition.afterLeave = () => {
                J === S.pendingId && (m(ge, Y, s === k ? E(fe) : s, 0),
                cu(re))
            }
            ),
            fe && (y(fe.el) === Y && (s = E(fe)),
            w(fe, ee, S, !0)),
            Z || m(ge, Y, s, 0)),
            rl(S, ge),
            S.pendingBranch = null,
            S.isInFallback = !1;
            let Q = S.parent
              , ue = !1;
            for (; Q; ) {
                if (Q.pendingBranch) {
                    Q.effects.push(...re),
                    ue = !0;
                    break
                }
                Q = Q.parent
            }
            !ue && !Z && cu(re),
            S.effects = [],
            x && t && t.pendingBranch && P === t.pendingId && (t.deps--,
            t.deps === 0 && !K && t.resolve()),
            gu(be, "onResolve")
        },
        fallback(W) {
            if (!S.pendingBranch)
                return;
            const {vnode: K, activeBranch: be, parentComponent: fe, container: ge, namespace: J} = S;
            gu(K, "onFallback");
            const re = E(be)
              , ee = () => {
                S.isInFallback && (g(null, W, ge, re, fe, null, J, l, u),
                rl(S, W))
            }
              , Y = W.transition && W.transition.mode === "out-in";
            Y && (be.transition.afterLeave = ee),
            S.isInFallback = !0,
            w(be, fe, null, !0),
            Y || ee()
        },
        move(W, K, be) {
            S.activeBranch && m(S.activeBranch, W, K, be),
            S.container = W
        },
        next() {
            return S.activeBranch && E(S.activeBranch)
        },
        registerDep(W, K, be) {
            const fe = !!S.pendingBranch;
            fe && S.deps++;
            const ge = W.vnode.el;
            W.asyncDep.catch(J => {
                Ia(J, W, 0)
            }
            ).then(J => {
                if (W.isUnmounted || S.isUnmounted || S.pendingId !== W.suspenseId)
                    return;
                W.asyncResolved = !0;
                const {vnode: re} = W;
                dd(W, J, !1),
                ge && (re.el = ge);
                const ee = !ge && W.subTree.el;
                K(W, re, y(ge || W.subTree.el), ge ? null : E(W.subTree), S, o, be),
                ee && R(ee),
                rf(W, re.el),
                fe && --S.deps === 0 && S.resolve()
            }
            )
        },
        unmount(W, K) {
            S.isUnmounted = !0,
            S.activeBranch && w(S.activeBranch, n, W, K),
            S.pendingBranch && w(S.pendingBranch, n, W, K)
        }
    };
    return S
}
function A1(e, t, n, r, i, s, o, l, u) {
    const p = t.suspense = im(t, r, n, e.parentNode, document.createElement("div"), null, i, s, o, l, !0)
      , h = u(e, p.pendingBranch = t.ssContent, n, p, s, o);
    return p.deps === 0 && p.resolve(!1, !0),
    h
}
function R1(e) {
    const {shapeFlag: t, children: n} = e
      , r = t & 32;
    e.ssContent = rp(r ? n.default : n),
    e.ssFallback = r ? rp(n.fallback) : tn(si)
}
function rp(e) {
    let t;
    if (dn(e)) {
        const n = Ra && e._c;
        n && (e._d = !1,
        It()),
        e = e(),
        n && (e._d = !0,
        t = Ui,
        om())
    }
    return Qt(e) && (e = E1(e)),
    e = us(e),
    t && !e.dynamicChildren && (e.dynamicChildren = t.filter(n => n !== e)),
    e
}
function sm(e, t) {
    t && t.pendingBranch ? Qt(e) ? t.effects.push(...e) : t.effects.push(e) : cu(e)
}
function rl(e, t) {
    e.activeBranch = t;
    const {vnode: n, parentComponent: r} = e;
    let i = t.el;
    for (; !i && t.component; )
        t = t.component.subTree,
        i = t.el;
    n.el = i,
    r && r.subTree === n && (r.vnode.el = i,
    rf(r, i))
}
function O1(e) {
    const t = e.props && e.props.suspensible;
    return t != null && t !== !1
}
const er = Symbol.for("v-fgt")
  , na = Symbol.for("v-txt")
  , si = Symbol.for("v-cmt")
  , Pa = Symbol.for("v-stc")
  , tu = [];
let Ui = null;
function It(e=!1) {
    tu.push(Ui = e ? null : [])
}
function om() {
    tu.pop(),
    Ui = tu[tu.length - 1] || null
}
let Ra = 1;
function ud(e, t=!1) {
    Ra += e,
    e < 0 && Ui && t && (Ui.hasOnce = !0)
}
function am(e) {
    return e.dynamicChildren = Ra > 0 ? Ui || Xa : null,
    om(),
    Ra > 0 && Ui && Ui.push(e),
    e
}
function Cn(e, t, n, r, i, s) {
    return am(kt(e, t, n, r, i, s, !0))
}
function Wn(e, t, n, r, i) {
    return am(tn(e, t, n, r, i, !0))
}
function Oo(e) {
    return e ? e.__v_isVNode === !0 : !1
}
function Vs(e, t) {
    return e.type === t.type && e.key === t.key
}
function M1(e) {}
const lm = ({key: e}) => e ?? null
  , cc = ({ref: e, ref_key: t, ref_for: n}) => (typeof e == "number" && (e = "" + e),
e != null ? Sr(e) || sr(e) || dn(e) ? {
    i: Di,
    r: e,
    k: t,
    f: !!n
} : e : null);
function kt(e, t=null, n=null, r=0, i=null, s=e === er ? 0 : 1, o=!1, l=!1) {
    const u = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && lm(t),
        ref: t && cc(t),
        scopeId: Jc,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: r,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
        ctx: Di
    };
    return l ? (_h(u, n),
    s & 128 && e.normalize(u)) : n && (u.shapeFlag |= Sr(n) ? 8 : 16),
    Ra > 0 && !o && Ui && (u.patchFlag > 0 || s & 6) && u.patchFlag !== 32 && Ui.push(u),
    u
}
const tn = L1;
function L1(e, t=null, n=null, r=0, i=null, s=!1) {
    if ((!e || e === M_) && (e = si),
    Oo(e)) {
        const l = Us(e, t, !0);
        return n && _h(l, n),
        Ra > 0 && !s && Ui && (l.shapeFlag & 6 ? Ui[Ui.indexOf(e)] = l : Ui.push(l)),
        l.patchFlag = -2,
        l
    }
    if (V1(e) && (e = e.__vccOpts),
    t) {
        t = um(t);
        let {class: l, style: u} = t;
        l && !Sr(l) && (t.class = ks(l)),
        gr(u) && (Xc(u) && !Qt(u) && (u = vr({}, u)),
        t.style = ml(u))
    }
    const o = Sr(e) ? 1 : Cc(e) ? 128 : b_(e) ? 64 : gr(e) ? 4 : dn(e) ? 2 : 0;
    return kt(e, t, n, r, i, o, s, !0)
}
function um(e) {
    return e ? Xc(e) || H_(e) ? vr({}, e) : e : null
}
function Us(e, t, n=!1, r=!1) {
    const {props: i, ref: s, patchFlag: o, children: l, transition: u} = e
      , p = t ? oo(i || {}, t) : i
      , h = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: p,
        key: p && lm(p),
        ref: t && t.ref ? n && s ? Qt(s) ? s.concat(cc(t)) : [s, cc(t)] : cc(t) : s,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: l,
        target: e.target,
        targetStart: e.targetStart,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== er ? o === -1 ? 16 : o | 16 : o,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: u,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && Us(e.ssContent),
        ssFallback: e.ssFallback && Us(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
        ctx: e.ctx,
        ce: e.ce
    };
    return u && r && Ro(h, u.clone(h)),
    h
}
function To(e=" ", t=0) {
    return tn(na, null, e, t)
}
function gh(e, t) {
    const n = tn(Pa, null, e);
    return n.staticCount = t,
    n
}
function ii(e="", t=!1) {
    return t ? (It(),
    Wn(si, null, e)) : tn(si, null, e)
}
function us(e) {
    return e == null || typeof e == "boolean" ? tn(si) : Qt(e) ? tn(er, null, e.slice()) : Oo(e) ? Qo(e) : tn(na, null, String(e))
}
function Qo(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : Us(e)
}
function _h(e, t) {
    let n = 0;
    const {shapeFlag: r} = e;
    if (t == null)
        t = null;
    else if (Qt(t))
        n = 16;
    else if (typeof t == "object")
        if (r & 65) {
            const i = t.default;
            i && (i._c && (i._d = !1),
            _h(e, i()),
            i._c && (i._d = !0));
            return
        } else {
            n = 32;
            const i = t._;
            !i && !H_(t) ? t._ctx = Di : i === 3 && Di && (Di.slots._ === 1 ? t._ = 1 : (t._ = 2,
            e.patchFlag |= 1024))
        }
    else
        dn(t) ? (t = {
            default: t,
            _ctx: Di
        },
        n = 32) : (t = String(t),
        r & 64 ? (n = 16,
        t = [To(t)]) : n = 8);
    e.children = t,
    e.shapeFlag |= n
}
function oo(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        for (const i in r)
            if (i === "class")
                t.class !== r.class && (t.class = ks([t.class, r.class]));
            else if (i === "style")
                t.style = ml([t.style, r.style]);
            else if (Du(i)) {
                const s = t[i]
                  , o = r[i];
                o && s !== o && !(Qt(s) && s.includes(o)) && (t[i] = s ? [].concat(s, o) : o)
            } else
                i !== "" && (t[i] = r[i])
    }
    return t
}
function ls(e, t, n, r=null) {
    Rs(e, t, 7, [n, r])
}
const F1 = N_();
let I1 = 0;
function cm(e, t, n) {
    const r = e.type
      , i = (t ? t.appContext : e.appContext) || F1
      , s = {
        uid: I1++,
        vnode: e,
        type: r,
        parent: t,
        appContext: i,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        job: null,
        scope: new Kd(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(i.provides),
        ids: t ? t.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: j_(r, i),
        emitsOptions: rm(r, i),
        emit: null,
        emitted: null,
        propsDefaults: jn,
        inheritAttrs: r.inheritAttrs,
        ctx: jn,
        data: jn,
        props: jn,
        attrs: jn,
        slots: jn,
        refs: jn,
        setupState: jn,
        setupContext: null,
        suspense: n,
        suspenseId: n ? n.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return s.ctx = {
        _: s
    },
    s.root = t ? t.root : s,
    s.emit = D1.bind(null, s),
    e.ce && e.ce(s),
    s
}
let wi = null;
const Or = () => wi || Di;
let xc, cd;
{
    const e = Uc()
      , t = (n, r) => {
        let i;
        return (i = e[n]) || (i = e[n] = []),
        i.push(r),
        s => {
            i.length > 1 ? i.forEach(o => o(s)) : i[0](s)
        }
    }
    ;
    xc = t("__VUE_INSTANCE_SETTERS__", n => wi = n),
    cd = t("__VUE_SSR_SETTERS__", n => ll = n)
}
const Oa = e => {
    const t = wi;
    return xc(e),
    e.scope.on(),
    () => {
        e.scope.off(),
        xc(t)
    }
}
  , fd = () => {
    wi && wi.scope.off(),
    xc(null)
}
;
function fm(e) {
    return e.vnode.shapeFlag & 4
}
let ll = !1;
function dm(e, t=!1, n=!1) {
    t && cd(t);
    const {props: r, children: i} = e.vnode
      , s = fm(e);
    d1(e, r, s, t),
    _1(e, i, n);
    const o = s ? N1(e, t) : void 0;
    return t && cd(!1),
    o
}
function N1(e, t) {
    const n = e.type;
    e.accessCache = Object.create(null),
    e.proxy = new Proxy(e.ctx,id);
    const {setup: r} = n;
    if (r) {
        oa();
        const i = e.setupContext = r.length > 1 ? pm(e) : null
          , s = Oa(e)
          , o = vl(r, e, 0, [e.props, i])
          , l = Gd(o);
        if (aa(),
        s(),
        (l || e.sp) && !ta(e) && rh(e),
        l) {
            if (o.then(fd, fd),
            t)
                return o.then(u => {
                    dd(e, u, t)
                }
                ).catch(u => {
                    Ia(u, e, 0)
                }
                );
            e.asyncDep = o
        } else
            dd(e, o, t)
    } else
        hm(e, t)
}
function dd(e, t, n) {
    dn(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : gr(t) && (e.setupState = Zd(t)),
    hm(e, n)
}
let Sc, hd;
function $1(e) {
    Sc = e,
    hd = t => {
        t.render._rc && (t.withProxy = new Proxy(t.ctx,qv))
    }
}
const B1 = () => !Sc;
function hm(e, t, n) {
    const r = e.type;
    if (!e.render) {
        if (!t && Sc && !r.render) {
            const i = r.template || dh(e).template;
            if (i) {
                const {isCustomElement: s, compilerOptions: o} = e.appContext.config
                  , {delimiters: l, compilerOptions: u} = r
                  , p = vr(vr({
                    isCustomElement: s,
                    delimiters: l
                }, o), u);
                r.render = Sc(i, p)
            }
        }
        e.render = r.render || Ps,
        hd && hd(e)
    }
    {
        const i = Oa(e);
        oa();
        try {
            s1(e)
        } finally {
            aa(),
            i()
        }
    }
}
const H1 = {
    get(e, t) {
        return ji(e, "get", ""),
        e[t]
    }
};
function pm(e) {
    const t = n => {
        e.exposed = n || {}
    }
    ;
    return {
        attrs: new Proxy(e.attrs,H1),
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}
function Su(e) {
    return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Zd(Eu(e.exposed)),{
        get(t, n) {
            if (n in t)
                return t[n];
            if (n in eu)
                return eu[n](e)
        },
        has(t, n) {
            return n in t || n in eu
        }
    })) : e.proxy
}
function pd(e, t=!0) {
    return dn(e) ? e.displayName || e.name : e.name || t && e.__name
}
function V1(e) {
    return dn(e) && "__vccOpts"in e
}
const zt = (e, t) => fv(e, t, ll);
function ar(e, t, n) {
    const r = arguments.length;
    return r === 2 ? gr(t) && !Qt(t) ? Oo(t) ? tn(e, null, [t]) : tn(e, t) : tn(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && Oo(n) && (n = [n]),
    tn(e, t, n))
}
function j1() {}
function z1(e, t, n, r) {
    const i = n[r];
    if (i && gm(i, e))
        return i;
    const s = t();
    return s.memo = e.slice(),
    s.cacheIndex = r,
    n[r] = s
}
function gm(e, t) {
    const n = e.memo;
    if (n.length != t.length)
        return !1;
    for (let r = 0; r < n.length; r++)
        if (es(n[r], t[r]))
            return !1;
    return Ra > 0 && Ui && Ui.push(e),
    !0
}
const _m = "3.5.13"
  , U1 = Ps
  , W1 = vv
  , q1 = Ga
  , G1 = y_
  , Y1 = {
    createComponentInstance: cm,
    setupComponent: dm,
    renderComponentRoot: uc,
    setCurrentRenderingInstance: du,
    isVNode: Oo,
    normalizeVNode: us,
    getComponentPublicInstance: Su,
    ensureValidVNode: fh,
    pushWarningContext: gv,
    popWarningContext: _v
}
  , K1 = Y1
  , X1 = null
  , Q1 = null
  , J1 = null;
/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let gd;
const ip = typeof window < "u" && window.trustedTypes;
if (ip)
    try {
        gd = ip.createPolicy("vue", {
            createHTML: e => e
        })
    } catch {}
const mm = gd ? e => gd.createHTML(e) : e => e
  , Z1 = "http://www.w3.org/2000/svg"
  , eb = "http://www.w3.org/1998/Math/MathML"
  , Do = typeof document < "u" ? document : null
  , sp = Do && Do.createElement("template")
  , tb = {
    insert: (e, t, n) => {
        t.insertBefore(e, n || null)
    }
    ,
    remove: e => {
        const t = e.parentNode;
        t && t.removeChild(e)
    }
    ,
    createElement: (e, t, n, r) => {
        const i = t === "svg" ? Do.createElementNS(Z1, e) : t === "mathml" ? Do.createElementNS(eb, e) : n ? Do.createElement(e, {
            is: n
        }) : Do.createElement(e);
        return e === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple),
        i
    }
    ,
    createText: e => Do.createTextNode(e),
    createComment: e => Do.createComment(e),
    setText: (e, t) => {
        e.nodeValue = t
    }
    ,
    setElementText: (e, t) => {
        e.textContent = t
    }
    ,
    parentNode: e => e.parentNode,
    nextSibling: e => e.nextSibling,
    querySelector: e => Do.querySelector(e),
    setScopeId(e, t) {
        e.setAttribute(t, "")
    },
    insertStaticContent(e, t, n, r, i, s) {
        const o = n ? n.previousSibling : t.lastChild;
        if (i && (i === s || i.nextSibling))
            for (; t.insertBefore(i.cloneNode(!0), n),
            !(i === s || !(i = i.nextSibling)); )
                ;
        else {
            sp.innerHTML = mm(r === "svg" ? `<svg>${e}</svg>` : r === "mathml" ? `<math>${e}</math>` : e);
            const l = sp.content;
            if (r === "svg" || r === "mathml") {
                const u = l.firstChild;
                for (; u.firstChild; )
                    l.appendChild(u.firstChild);
                l.removeChild(u)
            }
            t.insertBefore(l, n)
        }
        return [o ? o.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    }
}
  , Vo = "transition"
  , Ml = "animation"
  , ul = Symbol("_vtc")
  , ym = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}
  , vm = vr({}, nh, ym)
  , nb = e => (e.displayName = "Transition",
e.props = vm,
e)
  , bm = nb( (e, {slots: t}) => ar(S_, wm(e), t))
  , wa = (e, t=[]) => {
    Qt(e) ? e.forEach(n => n(...t)) : e && e(...t)
}
  , op = e => e ? Qt(e) ? e.some(t => t.length > 1) : e.length > 1 : !1;
function wm(e) {
    const t = {};
    for (const re in e)
        re in ym || (t[re] = e[re]);
    if (e.css === !1)
        return t;
    const {name: n="v", type: r, duration: i, enterFromClass: s=`${n}-enter-from`, enterActiveClass: o=`${n}-enter-active`, enterToClass: l=`${n}-enter-to`, appearFromClass: u=s, appearActiveClass: p=o, appearToClass: h=l, leaveFromClass: g=`${n}-leave-from`, leaveActiveClass: m=`${n}-leave-active`, leaveToClass: w=`${n}-leave-to`} = e
      , E = rb(i)
      , y = E && E[0]
      , R = E && E[1]
      , {onBeforeEnter: P, onEnter: x, onEnterCancelled: v, onLeave: k, onLeaveCancelled: S, onBeforeAppear: W=P, onAppear: K=x, onAppearCancelled: be=v} = t
      , fe = (re, ee, Y, Z) => {
        re._enterCancelled = Z,
        qo(re, ee ? h : l),
        qo(re, ee ? p : o),
        Y && Y()
    }
      , ge = (re, ee) => {
        re._isLeaving = !1,
        qo(re, g),
        qo(re, w),
        qo(re, m),
        ee && ee()
    }
      , J = re => (ee, Y) => {
        const Z = re ? K : x
          , Q = () => fe(ee, re, Y);
        wa(Z, [ee, Q]),
        ap( () => {
            qo(ee, re ? u : s),
            to(ee, re ? h : l),
            op(Z) || lp(ee, r, y, Q)
        }
        )
    }
    ;
    return vr(t, {
        onBeforeEnter(re) {
            wa(P, [re]),
            to(re, s),
            to(re, o)
        },
        onBeforeAppear(re) {
            wa(W, [re]),
            to(re, u),
            to(re, p)
        },
        onEnter: J(!1),
        onAppear: J(!0),
        onLeave(re, ee) {
            re._isLeaving = !0;
            const Y = () => ge(re, ee);
            to(re, g),
            re._enterCancelled ? (to(re, m),
            _d()) : (_d(),
            to(re, m)),
            ap( () => {
                re._isLeaving && (qo(re, g),
                to(re, w),
                op(k) || lp(re, r, R, Y))
            }
            ),
            wa(k, [re, Y])
        },
        onEnterCancelled(re) {
            fe(re, !1, void 0, !0),
            wa(v, [re])
        },
        onAppearCancelled(re) {
            fe(re, !0, void 0, !0),
            wa(be, [re])
        },
        onLeaveCancelled(re) {
            ge(re),
            wa(S, [re])
        }
    })
}
function rb(e) {
    if (e == null)
        return null;
    if (gr(e))
        return [Rf(e.enter), Rf(e.leave)];
    {
        const t = Rf(e);
        return [t, t]
    }
}
function Rf(e) {
    return _c(e)
}
function to(e, t) {
    t.split(/\s+/).forEach(n => n && e.classList.add(n)),
    (e[ul] || (e[ul] = new Set)).add(t)
}
function qo(e, t) {
    t.split(/\s+/).forEach(r => r && e.classList.remove(r));
    const n = e[ul];
    n && (n.delete(t),
    n.size || (e[ul] = void 0))
}
function ap(e) {
    requestAnimationFrame( () => {
        requestAnimationFrame(e)
    }
    )
}
let ib = 0;
function lp(e, t, n, r) {
    const i = e._endId = ++ib
      , s = () => {
        i === e._endId && r()
    }
    ;
    if (n != null)
        return setTimeout(s, n);
    const {type: o, timeout: l, propCount: u} = Dm(e, t);
    if (!o)
        return r();
    const p = o + "end";
    let h = 0;
    const g = () => {
        e.removeEventListener(p, m),
        s()
    }
      , m = w => {
        w.target === e && ++h >= u && g()
    }
    ;
    setTimeout( () => {
        h < u && g()
    }
    , l + 1),
    e.addEventListener(p, m)
}
function Dm(e, t) {
    const n = window.getComputedStyle(e)
      , r = E => (n[E] || "").split(", ")
      , i = r(`${Vo}Delay`)
      , s = r(`${Vo}Duration`)
      , o = up(i, s)
      , l = r(`${Ml}Delay`)
      , u = r(`${Ml}Duration`)
      , p = up(l, u);
    let h = null
      , g = 0
      , m = 0;
    t === Vo ? o > 0 && (h = Vo,
    g = o,
    m = s.length) : t === Ml ? p > 0 && (h = Ml,
    g = p,
    m = u.length) : (g = Math.max(o, p),
    h = g > 0 ? o > p ? Vo : Ml : null,
    m = h ? h === Vo ? s.length : u.length : 0);
    const w = h === Vo && /\b(transform|all)(,|$)/.test(r(`${Vo}Property`).toString());
    return {
        type: h,
        timeout: g,
        propCount: m,
        hasTransform: w
    }
}
function up(e, t) {
    for (; e.length < t.length; )
        e = e.concat(e);
    return Math.max(...t.map( (n, r) => cp(n) + cp(e[r])))
}
function cp(e) {
    return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3
}
function _d() {
    return document.body.offsetHeight
}
function sb(e, t, n) {
    const r = e[ul];
    r && (t = (t ? [t, ...r] : [...r]).join(" ")),
    t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
}
const Tc = Symbol("_vod")
  , Em = Symbol("_vsh")
  , Cm = {
    beforeMount(e, {value: t}, {transition: n}) {
        e[Tc] = e.style.display === "none" ? "" : e.style.display,
        n && t ? n.beforeEnter(e) : Ll(e, t)
    },
    mounted(e, {value: t}, {transition: n}) {
        n && t && n.enter(e)
    },
    updated(e, {value: t, oldValue: n}, {transition: r}) {
        !t != !n && (r ? t ? (r.beforeEnter(e),
        Ll(e, !0),
        r.enter(e)) : r.leave(e, () => {
            Ll(e, !1)
        }
        ) : Ll(e, t))
    },
    beforeUnmount(e, {value: t}) {
        Ll(e, t)
    }
};
function Ll(e, t) {
    e.style.display = t ? e[Tc] : "none",
    e[Em] = !t
}
function ob() {
    Cm.getSSRProps = ({value: e}) => {
        if (!e)
            return {
                style: {
                    display: "none"
                }
            }
    }
}
const xm = Symbol("");
function Sm(e) {
    const t = Or();
    if (!t)
        return;
    const n = t.ut = (i=e(t.proxy)) => {
        Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(s => Pc(s, i))
    }
      , r = () => {
        const i = e(t.proxy);
        t.ce ? Pc(t.ce, i) : md(t.subTree, i),
        n(i)
    }
    ;
    ah( () => {
        cu(r)
    }
    ),
    xi( () => {
        tr(r, Ps, {
            flush: "post"
        });
        const i = new MutationObserver(r);
        i.observe(t.subTree.el.parentNode, {
            childList: !0
        }),
        bl( () => i.disconnect())
    }
    )
}
function md(e, t) {
    if (e.shapeFlag & 128) {
        const n = e.suspense;
        e = n.activeBranch,
        n.pendingBranch && !n.isHydrating && n.effects.push( () => {
            md(n.activeBranch, t)
        }
        )
    }
    for (; e.component; )
        e = e.component.subTree;
    if (e.shapeFlag & 1 && e.el)
        Pc(e.el, t);
    else if (e.type === er)
        e.children.forEach(n => md(n, t));
    else if (e.type === Pa) {
        let {el: n, anchor: r} = e;
        for (; n && (Pc(n, t),
        n !== r); )
            n = n.nextSibling
    }
}
function Pc(e, t) {
    if (e.nodeType === 1) {
        const n = e.style;
        let r = "";
        for (const i in t)
            n.setProperty(`--${i}`, t[i]),
            r += `--${i}: ${t[i]};`;
        n[xm] = r
    }
}
const ab = /(^|;)\s*display\s*:/;
function lb(e, t, n) {
    const r = e.style
      , i = Sr(n);
    let s = !1;
    if (n && !i) {
        if (t)
            if (Sr(t))
                for (const o of t.split(";")) {
                    const l = o.slice(0, o.indexOf(":")).trim();
                    n[l] == null && fc(r, l, "")
                }
            else
                for (const o in t)
                    n[o] == null && fc(r, o, "");
        for (const o in n)
            o === "display" && (s = !0),
            fc(r, o, n[o])
    } else if (i) {
        if (t !== n) {
            const o = r[xm];
            o && (n += ";" + o),
            r.cssText = n,
            s = ab.test(n)
        }
    } else
        t && e.removeAttribute("style");
    Tc in e && (e[Tc] = s ? r.display : "",
    e[Em] && (r.display = "none"))
}
const fp = /\s*!important$/;
function fc(e, t, n) {
    if (Qt(n))
        n.forEach(r => fc(e, t, r));
    else if (n == null && (n = ""),
    t.startsWith("--"))
        e.setProperty(t, n);
    else {
        const r = ub(e, t);
        fp.test(n) ? e.setProperty(cs(r), n.replace(fp, ""), "important") : e[r] = n
    }
}
const dp = ["Webkit", "Moz", "ms"]
  , Of = {};
function ub(e, t) {
    const n = Of[t];
    if (n)
        return n;
    let r = Ei(t);
    if (r !== "filter" && r in e)
        return Of[t] = r;
    r = _l(r);
    for (let i = 0; i < dp.length; i++) {
        const s = dp[i] + r;
        if (s in e)
            return Of[t] = s
    }
    return t
}
const hp = "http://www.w3.org/1999/xlink";
function pp(e, t, n, r, i, s=Fy(t)) {
    r && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(hp, t.slice(6, t.length)) : e.setAttributeNS(hp, t, n) : n == null || s && !Gg(n) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : zs(n) ? String(n) : n)
}
function gp(e, t, n, r, i) {
    if (t === "innerHTML" || t === "textContent") {
        n != null && (e[t] = t === "innerHTML" ? mm(n) : n);
        return
    }
    const s = e.tagName;
    if (t === "value" && s !== "PROGRESS" && !s.includes("-")) {
        const l = s === "OPTION" ? e.getAttribute("value") || "" : e.value
          , u = n == null ? e.type === "checkbox" ? "on" : "" : String(n);
        (l !== u || !("_value"in e)) && (e.value = u),
        n == null && e.removeAttribute(t),
        e._value = n;
        return
    }
    let o = !1;
    if (n === "" || n == null) {
        const l = typeof e[t];
        l === "boolean" ? n = Gg(n) : n == null && l === "string" ? (n = "",
        o = !0) : l === "number" && (n = 0,
        o = !0)
    }
    try {
        e[t] = n
    } catch {}
    o && e.removeAttribute(i || t)
}
function xo(e, t, n, r) {
    e.addEventListener(t, n, r)
}
function cb(e, t, n, r) {
    e.removeEventListener(t, n, r)
}
const _p = Symbol("_vei");
function fb(e, t, n, r, i=null) {
    const s = e[_p] || (e[_p] = {})
      , o = s[t];
    if (r && o)
        o.value = r;
    else {
        const [l,u] = db(t);
        if (r) {
            const p = s[t] = gb(r, i);
            xo(e, l, p, u)
        } else
            o && (cb(e, l, o, u),
            s[t] = void 0)
    }
}
const mp = /(?:Once|Passive|Capture)$/;
function db(e) {
    let t;
    if (mp.test(e)) {
        t = {};
        let r;
        for (; r = e.match(mp); )
            e = e.slice(0, e.length - r[0].length),
            t[r[0].toLowerCase()] = !0
    }
    return [e[2] === ":" ? e.slice(3) : cs(e.slice(2)), t]
}
let Mf = 0;
const hb = Promise.resolve()
  , pb = () => Mf || (hb.then( () => Mf = 0),
Mf = Date.now());
function gb(e, t) {
    const n = r => {
        if (!r._vts)
            r._vts = Date.now();
        else if (r._vts <= n.attached)
            return;
        Rs(_b(r, n.value), t, 5, [r])
    }
    ;
    return n.value = e,
    n.attached = pb(),
    n
}
function _b(e, t) {
    if (Qt(t)) {
        const n = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = () => {
            n.call(e),
            e._stopped = !0
        }
        ,
        t.map(r => i => !i._stopped && r && r(i))
    } else
        return t
}
const yp = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123
  , mb = (e, t, n, r, i, s) => {
    const o = i === "svg";
    t === "class" ? sb(e, r, o) : t === "style" ? lb(e, n, r) : Du(t) ? Wd(t) || fb(e, t, n, r, s) : (t[0] === "." ? (t = t.slice(1),
    !0) : t[0] === "^" ? (t = t.slice(1),
    !1) : yb(e, t, r, o)) ? (gp(e, t, r),
    !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && pp(e, t, r, o, s, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !Sr(r)) ? gp(e, Ei(t), r, s, t) : (t === "true-value" ? e._trueValue = r : t === "false-value" && (e._falseValue = r),
    pp(e, t, r, o))
}
;
function yb(e, t, n, r) {
    if (r)
        return !!(t === "innerHTML" || t === "textContent" || t in e && yp(t) && dn(n));
    if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
        return !1;
    if (t === "width" || t === "height") {
        const i = e.tagName;
        if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
            return !1
    }
    return yp(t) && Sr(n) ? !1 : t in e
}
const vp = {};
/*! #__NO_SIDE_EFFECTS__ */
function Tm(e, t, n) {
    const r = Mn(e, t);
    jc(r) && vr(r, t);
    class i extends of {
        constructor(o) {
            super(r, o, n)
        }
    }
    return i.def = r,
    i
}
/*! #__NO_SIDE_EFFECTS__ */
const vb = (e, t) => Tm(e, t, vh)
  , bb = typeof HTMLElement < "u" ? HTMLElement : class {
}
;
class of extends bb {
    constructor(t, n={}, r=Rc) {
        super(),
        this._def = t,
        this._props = n,
        this._createApp = r,
        this._isVueCE = !0,
        this._instance = null,
        this._app = null,
        this._nonce = this._def.nonce,
        this._connected = !1,
        this._resolved = !1,
        this._numberProps = null,
        this._styleChildren = new WeakSet,
        this._ob = null,
        this.shadowRoot && r !== Rc ? this._root = this.shadowRoot : t.shadowRoot !== !1 ? (this.attachShadow({
            mode: "open"
        }),
        this._root = this.shadowRoot) : this._root = this,
        this._def.__asyncLoader || this._resolveProps(this._def)
    }
    connectedCallback() {
        if (!this.isConnected)
            return;
        this.shadowRoot || this._parseSlots(),
        this._connected = !0;
        let t = this;
        for (; t = t && (t.parentNode || t.host); )
            if (t instanceof of) {
                this._parent = t;
                break
            }
        this._instance || (this._resolved ? (this._setParent(),
        this._update()) : t && t._pendingResolve ? this._pendingResolve = t._pendingResolve.then( () => {
            this._pendingResolve = void 0,
            this._resolveDef()
        }
        ) : this._resolveDef())
    }
    _setParent(t=this._parent) {
        t && (this._instance.parent = t._instance,
        this._instance.provides = t._instance.provides)
    }
    disconnectedCallback() {
        this._connected = !1,
        Ci( () => {
            this._connected || (this._ob && (this._ob.disconnect(),
            this._ob = null),
            this._app && this._app.unmount(),
            this._instance && (this._instance.ce = void 0),
            this._app = this._instance = null)
        }
        )
    }
    _resolveDef() {
        if (this._pendingResolve)
            return;
        for (let r = 0; r < this.attributes.length; r++)
            this._setAttr(this.attributes[r].name);
        this._ob = new MutationObserver(r => {
            for (const i of r)
                this._setAttr(i.attributeName)
        }
        ),
        this._ob.observe(this, {
            attributes: !0
        });
        const t = (r, i=!1) => {
            this._resolved = !0,
            this._pendingResolve = void 0;
            const {props: s, styles: o} = r;
            let l;
            if (s && !Qt(s))
                for (const u in s) {
                    const p = s[u];
                    (p === Number || p && p.type === Number) && (u in this._props && (this._props[u] = _c(this._props[u])),
                    (l || (l = Object.create(null)))[Ei(u)] = !0)
                }
            this._numberProps = l,
            i && this._resolveProps(r),
            this.shadowRoot && this._applyStyles(o),
            this._mount(r)
        }
          , n = this._def.__asyncLoader;
        n ? this._pendingResolve = n().then(r => t(this._def = r, !0)) : t(this._def)
    }
    _mount(t) {
        this._app = this._createApp(t),
        t.configureApp && t.configureApp(this._app),
        this._app._ceVNode = this._createVNode(),
        this._app.mount(this._root);
        const n = this._instance && this._instance.exposed;
        if (n)
            for (const r in n)
                Zn(this, r) || Object.defineProperty(this, r, {
                    get: () => Re(n[r])
                })
    }
    _resolveProps(t) {
        const {props: n} = t
          , r = Qt(n) ? n : Object.keys(n || {});
        for (const i of Object.keys(this))
            i[0] !== "_" && r.includes(i) && this._setProp(i, this[i]);
        for (const i of r.map(Ei))
            Object.defineProperty(this, i, {
                get() {
                    return this._getProp(i)
                },
                set(s) {
                    this._setProp(i, s, !0, !0)
                }
            })
    }
    _setAttr(t) {
        if (t.startsWith("data-v-"))
            return;
        const n = this.hasAttribute(t);
        let r = n ? this.getAttribute(t) : vp;
        const i = Ei(t);
        n && this._numberProps && this._numberProps[i] && (r = _c(r)),
        this._setProp(i, r, !1, !0)
    }
    _getProp(t) {
        return this._props[t]
    }
    _setProp(t, n, r=!0, i=!1) {
        if (n !== this._props[t] && (n === vp ? delete this._props[t] : (this._props[t] = n,
        t === "key" && this._app && (this._app._ceVNode.key = n)),
        i && this._instance && this._update(),
        r)) {
            const s = this._ob;
            s && s.disconnect(),
            n === !0 ? this.setAttribute(cs(t), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(cs(t), n + "") : n || this.removeAttribute(cs(t)),
            s && s.observe(this, {
                attributes: !0
            })
        }
    }
    _update() {
        Bm(this._createVNode(), this._root)
    }
    _createVNode() {
        const t = {};
        this.shadowRoot || (t.onVnodeMounted = t.onVnodeUpdated = this._renderSlots.bind(this));
        const n = tn(this._def, vr(t, this._props));
        return this._instance || (n.ce = r => {
            this._instance = r,
            r.ce = this,
            r.isCE = !0;
            const i = (s, o) => {
                this.dispatchEvent(new CustomEvent(s,jc(o[0]) ? vr({
                    detail: o
                }, o[0]) : {
                    detail: o
                }))
            }
            ;
            r.emit = (s, ...o) => {
                i(s, o),
                cs(s) !== s && i(cs(s), o)
            }
            ,
            this._setParent()
        }
        ),
        n
    }
    _applyStyles(t, n) {
        if (!t)
            return;
        if (n) {
            if (n === this._def || this._styleChildren.has(n))
                return;
            this._styleChildren.add(n)
        }
        const r = this._nonce;
        for (let i = t.length - 1; i >= 0; i--) {
            const s = document.createElement("style");
            r && s.setAttribute("nonce", r),
            s.textContent = t[i],
            this.shadowRoot.prepend(s)
        }
    }
    _parseSlots() {
        const t = this._slots = {};
        let n;
        for (; n = this.firstChild; ) {
            const r = n.nodeType === 1 && n.getAttribute("slot") || "default";
            (t[r] || (t[r] = [])).push(n),
            this.removeChild(n)
        }
    }
    _renderSlots() {
        const t = (this._teleportTarget || this).querySelectorAll("slot")
          , n = this._instance.type.__scopeId;
        for (let r = 0; r < t.length; r++) {
            const i = t[r]
              , s = i.getAttribute("name") || "default"
              , o = this._slots[s]
              , l = i.parentNode;
            if (o)
                for (const u of o) {
                    if (n && u.nodeType === 1) {
                        const p = n + "-s"
                          , h = document.createTreeWalker(u, 1);
                        u.setAttribute(p, "");
                        let g;
                        for (; g = h.nextNode(); )
                            g.setAttribute(p, "")
                    }
                    l.insertBefore(u, i)
                }
            else
                for (; i.firstChild; )
                    l.insertBefore(i.firstChild, i);
            l.removeChild(i)
        }
    }
    _injectChildStyle(t) {
        this._applyStyles(t.styles, t)
    }
    _removeChildStyle(t) {}
}
function Pm(e) {
    const t = Or()
      , n = t && t.ce;
    return n || null
}
function wb() {
    const e = Pm();
    return e && e.shadowRoot
}
function Db(e="$style") {
    {
        const t = Or();
        if (!t)
            return jn;
        const n = t.type.__cssModules;
        if (!n)
            return jn;
        const r = n[e];
        return r || jn
    }
}
const km = new WeakMap
  , Am = new WeakMap
  , kc = Symbol("_moveCb")
  , bp = Symbol("_enterCb")
  , Eb = e => (delete e.props.mode,
e)
  , Cb = Eb({
    name: "TransitionGroup",
    props: vr({}, vm, {
        tag: String,
        moveClass: String
    }),
    setup(e, {slots: t}) {
        const n = Or()
          , r = th();
        let i, s;
        return tf( () => {
            if (!i.length)
                return;
            const o = e.moveClass || `${e.name || "v"}-move`;
            if (!kb(i[0].el, n.vnode.el, o))
                return;
            i.forEach(Sb),
            i.forEach(Tb);
            const l = i.filter(Pb);
            _d(),
            l.forEach(u => {
                const p = u.el
                  , h = p.style;
                to(p, o),
                h.transform = h.webkitTransform = h.transitionDuration = "";
                const g = p[kc] = m => {
                    m && m.target !== p || (!m || /transform$/.test(m.propertyName)) && (p.removeEventListener("transitionend", g),
                    p[kc] = null,
                    qo(p, o))
                }
                ;
                p.addEventListener("transitionend", g)
            }
            )
        }
        ),
        () => {
            const o = Nn(e)
              , l = wm(o);
            let u = o.tag || er;
            if (i = [],
            s)
                for (let p = 0; p < s.length; p++) {
                    const h = s[p];
                    h.el && h.el instanceof Element && (i.push(h),
                    Ro(h, al(h, l, r, n)),
                    km.set(h, h.el.getBoundingClientRect()))
                }
            s = t.default ? Zc(t.default()) : [];
            for (let p = 0; p < s.length; p++) {
                const h = s[p];
                h.key != null && Ro(h, al(h, l, r, n))
            }
            return tn(u, null, s)
        }
    }
})
  , xb = Cb;
function Sb(e) {
    const t = e.el;
    t[kc] && t[kc](),
    t[bp] && t[bp]()
}
function Tb(e) {
    Am.set(e, e.el.getBoundingClientRect())
}
function Pb(e) {
    const t = km.get(e)
      , n = Am.get(e)
      , r = t.left - n.left
      , i = t.top - n.top;
    if (r || i) {
        const s = e.el.style;
        return s.transform = s.webkitTransform = `translate(${r}px,${i}px)`,
        s.transitionDuration = "0s",
        e
    }
}
function kb(e, t, n) {
    const r = e.cloneNode()
      , i = e[ul];
    i && i.forEach(l => {
        l.split(/\s+/).forEach(u => u && r.classList.remove(u))
    }
    ),
    n.split(/\s+/).forEach(l => l && r.classList.add(l)),
    r.style.display = "none";
    const s = t.nodeType === 1 ? t : t.parentNode;
    s.appendChild(r);
    const {hasTransform: o} = Dm(r);
    return s.removeChild(r),
    o
}
const sa = e => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return Qt(t) ? n => el(t, n) : t
}
;
function Ab(e) {
    e.target.composing = !0
}
function wp(e) {
    const t = e.target;
    t.composing && (t.composing = !1,
    t.dispatchEvent(new Event("input")))
}
const As = Symbol("_assign")
  , Ac = {
    created(e, {modifiers: {lazy: t, trim: n, number: r}}, i) {
        e[As] = sa(i);
        const s = r || i.props && i.props.type === "number";
        xo(e, t ? "change" : "input", o => {
            if (o.target.composing)
                return;
            let l = e.value;
            n && (l = l.trim()),
            s && (l = gc(l)),
            e[As](l)
        }
        ),
        n && xo(e, "change", () => {
            e.value = e.value.trim()
        }
        ),
        t || (xo(e, "compositionstart", Ab),
        xo(e, "compositionend", wp),
        xo(e, "change", wp))
    },
    mounted(e, {value: t}) {
        e.value = t ?? ""
    },
    beforeUpdate(e, {value: t, oldValue: n, modifiers: {lazy: r, trim: i, number: s}}, o) {
        if (e[As] = sa(o),
        e.composing)
            return;
        const l = (s || e.type === "number") && !/^0\d/.test(e.value) ? gc(e.value) : e.value
          , u = t ?? "";
        l !== u && (document.activeElement === e && e.type !== "range" && (r && t === n || i && e.value.trim() === u) || (e.value = u))
    }
}
  , mh = {
    deep: !0,
    created(e, t, n) {
        e[As] = sa(n),
        xo(e, "change", () => {
            const r = e._modelValue
              , i = cl(e)
              , s = e.checked
              , o = e[As];
            if (Qt(r)) {
                const l = Wc(r, i)
                  , u = l !== -1;
                if (s && !u)
                    o(r.concat(i));
                else if (!s && u) {
                    const p = [...r];
                    p.splice(l, 1),
                    o(p)
                }
            } else if (Fa(r)) {
                const l = new Set(r);
                s ? l.add(i) : l.delete(i),
                o(l)
            } else
                o(Om(e, s))
        }
        )
    },
    mounted: Dp,
    beforeUpdate(e, t, n) {
        e[As] = sa(n),
        Dp(e, t, n)
    }
};
function Dp(e, {value: t, oldValue: n}, r) {
    e._modelValue = t;
    let i;
    if (Qt(t))
        i = Wc(t, r.props.value) > -1;
    else if (Fa(t))
        i = t.has(r.props.value);
    else {
        if (t === n)
            return;
        i = ia(t, Om(e, !0))
    }
    e.checked !== i && (e.checked = i)
}
const yh = {
    created(e, {value: t}, n) {
        e.checked = ia(t, n.props.value),
        e[As] = sa(n),
        xo(e, "change", () => {
            e[As](cl(e))
        }
        )
    },
    beforeUpdate(e, {value: t, oldValue: n}, r) {
        e[As] = sa(r),
        t !== n && (e.checked = ia(t, r.props.value))
    }
}
  , Rm = {
    deep: !0,
    created(e, {value: t, modifiers: {number: n}}, r) {
        const i = Fa(t);
        xo(e, "change", () => {
            const s = Array.prototype.filter.call(e.options, o => o.selected).map(o => n ? gc(cl(o)) : cl(o));
            e[As](e.multiple ? i ? new Set(s) : s : s[0]),
            e._assigning = !0,
            Ci( () => {
                e._assigning = !1
            }
            )
        }
        ),
        e[As] = sa(r)
    },
    mounted(e, {value: t}) {
        Ep(e, t)
    },
    beforeUpdate(e, t, n) {
        e[As] = sa(n)
    },
    updated(e, {value: t}) {
        e._assigning || Ep(e, t)
    }
};
function Ep(e, t) {
    const n = e.multiple
      , r = Qt(t);
    if (!(n && !r && !Fa(t))) {
        for (let i = 0, s = e.options.length; i < s; i++) {
            const o = e.options[i]
              , l = cl(o);
            if (n)
                if (r) {
                    const u = typeof l;
                    u === "string" || u === "number" ? o.selected = t.some(p => String(p) === String(l)) : o.selected = Wc(t, l) > -1
                } else
                    o.selected = t.has(l);
            else if (ia(cl(o), t)) {
                e.selectedIndex !== i && (e.selectedIndex = i);
                return
            }
        }
        !n && e.selectedIndex !== -1 && (e.selectedIndex = -1)
    }
}
function cl(e) {
    return "_value"in e ? e._value : e.value
}
function Om(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t
}
const Mm = {
    created(e, t, n) {
        Qu(e, t, n, null, "created")
    },
    mounted(e, t, n) {
        Qu(e, t, n, null, "mounted")
    },
    beforeUpdate(e, t, n, r) {
        Qu(e, t, n, r, "beforeUpdate")
    },
    updated(e, t, n, r) {
        Qu(e, t, n, r, "updated")
    }
};
function Lm(e, t) {
    switch (e) {
    case "SELECT":
        return Rm;
    case "TEXTAREA":
        return Ac;
    default:
        switch (t) {
        case "checkbox":
            return mh;
        case "radio":
            return yh;
        default:
            return Ac
        }
    }
}
function Qu(e, t, n, r, i) {
    const o = Lm(e.tagName, n.props && n.props.type)[i];
    o && o(e, t, n, r)
}
function Rb() {
    Ac.getSSRProps = ({value: e}) => ({
        value: e
    }),
    yh.getSSRProps = ({value: e}, t) => {
        if (t.props && ia(t.props.value, e))
            return {
                checked: !0
            }
    }
    ,
    mh.getSSRProps = ({value: e}, t) => {
        if (Qt(e)) {
            if (t.props && Wc(e, t.props.value) > -1)
                return {
                    checked: !0
                }
        } else if (Fa(e)) {
            if (t.props && e.has(t.props.value))
                return {
                    checked: !0
                }
        } else if (e)
            return {
                checked: !0
            }
    }
    ,
    Mm.getSSRProps = (e, t) => {
        if (typeof t.type != "string")
            return;
        const n = Lm(t.type.toUpperCase(), t.props && t.props.type);
        if (n.getSSRProps)
            return n.getSSRProps(e, t)
    }
}
const Ob = ["ctrl", "shift", "alt", "meta"]
  , Mb = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => "button"in e && e.button !== 0,
    middle: e => "button"in e && e.button !== 1,
    right: e => "button"in e && e.button !== 2,
    exact: (e, t) => Ob.some(n => e[`${n}Key`] && !t.includes(n))
}
  , Lb = (e, t) => {
    const n = e._withMods || (e._withMods = {})
      , r = t.join(".");
    return n[r] || (n[r] = (i, ...s) => {
        for (let o = 0; o < t.length; o++) {
            const l = Mb[t[o]];
            if (l && l(i, t))
                return
        }
        return e(i, ...s)
    }
    )
}
  , Fb = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
}
  , Fm = (e, t) => {
    const n = e._withKeys || (e._withKeys = {})
      , r = t.join(".");
    return n[r] || (n[r] = i => {
        if (!("key"in i))
            return;
        const s = cs(i.key);
        if (t.some(o => o === s || Fb[o] === s))
            return e(i)
    }
    )
}
  , Im = vr({
    patchProp: mb
}, tb);
let nu, Cp = !1;
function Nm() {
    return nu || (nu = G_(Im))
}
function $m() {
    return nu = Cp ? nu : Y_(Im),
    Cp = !0,
    nu
}
const Bm = (...e) => {
    Nm().render(...e)
}
  , Ib = (...e) => {
    $m().hydrate(...e)
}
  , Rc = (...e) => {
    const t = Nm().createApp(...e)
      , {mount: n} = t;
    return t.mount = r => {
        const i = Vm(r);
        if (!i)
            return;
        const s = t._component;
        !dn(s) && !s.render && !s.template && (s.template = i.innerHTML),
        i.nodeType === 1 && (i.textContent = "");
        const o = n(i, !1, Hm(i));
        return i instanceof Element && (i.removeAttribute("v-cloak"),
        i.setAttribute("data-v-app", "")),
        o
    }
    ,
    t
}
  , vh = (...e) => {
    const t = $m().createApp(...e)
      , {mount: n} = t;
    return t.mount = r => {
        const i = Vm(r);
        if (i)
            return n(i, !0, Hm(i))
    }
    ,
    t
}
;
function Hm(e) {
    if (e instanceof SVGElement)
        return "svg";
    if (typeof MathMLElement == "function" && e instanceof MathMLElement)
        return "mathml"
}
function Vm(e) {
    return Sr(e) ? document.querySelector(e) : e
}
let xp = !1;
const Nb = () => {
    xp || (xp = !0,
    Rb(),
    ob())
}
;
/**
* vue v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const $b = () => {}
  , Bb = Object.freeze(Object.defineProperty({
    __proto__: null,
    BaseTransition: S_,
    BaseTransitionPropsValidators: nh,
    Comment: si,
    DeprecationTypes: J1,
    EffectScope: Kd,
    ErrorCodes: yv,
    ErrorTypeStrings: W1,
    Fragment: er,
    KeepAlive: P_,
    ReactiveEffect: au,
    Static: Pa,
    Suspense: sf,
    Teleport: D_,
    Text: na,
    TrackOpTypes: dv,
    Transition: bm,
    TransitionGroup: xb,
    TriggerOpTypes: hv,
    VueElement: of,
    assertNumber: mv,
    callWithAsyncErrorHandling: Rs,
    callWithErrorHandling: vl,
    camelize: Ei,
    capitalize: _l,
    cloneVNode: Us,
    compatUtils: Q1,
    compile: $b,
    computed: zt,
    createApp: Rc,
    createBlock: Wn,
    createCommentVNode: ii,
    createElementBlock: Cn,
    createElementVNode: kt,
    createHydrationRenderer: Y_,
    createPropsRestProxy: i1,
    createRenderer: G_,
    createSSRApp: vh,
    createSlots: Uv,
    createStaticVNode: gh,
    createTextVNode: To,
    createVNode: tn,
    customRef: Qc,
    defineAsyncComponent: Xt,
    defineComponent: Mn,
    defineCustomElement: Tm,
    defineEmits: Yv,
    defineExpose: Kv,
    defineModel: Jv,
    defineOptions: Xv,
    defineProps: Gv,
    defineSSRCustomElement: vb,
    defineSlots: Qv,
    devtools: q1,
    effect: $y,
    effectScope: Ss,
    getCurrentInstance: Or,
    getCurrentScope: Lo,
    getCurrentWatcher: h_,
    getTransitionRawChildren: Zc,
    guardReactiveProps: um,
    h: ar,
    handleError: Ia,
    hasInjectionContext: Na,
    hydrate: Ib,
    hydrateOnIdle: Lv,
    hydrateOnInteraction: $v,
    hydrateOnMediaQuery: Nv,
    hydrateOnVisible: Iv,
    initCustomFormatter: j1,
    initDirectivesForSSR: Nb,
    inject: pr,
    isMemoSame: gm,
    isProxy: Xc,
    isReactive: so,
    isReadonly: Ao,
    isRef: sr,
    isRuntimeOnly: B1,
    isShallow: ms,
    isVNode: Oo,
    markRaw: Eu,
    mergeDefaults: n1,
    mergeModels: r1,
    mergeProps: oo,
    nextTick: Ci,
    normalizeClass: ks,
    normalizeProps: My,
    normalizeStyle: ml,
    onActivated: ih,
    onBeforeMount: oh,
    onBeforeUnmount: Io,
    onBeforeUpdate: ah,
    onDeactivated: sh,
    onErrorCaptured: lh,
    onMounted: xi,
    onRenderTracked: O_,
    onRenderTriggered: R_,
    onScopeDispose: ds,
    onServerPrefetch: A_,
    onUnmounted: bl,
    onUpdated: tf,
    onWatcherCleanup: Aa,
    openBlock: It,
    popScopeId: Ev,
    provide: ns,
    proxyRefs: Zd,
    pushScopeId: Dv,
    queuePostFlushCb: cu,
    reactive: Gr,
    readonly: yl,
    ref: Ut,
    registerRuntimeCompiler: $1,
    render: Bm,
    renderList: So,
    renderSlot: ys,
    resolveComponent: wc,
    resolveDirective: zv,
    resolveDynamicComponent: nl,
    resolveFilter: X1,
    resolveTransitionHooks: al,
    setBlockTracking: ud,
    setDevtoolsHook: G1,
    setTransitionHooks: Ro,
    shallowReactive: Ts,
    shallowReadonly: Ca,
    shallowRef: qr,
    ssrContextKey: J_,
    ssrUtils: K1,
    stop: By,
    toDisplayString: Ji,
    toHandlerKey: Za,
    toHandlers: Wv,
    toRaw: Nn,
    toRef: ko,
    toRefs: ol,
    toValue: Qr,
    transformVNodeArgs: M1,
    triggerRef: sv,
    unref: Re,
    useAttrs: t1,
    useCssModule: Db,
    useCssVars: Sm,
    useHost: Pm,
    useId: Zl,
    useModel: w1,
    useSSRContext: Z_,
    useShadowRoot: wb,
    useSlots: e1,
    useTemplateRef: Un,
    useTransitionState: th,
    vModelCheckbox: mh,
    vModelDynamic: Mm,
    vModelRadio: yh,
    vModelSelect: Rm,
    vModelText: Ac,
    vShow: Cm,
    version: _m,
    warn: U1,
    watch: tr,
    watchEffect: fs,
    watchPostEffect: v1,
    watchSyncEffect: em,
    withAsyncContext: F_,
    withCtx: Tn,
    withDefaults: Zv,
    withDirectives: xv,
    withKeys: Fm,
    withMemo: z1,
    withModifiers: Lb,
    withScopeId: Cv
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Hb = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
  , Vb = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
  , jb = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function zb(e, t) {
    if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype"in t) {
        Ub(e);
        return
    }
    return t
}
function Ub(e) {
    console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`)
}
function Oc(e, t={}) {
    if (typeof e != "string")
        return e;
    if (e[0] === '"' && e[e.length - 1] === '"' && e.indexOf("\\") === -1)
        return e.slice(1, -1);
    const n = e.trim();
    if (n.length <= 9)
        switch (n.toLowerCase()) {
        case "true":
            return !0;
        case "false":
            return !1;
        case "undefined":
            return;
        case "null":
            return null;
        case "nan":
            return Number.NaN;
        case "infinity":
            return Number.POSITIVE_INFINITY;
        case "-infinity":
            return Number.NEGATIVE_INFINITY
        }
    if (!jb.test(e)) {
        if (t.strict)
            throw new SyntaxError("[destr] Invalid JSON");
        return e
    }
    try {
        if (Hb.test(e) || Vb.test(e)) {
            if (t.strict)
                throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(e, zb)
        }
        return JSON.parse(e)
    } catch (r) {
        if (t.strict)
            throw r;
        return e
    }
}
const Wb = /#/g
  , qb = /&/g
  , Gb = /\//g
  , Yb = /=/g
  , bh = /\+/g
  , Kb = /%5e/gi
  , Xb = /%60/gi
  , Qb = /%7c/gi
  , Jb = /%20/gi;
function Zb(e) {
    return encodeURI("" + e).replace(Qb, "|")
}
function yd(e) {
    return Zb(typeof e == "string" ? e : JSON.stringify(e)).replace(bh, "%2B").replace(Jb, "+").replace(Wb, "%23").replace(qb, "%26").replace(Xb, "`").replace(Kb, "^").replace(Gb, "%2F")
}
function Lf(e) {
    return yd(e).replace(Yb, "%3D")
}
function Mc(e="") {
    try {
        return decodeURIComponent("" + e)
    } catch {
        return "" + e
    }
}
function ew(e) {
    return Mc(e.replace(bh, " "))
}
function tw(e) {
    return Mc(e.replace(bh, " "))
}
function wh(e="") {
    const t = Object.create(null);
    e[0] === "?" && (e = e.slice(1));
    for (const n of e.split("&")) {
        const r = n.match(/([^=]+)=?(.*)/) || [];
        if (r.length < 2)
            continue;
        const i = ew(r[1]);
        if (i === "__proto__" || i === "constructor")
            continue;
        const s = tw(r[2] || "");
        t[i] === void 0 ? t[i] = s : Array.isArray(t[i]) ? t[i].push(s) : t[i] = [t[i], s]
    }
    return t
}
function nw(e, t) {
    return (typeof t == "number" || typeof t == "boolean") && (t = String(t)),
    t ? Array.isArray(t) ? t.map(n => `${Lf(e)}=${yd(n)}`).join("&") : `${Lf(e)}=${yd(t)}` : Lf(e)
}
function rw(e) {
    return Object.keys(e).filter(t => e[t] !== void 0).map(t => nw(t, e[t])).filter(Boolean).join("&")
}
const iw = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/
  , jm = /^[\s\w\0+.-]{2,}:([/\\]{2})?/
  , sw = /^([/\\]\s*){2,}[^/\\]/
  , ow = /^[\s\0]*(blob|data|javascript|vbscript):$/i
  , aw = /\/$|\/\?|\/#/
  , lw = /^\.?\//;
function ao(e, t={}) {
    return typeof t == "boolean" && (t = {
        acceptRelative: t
    }),
    t.strict ? iw.test(e) : jm.test(e) || (t.acceptRelative ? sw.test(e) : !1)
}
function uw(e) {
    return !!e && ow.test(e)
}
function vd(e="", t) {
    return t ? aw.test(e) : e.endsWith("/")
}
function fl(e="", t) {
    if (!t)
        return (vd(e) ? e.slice(0, -1) : e) || "/";
    if (!vd(e, !0))
        return e || "/";
    let n = e
      , r = "";
    const i = e.indexOf("#");
    i !== -1 && (n = e.slice(0, i),
    r = e.slice(i));
    const [s,...o] = n.split("?");
    return ((s.endsWith("/") ? s.slice(0, -1) : s) || "/") + (o.length > 0 ? `?${o.join("?")}` : "") + r
}
function zm(e="", t) {
    if (!t)
        return e.endsWith("/") ? e : e + "/";
    if (vd(e, !0))
        return e || "/";
    let n = e
      , r = "";
    const i = e.indexOf("#");
    if (i !== -1 && (n = e.slice(0, i),
    r = e.slice(i),
    !n))
        return r;
    const [s,...o] = n.split("?");
    return s + "/" + (o.length > 0 ? `?${o.join("?")}` : "") + r
}
function cw(e="") {
    return e.startsWith("/")
}
function xA(e="") {
    return cw(e) ? e : "/" + e
}
function fw(e, t) {
    if (Um(t) || ao(e))
        return e;
    const n = fl(t);
    return e.startsWith(n) ? e : af(n, e)
}
function Sp(e, t) {
    if (Um(t))
        return e;
    const n = fl(t);
    if (!e.startsWith(n))
        return e;
    const r = e.slice(n.length);
    return r[0] === "/" ? r : "/" + r
}
function _u(e, t) {
    const n = Gm(e)
      , r = {
        ...wh(n.search),
        ...t
    };
    return n.search = rw(r),
    _w(n)
}
function Um(e) {
    return !e || e === "/"
}
function dw(e) {
    return e && e !== "/"
}
function af(e, ...t) {
    let n = e || "";
    for (const r of t.filter(i => dw(i)))
        if (n) {
            const i = r.replace(lw, "");
            n = zm(n) + i
        } else
            n = r;
    return n
}
function Wm(...e) {
    var o, l, u, p;
    const t = /\/(?!\/)/
      , n = e.filter(Boolean)
      , r = [];
    let i = 0;
    for (const h of n)
        if (!(!h || h === "/")) {
            for (const [g,m] of h.split(t).entries())
                if (!(!m || m === ".")) {
                    if (m === "..") {
                        if (r.length === 1 && ao(r[0]))
                            continue;
                        r.pop(),
                        i--;
                        continue
                    }
                    if (g === 1 && ((o = r[r.length - 1]) != null && o.endsWith(":/"))) {
                        r[r.length - 1] += "/" + m;
                        continue
                    }
                    r.push(m),
                    i++
                }
        }
    let s = r.join("/");
    return i >= 0 ? (l = n[0]) != null && l.startsWith("/") && !s.startsWith("/") ? s = "/" + s : (u = n[0]) != null && u.startsWith("./") && !s.startsWith("./") && (s = "./" + s) : s = "../".repeat(-1 * i) + s,
    (p = n[n.length - 1]) != null && p.endsWith("/") && !s.endsWith("/") && (s += "/"),
    s
}
function hw(e) {
    return pw(e, "https://")
}
function pw(e, t) {
    let n = e.match(jm);
    return n || (n = e.match(/^\/{2,}/)),
    n ? t + e.slice(n[0].length) : t + e
}
function gw(e, t) {
    return Mc(fl(e)) === Mc(fl(t))
}
const qm = Symbol.for("ufo:protocolRelative");
function Gm(e="", t) {
    const n = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
    if (n) {
        const [,g,m=""] = n;
        return {
            protocol: g.toLowerCase(),
            pathname: m,
            href: g + m,
            auth: "",
            host: "",
            search: "",
            hash: ""
        }
    }
    if (!ao(e, {
        acceptRelative: !0
    }))
        return Tp(e);
    const [,r="",i,s=""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
    let[,o="",l=""] = s.match(/([^#/?]*)(.*)?/) || [];
    r === "file:" && (l = l.replace(/\/(?=[A-Za-z]:)/, ""));
    const {pathname: u, search: p, hash: h} = Tp(l);
    return {
        protocol: r.toLowerCase(),
        auth: i ? i.slice(0, Math.max(0, i.length - 1)) : "",
        host: o,
        pathname: u,
        search: p,
        hash: h,
        [qm]: !r
    }
}
function Tp(e="") {
    const [t="",n="",r=""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
    return {
        pathname: t,
        search: n,
        hash: r
    }
}
function _w(e) {
    const t = e.pathname || ""
      , n = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : ""
      , r = e.hash || ""
      , i = e.auth ? e.auth + "@" : ""
      , s = e.host || "";
    return (e.protocol || e[qm] ? (e.protocol || "") + "//" : "") + i + s + t + n + r
}
class mw extends Error {
    constructor(t, n) {
        super(t, n),
        this.name = "FetchError",
        n != null && n.cause && !this.cause && (this.cause = n.cause)
    }
}
function yw(e) {
    var u, p, h, g, m;
    const t = ((u = e.error) == null ? void 0 : u.message) || ((p = e.error) == null ? void 0 : p.toString()) || ""
      , n = ((h = e.request) == null ? void 0 : h.method) || ((g = e.options) == null ? void 0 : g.method) || "GET"
      , r = ((m = e.request) == null ? void 0 : m.url) || String(e.request) || "/"
      , i = `[${n}] ${JSON.stringify(r)}`
      , s = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>"
      , o = `${i}: ${s}${t ? ` ${t}` : ""}`
      , l = new mw(o,e.error ? {
        cause: e.error
    } : void 0);
    for (const w of ["request", "options", "response"])
        Object.defineProperty(l, w, {
            get() {
                return e[w]
            }
        });
    for (const [w,E] of [["data", "_data"], ["status", "status"], ["statusCode", "status"], ["statusText", "statusText"], ["statusMessage", "statusText"]])
        Object.defineProperty(l, w, {
            get() {
                return e.response && e.response[E]
            }
        });
    return l
}
const vw = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));
function Pp(e="GET") {
    return vw.has(e.toUpperCase())
}
function bw(e) {
    if (e === void 0)
        return !1;
    const t = typeof e;
    return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function"
}
const ww = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"])
  , Dw = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function Ew(e="") {
    if (!e)
        return "json";
    const t = e.split(";").shift() || "";
    return Dw.test(t) ? "json" : ww.has(t) || t.startsWith("text/") ? "text" : "blob"
}
function Cw(e, t, n, r) {
    const i = xw((t == null ? void 0 : t.headers) ?? (e == null ? void 0 : e.headers), n == null ? void 0 : n.headers, r);
    let s;
    return (n != null && n.query || n != null && n.params || t != null && t.params || t != null && t.query) && (s = {
        ...n == null ? void 0 : n.params,
        ...n == null ? void 0 : n.query,
        ...t == null ? void 0 : t.params,
        ...t == null ? void 0 : t.query
    }),
    {
        ...n,
        ...t,
        query: s,
        params: s,
        headers: i
    }
}
function xw(e, t, n) {
    if (!t)
        return new n(e);
    const r = new n(t);
    if (e)
        for (const [i,s] of Symbol.iterator in e || Array.isArray(e) ? e : new n(e))
            r.set(i, s);
    return r
}
async function Ju(e, t) {
    if (t)
        if (Array.isArray(t))
            for (const n of t)
                await n(e);
        else
            await t(e)
}
const Sw = new Set([408, 409, 425, 429, 500, 502, 503, 504])
  , Tw = new Set([101, 204, 205, 304]);
function Ym(e={}) {
    const {fetch: t=globalThis.fetch, Headers: n=globalThis.Headers, AbortController: r=globalThis.AbortController} = e;
    async function i(l) {
        const u = l.error && l.error.name === "AbortError" && !l.options.timeout || !1;
        if (l.options.retry !== !1 && !u) {
            let h;
            typeof l.options.retry == "number" ? h = l.options.retry : h = Pp(l.options.method) ? 0 : 1;
            const g = l.response && l.response.status || 500;
            if (h > 0 && (Array.isArray(l.options.retryStatusCodes) ? l.options.retryStatusCodes.includes(g) : Sw.has(g))) {
                const m = typeof l.options.retryDelay == "function" ? l.options.retryDelay(l) : l.options.retryDelay || 0;
                return m > 0 && await new Promise(w => setTimeout(w, m)),
                s(l.request, {
                    ...l.options,
                    retry: h - 1
                })
            }
        }
        const p = yw(l);
        throw Error.captureStackTrace && Error.captureStackTrace(p, s),
        p
    }
    const s = async function(u, p={}) {
        const h = {
            request: u,
            options: Cw(u, p, e.defaults, n),
            response: void 0,
            error: void 0
        };
        h.options.method && (h.options.method = h.options.method.toUpperCase()),
        h.options.onRequest && await Ju(h, h.options.onRequest),
        typeof h.request == "string" && (h.options.baseURL && (h.request = fw(h.request, h.options.baseURL)),
        h.options.query && (h.request = _u(h.request, h.options.query),
        delete h.options.query),
        "query"in h.options && delete h.options.query,
        "params"in h.options && delete h.options.params),
        h.options.body && Pp(h.options.method) && (bw(h.options.body) ? (h.options.body = typeof h.options.body == "string" ? h.options.body : JSON.stringify(h.options.body),
        h.options.headers = new n(h.options.headers || {}),
        h.options.headers.has("content-type") || h.options.headers.set("content-type", "application/json"),
        h.options.headers.has("accept") || h.options.headers.set("accept", "application/json")) : ("pipeTo"in h.options.body && typeof h.options.body.pipeTo == "function" || typeof h.options.body.pipe == "function") && ("duplex"in h.options || (h.options.duplex = "half")));
        let g;
        if (!h.options.signal && h.options.timeout) {
            const w = new r;
            g = setTimeout( () => {
                const E = new Error("[TimeoutError]: The operation was aborted due to timeout");
                E.name = "TimeoutError",
                E.code = 23,
                w.abort(E)
            }
            , h.options.timeout),
            h.options.signal = w.signal
        }
        try {
            h.response = await t(h.request, h.options)
        } catch (w) {
            return h.error = w,
            h.options.onRequestError && await Ju(h, h.options.onRequestError),
            await i(h)
        } finally {
            g && clearTimeout(g)
        }
        if ((h.response.body || h.response._bodyInit) && !Tw.has(h.response.status) && h.options.method !== "HEAD") {
            const w = (h.options.parseResponse ? "json" : h.options.responseType) || Ew(h.response.headers.get("content-type") || "");
            switch (w) {
            case "json":
                {
                    const E = await h.response.text()
                      , y = h.options.parseResponse || Oc;
                    h.response._data = y(E);
                    break
                }
            case "stream":
                {
                    h.response._data = h.response.body || h.response._bodyInit;
                    break
                }
            default:
                h.response._data = await h.response[w]()
            }
        }
        return h.options.onResponse && await Ju(h, h.options.onResponse),
        !h.options.ignoreResponseError && h.response.status >= 400 && h.response.status < 600 ? (h.options.onResponseError && await Ju(h, h.options.onResponseError),
        await i(h)) : h.response
    }
      , o = async function(u, p) {
        return (await s(u, p))._data
    };
    return o.raw = s,
    o.native = (...l) => t(...l),
    o.create = (l={}, u={}) => Ym({
        ...e,
        ...u,
        defaults: {
            ...e.defaults,
            ...u.defaults,
            ...l
        }
    }),
    o
}
const Lc = function() {
    if (typeof globalThis < "u")
        return globalThis;
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof global < "u")
        return global;
    throw new Error("unable to locate global object")
}()
  , Pw = Lc.fetch ? (...e) => Lc.fetch(...e) : () => Promise.reject(new Error("[ofetch] global.fetch is not supported!"))
  , kw = Lc.Headers
  , Aw = Lc.AbortController
  , Rw = Ym({
    fetch: Pw,
    Headers: kw,
    AbortController: Aw
})
  , Ow = Rw
  , Mw = () => {
    var e;
    return ((e = window == null ? void 0 : window.__NUXT__) == null ? void 0 : e.config) || {}
}
  , Fc = Mw().app
  , Lw = () => Fc.baseURL
  , Fw = () => Fc.buildAssetsDir
  , Dh = (...e) => Wm(Km(), Fw(), ...e)
  , Km = (...e) => {
    const t = Fc.cdnURL || Fc.baseURL;
    return e.length ? Wm(t, ...e) : t
}
;
globalThis.__buildAssetsURL = Dh,
globalThis.__publicAssetsURL = Km;
globalThis.$fetch || (globalThis.$fetch = Ow.create({
    baseURL: Lw()
}));
function bd(e, t={}, n) {
    for (const r in e) {
        const i = e[r]
          , s = n ? `${n}:${r}` : r;
        typeof i == "object" && i !== null ? bd(i, t, s) : typeof i == "function" && (t[s] = i)
    }
    return t
}
const Iw = {
    run: e => e()
}
  , Nw = () => Iw
  , Xm = typeof console.createTask < "u" ? console.createTask : Nw;
function $w(e, t) {
    const n = t.shift()
      , r = Xm(n);
    return e.reduce( (i, s) => i.then( () => r.run( () => s(...t))), Promise.resolve())
}
function Bw(e, t) {
    const n = t.shift()
      , r = Xm(n);
    return Promise.all(e.map(i => r.run( () => i(...t))))
}
function Ff(e, t) {
    for (const n of [...e])
        n(t)
}
class Hw {
    constructor() {
        this._hooks = {},
        this._before = void 0,
        this._after = void 0,
        this._deprecatedMessages = void 0,
        this._deprecatedHooks = {},
        this.hook = this.hook.bind(this),
        this.callHook = this.callHook.bind(this),
        this.callHookWith = this.callHookWith.bind(this)
    }
    hook(t, n, r={}) {
        if (!t || typeof n != "function")
            return () => {}
            ;
        const i = t;
        let s;
        for (; this._deprecatedHooks[t]; )
            s = this._deprecatedHooks[t],
            t = s.to;
        if (s && !r.allowDeprecated) {
            let o = s.message;
            o || (o = `${i} hook has been deprecated` + (s.to ? `, please use ${s.to}` : "")),
            this._deprecatedMessages || (this._deprecatedMessages = new Set),
            this._deprecatedMessages.has(o) || (console.warn(o),
            this._deprecatedMessages.add(o))
        }
        if (!n.name)
            try {
                Object.defineProperty(n, "name", {
                    get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb",
                    configurable: !0
                })
            } catch {}
        return this._hooks[t] = this._hooks[t] || [],
        this._hooks[t].push(n),
        () => {
            n && (this.removeHook(t, n),
            n = void 0)
        }
    }
    hookOnce(t, n) {
        let r, i = (...s) => (typeof r == "function" && r(),
        r = void 0,
        i = void 0,
        n(...s));
        return r = this.hook(t, i),
        r
    }
    removeHook(t, n) {
        if (this._hooks[t]) {
            const r = this._hooks[t].indexOf(n);
            r !== -1 && this._hooks[t].splice(r, 1),
            this._hooks[t].length === 0 && delete this._hooks[t]
        }
    }
    deprecateHook(t, n) {
        this._deprecatedHooks[t] = typeof n == "string" ? {
            to: n
        } : n;
        const r = this._hooks[t] || [];
        delete this._hooks[t];
        for (const i of r)
            this.hook(t, i)
    }
    deprecateHooks(t) {
        Object.assign(this._deprecatedHooks, t);
        for (const n in t)
            this.deprecateHook(n, t[n])
    }
    addHooks(t) {
        const n = bd(t)
          , r = Object.keys(n).map(i => this.hook(i, n[i]));
        return () => {
            for (const i of r.splice(0, r.length))
                i()
        }
    }
    removeHooks(t) {
        const n = bd(t);
        for (const r in n)
            this.removeHook(r, n[r])
    }
    removeAllHooks() {
        for (const t in this._hooks)
            delete this._hooks[t]
    }
    callHook(t, ...n) {
        return n.unshift(t),
        this.callHookWith($w, t, ...n)
    }
    callHookParallel(t, ...n) {
        return n.unshift(t),
        this.callHookWith(Bw, t, ...n)
    }
    callHookWith(t, n, ...r) {
        const i = this._before || this._after ? {
            name: n,
            args: r,
            context: {}
        } : void 0;
        this._before && Ff(this._before, i);
        const s = t(n in this._hooks ? [...this._hooks[n]] : [], r);
        return s instanceof Promise ? s.finally( () => {
            this._after && i && Ff(this._after, i)
        }
        ) : (this._after && i && Ff(this._after, i),
        s)
    }
    beforeEach(t) {
        return this._before = this._before || [],
        this._before.push(t),
        () => {
            if (this._before !== void 0) {
                const n = this._before.indexOf(t);
                n !== -1 && this._before.splice(n, 1)
            }
        }
    }
    afterEach(t) {
        return this._after = this._after || [],
        this._after.push(t),
        () => {
            if (this._after !== void 0) {
                const n = this._after.indexOf(t);
                n !== -1 && this._after.splice(n, 1)
            }
        }
    }
}
function Qm() {
    return new Hw
}
function Vw(e={}) {
    let t, n = !1;
    const r = o => {
        if (t && t !== o)
            throw new Error("Context conflict")
    }
    ;
    let i;
    if (e.asyncContext) {
        const o = e.AsyncLocalStorage || globalThis.AsyncLocalStorage;
        o ? i = new o : console.warn("[unctx] `AsyncLocalStorage` is not provided.")
    }
    const s = () => {
        if (i) {
            const o = i.getStore();
            if (o !== void 0)
                return o
        }
        return t
    }
    ;
    return {
        use: () => {
            const o = s();
            if (o === void 0)
                throw new Error("Context is not available");
            return o
        }
        ,
        tryUse: () => s(),
        set: (o, l) => {
            l || r(o),
            t = o,
            n = !0
        }
        ,
        unset: () => {
            t = void 0,
            n = !1
        }
        ,
        call: (o, l) => {
            r(o),
            t = o;
            try {
                return i ? i.run(o, l) : l()
            } finally {
                n || (t = void 0)
            }
        }
        ,
        async callAsync(o, l) {
            t = o;
            const u = () => {
                t = o
            }
              , p = () => t === o ? u : void 0;
            wd.add(p);
            try {
                const h = i ? i.run(o, l) : l();
                return n || (t = void 0),
                await h
            } finally {
                wd.delete(p)
            }
        }
    }
}
function jw(e={}) {
    const t = {};
    return {
        get(n, r={}) {
            return t[n] || (t[n] = Vw({
                ...e,
                ...r
            })),
            t[n]
        }
    }
}
const Ic = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {}
  , kp = "__unctx__"
  , zw = Ic[kp] || (Ic[kp] = jw())
  , Uw = (e, t={}) => zw.get(e, t)
  , Ap = "__unctx_async_handlers__"
  , wd = Ic[Ap] || (Ic[Ap] = new Set);
function il(e) {
    const t = [];
    for (const i of wd) {
        const s = i();
        s && t.push(s)
    }
    const n = () => {
        for (const i of t)
            i()
    }
    ;
    let r = e();
    return r && typeof r == "object" && "catch"in r && (r = r.catch(i => {
        throw n(),
        i
    }
    )),
    [r, n]
}
const Ww = !1
  , Rp = !1
  , qw = !1
  , Gw = {
    componentName: "NuxtLink",
    prefetch: !0,
    prefetchOn: {
        visibility: !0
    }
}
  , io = {
    value: null,
    errorValue: null,
    deep: !0
}
  , Yw = null
  , Kw = "#__nuxt"
  , Jm = "nuxt-app"
  , Op = 36e5
  , Xw = "vite:preloadError";
function Zm(e=Jm) {
    return Uw(e, {
        asyncContext: !1
    })
}
const Qw = "__nuxt_plugin";
function Jw(e) {
    var i;
    let t = 0;
    const n = {
        _id: e.id || Jm || "nuxt-app",
        _scope: Ss(),
        provide: void 0,
        globalName: "nuxt",
        versions: {
            get nuxt() {
                return "3.17.2"
            },
            get vue() {
                return n.vueApp.version
            }
        },
        payload: Ts({
            ...((i = e.ssrContext) == null ? void 0 : i.payload) || {},
            data: Ts({}),
            state: Gr({}),
            once: new Set,
            _errors: Ts({})
        }),
        static: {
            data: {}
        },
        runWithContext(s) {
            return n._scope.active && !Lo() ? n._scope.run( () => Mp(n, s)) : Mp(n, s)
        },
        isHydrating: !0,
        deferHydration() {
            if (!n.isHydrating)
                return () => {}
                ;
            t++;
            let s = !1;
            return () => {
                if (!s && (s = !0,
                t--,
                t === 0))
                    return n.isHydrating = !1,
                    n.callHook("app:suspense:resolve")
            }
        },
        _asyncDataPromises: {},
        _asyncData: Ts({}),
        _payloadRevivers: {},
        ...e
    };
    {
        const s = window.__NUXT__;
        if (s)
            for (const o in s)
                switch (o) {
                case "data":
                case "state":
                case "_errors":
                    Object.assign(n.payload[o], s[o]);
                    break;
                default:
                    n.payload[o] = s[o]
                }
    }
    n.hooks = Qm(),
    n.hook = n.hooks.hook,
    n.callHook = n.hooks.callHook,
    n.provide = (s, o) => {
        const l = "$" + s;
        Zu(n, l, o),
        Zu(n.vueApp.config.globalProperties, l, o)
    }
    ,
    Zu(n.vueApp, "$nuxt", n),
    Zu(n.vueApp.config.globalProperties, "$nuxt", n);
    {
        window.addEventListener(Xw, o => {
            n.callHook("app:chunkError", {
                error: o.payload
            }),
            (n.isHydrating || o.payload.message.includes("Unable to preload CSS")) && o.preventDefault()
        }
        ),
        window.useNuxtApp || (window.useNuxtApp = Tr);
        const s = n.hook("app:error", (...o) => {
            console.error("[nuxt] error caught during app initialization", ...o)
        }
        );
        n.hook("app:mounted", s)
    }
    const r = n.payload.config;
    return n.provide("config", r),
    n
}
function Zw(e, t) {
    t.hooks && e.hooks.addHooks(t.hooks)
}
async function eD(e, t) {
    if (typeof t == "function") {
        const {provide: n} = await e.runWithContext( () => t(e)) || {};
        if (n && typeof n == "object")
            for (const r in n)
                e.provide(r, n[r])
    }
}
async function tD(e, t) {
    const n = []
      , r = []
      , i = []
      , s = [];
    let o = 0;
    async function l(u) {
        var h;
        const p = ((h = u.dependsOn) == null ? void 0 : h.filter(g => t.some(m => m._name === g) && !n.includes(g))) ?? [];
        if (p.length > 0)
            r.push([new Set(p), u]);
        else {
            const g = eD(e, u).then(async () => {
                u._name && (n.push(u._name),
                await Promise.all(r.map(async ([m,w]) => {
                    m.has(u._name) && (m.delete(u._name),
                    m.size === 0 && (o++,
                    await l(w)))
                }
                )))
            }
            );
            u.parallel ? i.push(g.catch(m => s.push(m))) : await g
        }
    }
    for (const u of t)
        Zw(e, u);
    for (const u of t)
        await l(u);
    if (await Promise.all(i),
    o)
        for (let u = 0; u < o; u++)
            await Promise.all(i);
    if (s.length)
        throw s[0]
}
function ki(e) {
    if (typeof e == "function")
        return e;
    const t = e._name || e.name;
    return delete e.name,
    Object.assign(e.setup || ( () => {}
    ), e, {
        [Qw]: !0,
        _name: t
    })
}
const nD = ki;
function Mp(e, t, n) {
    const r = () => t();
    return Zm(e._id).set(e),
    e.vueApp.runWithContext(r)
}
function e0(e) {
    var n;
    let t;
    return Na() && (t = (n = Or()) == null ? void 0 : n.appContext.app.$nuxt),
    t || (t = Zm(e).tryUse()),
    t || null
}
function Tr(e) {
    const t = e0(e);
    if (!t)
        throw new Error("[nuxt] instance unavailable");
    return t
}
function qs(e) {
    return Tr().$config
}
function Zu(e, t, n) {
    Object.defineProperty(e, t, {
        get: () => n
    })
}
function rD(e, t) {
    return {
        ctx: {
            table: e
        },
        matchAll: n => n0(n, e)
    }
}
function t0(e) {
    const t = {};
    for (const n in e)
        t[n] = n === "dynamic" ? new Map(Object.entries(e[n]).map( ([r,i]) => [r, t0(i)])) : new Map(Object.entries(e[n]));
    return t
}
function iD(e) {
    return rD(t0(e))
}
function n0(e, t, n) {
    e.endsWith("/") && (e = e.slice(0, -1) || "/");
    const r = [];
    for (const [s,o] of Lp(t.wildcard))
        (e === s || e.startsWith(s + "/")) && r.push(o);
    for (const [s,o] of Lp(t.dynamic))
        if (e.startsWith(s + "/")) {
            const l = "/" + e.slice(s.length).split("/").splice(2).join("/");
            r.push(...n0(l, o))
        }
    const i = t.static.get(e);
    return i && r.push(i),
    r.filter(Boolean)
}
function Lp(e) {
    return [...e.entries()].sort( (t, n) => t[0].length - n[0].length)
}
function If(e) {
    if (e === null || typeof e != "object")
        return !1;
    const t = Object.getPrototypeOf(e);
    return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0
}
function Dd(e, t, n=".", r) {
    if (!If(t))
        return Dd(e, {}, n, r);
    const i = Object.assign({}, t);
    for (const s in e) {
        if (s === "__proto__" || s === "constructor")
            continue;
        const o = e[s];
        o != null && (r && r(i, s, o, n) || (Array.isArray(o) && Array.isArray(i[s]) ? i[s] = [...o, ...i[s]] : If(o) && If(i[s]) ? i[s] = Dd(o, i[s], (n ? `${n}.` : "") + s.toString(), r) : i[s] = o))
    }
    return i
}
function sD(e) {
    return (...t) => t.reduce( (n, r) => Dd(n, r, "", e), {})
}
const lf = sD();
function oD(e, t) {
    try {
        return t in e
    } catch {
        return !1
    }
}
class Ed extends Error {
    constructor(n, r={}) {
        super(n, r);
        St(this, "statusCode", 500);
        St(this, "fatal", !1);
        St(this, "unhandled", !1);
        St(this, "statusMessage");
        St(this, "data");
        St(this, "cause");
        r.cause && !this.cause && (this.cause = r.cause)
    }
    toJSON() {
        const n = {
            message: this.message,
            statusCode: Cd(this.statusCode, 500)
        };
        return this.statusMessage && (n.statusMessage = r0(this.statusMessage)),
        this.data !== void 0 && (n.data = this.data),
        n
    }
}
St(Ed, "__h3_error__", !0);
function aD(e) {
    if (typeof e == "string")
        return new Ed(e);
    if (lD(e))
        return e;
    const t = new Ed(e.message ?? e.statusMessage ?? "",{
        cause: e.cause || e
    });
    if (oD(e, "stack"))
        try {
            Object.defineProperty(t, "stack", {
                get() {
                    return e.stack
                }
            })
        } catch {
            try {
                t.stack = e.stack
            } catch {}
        }
    if (e.data && (t.data = e.data),
    e.statusCode ? t.statusCode = Cd(e.statusCode, t.statusCode) : e.status && (t.statusCode = Cd(e.status, t.statusCode)),
    e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText),
    t.statusMessage) {
        const n = t.statusMessage;
        r0(t.statusMessage) !== n && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.")
    }
    return e.fatal !== void 0 && (t.fatal = e.fatal),
    e.unhandled !== void 0 && (t.unhandled = e.unhandled),
    t
}
function lD(e) {
    var t;
    return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.__h3_error__) === !0
}
const uD = /[^\u0009\u0020-\u007E]/g;
function r0(e="") {
    return e.replace(uD, "")
}
function Cd(e, t=200) {
    return !e || (typeof e == "string" && (e = Number.parseInt(e, 10)),
    e < 100 || e > 999) ? t : e
}
const i0 = Symbol("layout-meta")
  , Tu = Symbol("route")
  , rs = () => {
    var e;
    return (e = Tr()) == null ? void 0 : e.$router
}
  , Pu = () => Na() ? pr(Tu, Tr()._route) : Tr()._route;
const cD = () => {
    try {
        if (Tr()._processingMiddleware)
            return !0
    } catch {
        return !1
    }
    return !1
}
  , fD = (e, t) => {
    e || (e = "/");
    const n = typeof e == "string" ? e : "path"in e ? xd(e) : rs().resolve(e).href;
    if (t != null && t.open) {
        const {target: u="_blank", windowFeatures: p={}} = t.open
          , h = Object.entries(p).filter( ([g,m]) => m !== void 0).map( ([g,m]) => `${g.toLowerCase()}=${m}`).join(", ");
        return open(n, u, h),
        Promise.resolve()
    }
    const r = ao(n, {
        acceptRelative: !0
    })
      , i = (t == null ? void 0 : t.external) || r;
    if (i) {
        if (!(t != null && t.external))
            throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
        const {protocol: u} = new URL(n,window.location.href);
        if (u && uw(u))
            throw new Error(`Cannot navigate to a URL with '${u}' protocol.`)
    }
    const s = cD();
    if (!i && s) {
        if (t != null && t.replace) {
            if (typeof e == "string") {
                const {pathname: u, search: p, hash: h} = Gm(e);
                return {
                    path: u,
                    ...p && {
                        query: wh(p)
                    },
                    ...h && {
                        hash: h
                    },
                    replace: !0
                }
            }
            return {
                ...e,
                replace: !0
            }
        }
        return e
    }
    const o = rs()
      , l = Tr();
    return i ? (l._scope.stop(),
    t != null && t.replace ? location.replace(n) : location.href = n,
    s ? l.isHydrating ? new Promise( () => {}
    ) : !1 : Promise.resolve()) : t != null && t.replace ? o.replace(e) : o.push(e)
}
;
function xd(e) {
    return _u(e.path || "", e.query || {}) + (e.hash || "")
}
const s0 = "__nuxt_error"
  , uf = () => ko(Tr().payload, "error")
  , xa = e => {
    const t = ra(e);
    try {
        const n = Tr()
          , r = uf();
        n.hooks.callHook("app:error", t),
        r.value || (r.value = t)
    } catch {
        throw t
    }
    return t
}
  , dD = async (e={}) => {
    const t = Tr()
      , n = uf();
    t.callHook("app:error:cleared", e),
    e.redirect && await rs().replace(e.redirect),
    n.value = Yw
}
  , o0 = e => !!e && typeof e == "object" && s0 in e
  , ra = e => {
    const t = aD(e);
    return Object.defineProperty(t, s0, {
        value: !0,
        configurable: !1,
        writable: !1
    }),
    t
}
  , hD = {
    trailing: !0
};
function pD(e, t=25, n={}) {
    if (n = {
        ...hD,
        ...n
    },
    !Number.isFinite(t))
        throw new TypeError("Expected `wait` to be a finite number");
    let r, i, s = [], o, l;
    const u = (p, h) => (o = gD(e, p, h),
    o.finally( () => {
        if (o = null,
        n.trailing && l && !i) {
            const g = u(p, l);
            return l = null,
            g
        }
    }
    ),
    o);
    return function(...p) {
        return o ? (n.trailing && (l = p),
        o) : new Promise(h => {
            const g = !i && n.leading;
            clearTimeout(i),
            i = setTimeout( () => {
                i = null;
                const m = n.leading ? r : u(this, p);
                for (const w of s)
                    w(m);
                s = []
            }
            , t),
            g ? (r = u(this, p),
            h(r)) : s.push(h)
        }
        )
    }
}
async function gD(e, t, n) {
    return await e.apply(t, n)
}
/*!
 * pinia v3.0.2
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let a0;
const ku = e => a0 = e
  , l0 = Symbol();
function Sd(e) {
    return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function"
}
var ru;
(function(e) {
    e.direct = "direct",
    e.patchObject = "patch object",
    e.patchFunction = "patch function"
}
)(ru || (ru = {}));
function _D() {
    const e = Ss(!0)
      , t = e.run( () => Ut({}));
    let n = []
      , r = [];
    const i = Eu({
        install(s) {
            ku(i),
            i._a = s,
            s.provide(l0, i),
            s.config.globalProperties.$pinia = i,
            r.forEach(o => n.push(o)),
            r = []
        },
        use(s) {
            return this._a ? n.push(s) : r.push(s),
            this
        },
        _p: n,
        _a: null,
        _e: e,
        _s: new Map,
        state: t
    });
    return i
}
const u0 = () => {}
;
function Fp(e, t, n, r=u0) {
    e.push(t);
    const i = () => {
        const s = e.indexOf(t);
        s > -1 && (e.splice(s, 1),
        r())
    }
    ;
    return !n && Lo() && ds(i),
    i
}
function Ua(e, ...t) {
    e.slice().forEach(n => {
        n(...t)
    }
    )
}
const mD = e => e()
  , Ip = Symbol()
  , Nf = Symbol();
function Td(e, t) {
    e instanceof Map && t instanceof Map ? t.forEach( (n, r) => e.set(r, n)) : e instanceof Set && t instanceof Set && t.forEach(e.add, e);
    for (const n in t) {
        if (!t.hasOwnProperty(n))
            continue;
        const r = t[n]
          , i = e[n];
        Sd(i) && Sd(r) && e.hasOwnProperty(n) && !sr(r) && !so(r) ? e[n] = Td(i, r) : e[n] = r
    }
    return e
}
const yD = Symbol();
function vD(e) {
    return !Sd(e) || !Object.prototype.hasOwnProperty.call(e, yD)
}
const {assign: Go} = Object;
function bD(e) {
    return !!(sr(e) && e.effect)
}
function wD(e, t, n, r) {
    const {state: i, actions: s, getters: o} = t
      , l = n.state.value[e];
    let u;
    function p() {
        l || (n.state.value[e] = i ? i() : {});
        const h = ol(n.state.value[e]);
        return Go(h, s, Object.keys(o || {}).reduce( (g, m) => (g[m] = Eu(zt( () => {
            ku(n);
            const w = n._s.get(e);
            return o[m].call(w, w)
        }
        )),
        g), {}))
    }
    return u = c0(e, p, t, n, r, !0),
    u
}
function c0(e, t, n={}, r, i, s) {
    let o;
    const l = Go({
        actions: {}
    }, n)
      , u = {
        deep: !0
    };
    let p, h, g = [], m = [], w;
    const E = r.state.value[e];
    !s && !E && (r.state.value[e] = {}),
    Ut({});
    let y;
    function R(be) {
        let fe;
        p = h = !1,
        typeof be == "function" ? (be(r.state.value[e]),
        fe = {
            type: ru.patchFunction,
            storeId: e,
            events: w
        }) : (Td(r.state.value[e], be),
        fe = {
            type: ru.patchObject,
            payload: be,
            storeId: e,
            events: w
        });
        const ge = y = Symbol();
        Ci().then( () => {
            y === ge && (p = !0)
        }
        ),
        h = !0,
        Ua(g, fe, r.state.value[e])
    }
    const P = s ? function() {
        const {state: fe} = n
          , ge = fe ? fe() : {};
        this.$patch(J => {
            Go(J, ge)
        }
        )
    }
    : u0;
    function x() {
        o.stop(),
        g = [],
        m = [],
        r._s.delete(e)
    }
    const v = (be, fe="") => {
        if (Ip in be)
            return be[Nf] = fe,
            be;
        const ge = function() {
            ku(r);
            const J = Array.from(arguments)
              , re = []
              , ee = [];
            function Y(ue) {
                re.push(ue)
            }
            function Z(ue) {
                ee.push(ue)
            }
            Ua(m, {
                args: J,
                name: ge[Nf],
                store: S,
                after: Y,
                onError: Z
            });
            let Q;
            try {
                Q = be.apply(this && this.$id === e ? this : S, J)
            } catch (ue) {
                throw Ua(ee, ue),
                ue
            }
            return Q instanceof Promise ? Q.then(ue => (Ua(re, ue),
            ue)).catch(ue => (Ua(ee, ue),
            Promise.reject(ue))) : (Ua(re, Q),
            Q)
        };
        return ge[Ip] = !0,
        ge[Nf] = fe,
        ge
    }
      , k = {
        _p: r,
        $id: e,
        $onAction: Fp.bind(null, m),
        $patch: R,
        $reset: P,
        $subscribe(be, fe={}) {
            const ge = Fp(g, be, fe.detached, () => J())
              , J = o.run( () => tr( () => r.state.value[e], re => {
                (fe.flush === "sync" ? h : p) && be({
                    storeId: e,
                    type: ru.direct,
                    events: w
                }, re)
            }
            , Go({}, u, fe)));
            return ge
        },
        $dispose: x
    }
      , S = Gr(k);
    r._s.set(e, S);
    const K = (r._a && r._a.runWithContext || mD)( () => r._e.run( () => (o = Ss()).run( () => t({
        action: v
    }))));
    for (const be in K) {
        const fe = K[be];
        if (sr(fe) && !bD(fe) || so(fe))
            s || (E && vD(fe) && (sr(fe) ? fe.value = E[be] : Td(fe, E[be])),
            r.state.value[e][be] = fe);
        else if (typeof fe == "function") {
            const ge = v(fe, be);
            K[be] = ge,
            l.actions[be] = fe
        }
    }
    return Go(S, K),
    Go(Nn(S), K),
    Object.defineProperty(S, "$state", {
        get: () => r.state.value[e],
        set: be => {
            R(fe => {
                Go(fe, be)
            }
            )
        }
    }),
    r._p.forEach(be => {
        Go(S, o.run( () => be({
            store: S,
            app: r._a,
            pinia: r,
            options: l
        })))
    }
    ),
    E && s && n.hydrate && n.hydrate(S.$state, E),
    p = !0,
    h = !0,
    S
}
/*! #__NO_SIDE_EFFECTS__ */
function DD(e, t, n) {
    let r;
    const i = typeof t == "function";
    r = i ? n : t;
    function s(o, l) {
        const u = Na();
        return o = o || (u ? pr(l0, null) : null),
        o && ku(o),
        o = a0,
        o._s.has(e) || (i ? c0(e, t, r, o) : wD(e, r, o)),
        o._s.get(e)
    }
    return s.$id = e,
    s
}
function Np(e) {
    const t = CD(e)
      , n = new ArrayBuffer(t.length)
      , r = new DataView(n);
    for (let i = 0; i < n.byteLength; i++)
        r.setUint8(i, t.charCodeAt(i));
    return n
}
const ED = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function CD(e) {
    e.length % 4 === 0 && (e = e.replace(/==?$/, ""));
    let t = ""
      , n = 0
      , r = 0;
    for (let i = 0; i < e.length; i++)
        n <<= 6,
        n |= ED.indexOf(e[i]),
        r += 6,
        r === 24 && (t += String.fromCharCode((n & 16711680) >> 16),
        t += String.fromCharCode((n & 65280) >> 8),
        t += String.fromCharCode(n & 255),
        n = r = 0);
    return r === 12 ? (n >>= 4,
    t += String.fromCharCode(n)) : r === 18 && (n >>= 2,
    t += String.fromCharCode((n & 65280) >> 8),
    t += String.fromCharCode(n & 255)),
    t
}
const xD = -1
  , SD = -2
  , TD = -3
  , PD = -4
  , kD = -5
  , AD = -6;
function RD(e, t) {
    return OD(JSON.parse(e), t)
}
function OD(e, t) {
    if (typeof e == "number")
        return i(e, !0);
    if (!Array.isArray(e) || e.length === 0)
        throw new Error("Invalid input");
    const n = e
      , r = Array(n.length);
    function i(s, o=!1) {
        if (s === xD)
            return;
        if (s === TD)
            return NaN;
        if (s === PD)
            return 1 / 0;
        if (s === kD)
            return -1 / 0;
        if (s === AD)
            return -0;
        if (o)
            throw new Error("Invalid input");
        if (s in r)
            return r[s];
        const l = n[s];
        if (!l || typeof l != "object")
            r[s] = l;
        else if (Array.isArray(l))
            if (typeof l[0] == "string") {
                const u = l[0]
                  , p = t == null ? void 0 : t[u];
                if (p)
                    return r[s] = p(i(l[1]));
                switch (u) {
                case "Date":
                    r[s] = new Date(l[1]);
                    break;
                case "Set":
                    const h = new Set;
                    r[s] = h;
                    for (let w = 1; w < l.length; w += 1)
                        h.add(i(l[w]));
                    break;
                case "Map":
                    const g = new Map;
                    r[s] = g;
                    for (let w = 1; w < l.length; w += 2)
                        g.set(i(l[w]), i(l[w + 1]));
                    break;
                case "RegExp":
                    r[s] = new RegExp(l[1],l[2]);
                    break;
                case "Object":
                    r[s] = Object(l[1]);
                    break;
                case "BigInt":
                    r[s] = BigInt(l[1]);
                    break;
                case "null":
                    const m = Object.create(null);
                    r[s] = m;
                    for (let w = 1; w < l.length; w += 2)
                        m[l[w]] = i(l[w + 1]);
                    break;
                case "Int8Array":
                case "Uint8Array":
                case "Uint8ClampedArray":
                case "Int16Array":
                case "Uint16Array":
                case "Int32Array":
                case "Uint32Array":
                case "Float32Array":
                case "Float64Array":
                case "BigInt64Array":
                case "BigUint64Array":
                    {
                        const w = globalThis[u]
                          , E = l[1]
                          , y = Np(E)
                          , R = new w(y);
                        r[s] = R;
                        break
                    }
                case "ArrayBuffer":
                    {
                        const w = l[1]
                          , E = Np(w);
                        r[s] = E;
                        break
                    }
                default:
                    throw new Error(`Unknown type ${u}`)
                }
            } else {
                const u = new Array(l.length);
                r[s] = u;
                for (let p = 0; p < l.length; p += 1) {
                    const h = l[p];
                    h !== SD && (u[p] = i(h))
                }
            }
        else {
            const u = {};
            r[s] = u;
            for (const p in l) {
                const h = l[p];
                u[p] = i(h)
            }
        }
        return r[s]
    }
    return i(0)
}
const MD = new Set(["link", "style", "script", "noscript"])
  , LD = new Set(["title", "titleTemplate", "script", "style", "noscript"])
  , $p = new Set(["base", "meta", "link", "style", "script", "noscript"])
  , FD = new Set(["title", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"])
  , ID = new Set(["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"])
  , ND = new Set(["key", "tagPosition", "tagPriority", "tagDuplicateStrategy", "innerHTML", "textContent", "processTemplateParams"])
  , $D = new Set(["templateParams", "htmlAttrs", "bodyAttrs"])
  , Eh = new Set(["theme-color", "google-site-verification", "og", "article", "book", "profile", "twitter", "author"])
  , mu = {
    META: new Set(["twitter"]),
    OG: new Set(["og", "book", "article", "profile", "fb"]),
    MEDIA: new Set(["ogImage", "ogVideo", "ogAudio", "twitterImage"]),
    HTTP_EQUIV: new Set(["contentType", "defaultStyle", "xUaCompatible"])
}
  , BD = {
    articleExpirationTime: "article:expiration_time",
    articleModifiedTime: "article:modified_time",
    articlePublishedTime: "article:published_time",
    bookReleaseDate: "book:release_date",
    fbAppId: "fb:app_id",
    ogAudioSecureUrl: "og:audio:secure_url",
    ogAudioUrl: "og:audio",
    ogImageSecureUrl: "og:image:secure_url",
    ogImageUrl: "og:image",
    ogSiteName: "og:site_name",
    ogVideoSecureUrl: "og:video:secure_url",
    ogVideoUrl: "og:video",
    profileFirstName: "profile:first_name",
    profileLastName: "profile:last_name",
    profileUsername: "profile:username",
    msapplicationConfig: "msapplication-Config",
    msapplicationTileColor: "msapplication-TileColor",
    msapplicationTileImage: "msapplication-TileImage"
}
  , f0 = {
    appleItunesApp: {
        unpack: {
            entrySeparator: ", ",
            resolve: ({key: e, value: t}) => `${Po(e)}=${t}`
        }
    },
    refresh: {
        metaKey: "http-equiv",
        unpack: {
            entrySeparator: ";",
            resolve: ({key: e, value: t}) => e === "seconds" ? `${t}` : void 0
        }
    },
    robots: {
        unpack: {
            entrySeparator: ", ",
            resolve: ({key: e, value: t}) => typeof t == "boolean" ? Po(e) : `${Po(e)}:${t}`
        }
    },
    contentSecurityPolicy: {
        metaKey: "http-equiv",
        unpack: {
            entrySeparator: "; ",
            resolve: ({key: e, value: t}) => `${Po(e)} ${t}`
        }
    },
    charset: {}
};
function Po(e) {
    const t = e.replace(/([A-Z])/g, "-$1").toLowerCase()
      , n = t.indexOf("-");
    return n === -1 ? t : mu.META.has(t.slice(0, n)) || mu.OG.has(t.slice(0, n)) ? e.replace(/([A-Z])/g, ":$1").toLowerCase() : t
}
function d0(e) {
    return Object.fromEntries(Object.entries(e).filter( ([t,n]) => String(n) !== "false" && t))
}
function Pd(e) {
    return Array.isArray(e) ? e.map(Pd) : !e || typeof e != "object" ? e : Object.fromEntries(Object.entries(e).map( ([t,n]) => [Po(t), Pd(n)]))
}
function h0(e, t={}) {
    const {entrySeparator: n="", keyValueSeparator: r="", wrapValue: i, resolve: s} = t;
    return Object.entries(e).map( ([o,l]) => {
        if (s) {
            const p = s({
                key: o,
                value: l
            });
            if (p !== void 0)
                return p
        }
        const u = typeof l == "object" ? h0(l, t) : typeof l == "number" ? l.toString() : typeof l == "string" && i ? `${i}${l.replace(new RegExp(i,"g"), `\\${i}`)}${i}` : l;
        return `${o}${r}${u}`
    }
    ).join(n)
}
function Bp(e, t) {
    const n = d0(t)
      , r = Po(e)
      , i = p0(r);
    if (!Eh.has(r))
        return [{
            [i]: r,
            ...n
        }];
    const s = Object.fromEntries(Object.entries(n).map( ([o,l]) => [`${e}${o === "url" ? "" : `${o[0].toUpperCase()}${o.slice(1)}`}`, l]));
    return Nc(s || {}).sort( (o, l) => {
        var u, p;
        return (((u = o[i]) == null ? void 0 : u.length) || 0) - (((p = l[i]) == null ? void 0 : p.length) || 0)
    }
    )
}
function p0(e) {
    var r;
    if (((r = f0[e]) == null ? void 0 : r.metaKey) === "http-equiv" || mu.HTTP_EQUIV.has(e))
        return "http-equiv";
    const t = Po(e)
      , n = t.indexOf(":");
    return n === -1 ? "name" : mu.OG.has(t.slice(0, n)) ? "property" : "name"
}
function HD(e) {
    return BD[e] || Po(e)
}
function VD(e, t) {
    var n;
    return t === "refresh" ? `${e.seconds};url=${e.url}` : h0(Pd(e), {
        keyValueSeparator: "=",
        entrySeparator: ", ",
        resolve: ({value: r, key: i}) => r === null ? "" : typeof r == "boolean" ? i : void 0,
        ...(n = f0[t]) == null ? void 0 : n.unpack
    })
}
function Nc(e) {
    const t = []
      , n = {};
    for (const [i,s] of Object.entries(e)) {
        if (Array.isArray(s)) {
            if (i === "themeColor") {
                s.forEach(o => {
                    typeof o == "object" && o !== null && t.push({
                        name: "theme-color",
                        ...o
                    })
                }
                );
                continue
            }
            for (const o of s)
                if (typeof o == "object" && o !== null) {
                    const l = []
                      , u = [];
                    for (const [p,h] of Object.entries(o)) {
                        const g = `${i}${p === "url" ? "" : `:${p}`}`
                          , m = Nc({
                            [g]: h
                        });
                        (p === "url" ? l : u).push(...m)
                    }
                    t.push(...l, ...u)
                } else
                    t.push(...typeof o == "string" ? Nc({
                        [i]: o
                    }) : Bp(i, o));
            continue
        }
        if (typeof s == "object" && s)
            if (mu.MEDIA.has(i)) {
                const o = i.startsWith("twitter") ? "twitter" : "og"
                  , l = i.replace(/^(og|twitter)/, "").toLowerCase()
                  , u = o === "twitter" ? "name" : "property";
                s.url && t.push({
                    [u]: `${o}:${l}`,
                    content: s.url
                }),
                s.secureUrl && t.push({
                    [u]: `${o}:${l}:secure_url`,
                    content: s.secureUrl
                });
                for (const [p,h] of Object.entries(s))
                    p !== "url" && p !== "secureUrl" && t.push({
                        [u]: `${o}:${l}:${p}`,
                        content: h
                    })
            } else
                Eh.has(Po(i)) ? t.push(...Bp(i, s)) : n[i] = d0(s);
        else
            n[i] = s
    }
    const r = Object.entries(n).map( ([i,s]) => {
        if (i === "charset")
            return {
                charset: s === null ? "_null" : s
            };
        const o = p0(i)
          , l = HD(i)
          , u = s === null ? "_null" : typeof s == "object" ? VD(s, i) : typeof s == "number" ? s.toString() : s;
        return o === "http-equiv" ? {
            "http-equiv": l,
            content: u
        } : {
            [o]: l,
            content: u
        }
    }
    );
    return [...t, ...r].map(i => "content"in i && i.content === "_null" ? {
        ...i,
        content: null
    } : i)
}
const jD = {
    key: "flatMeta",
    hooks: {
        "entries:normalize": e => {
            const t = [];
            e.tags = e.tags.map(n => n.tag !== "_flatMeta" ? n : (t.push(Nc(n.props).map(r => ({
                ...n,
                tag: "meta",
                props: r
            }))),
            !1)).filter(Boolean).concat(...t)
        }
    }
}
  , zD = ["name", "property", "http-equiv"];
function g0(e) {
    const t = e.split(":")[1];
    return Eh.has(t)
}
function kd(e) {
    const {props: t, tag: n} = e;
    if (ID.has(n))
        return n;
    if (n === "link" && t.rel === "canonical")
        return "canonical";
    if (t.charset)
        return "charset";
    if (e.tag === "meta") {
        for (const r of zD)
            if (t[r] !== void 0)
                return `${n}:${t[r]}`
    }
    if (e.key)
        return `${n}:key:${e.key}`;
    if (t.id)
        return `${n}:id:${t.id}`;
    if (LD.has(n)) {
        const r = e.textContent || e.innerHTML;
        if (r)
            return `${n}:content:${r}`
    }
}
function Hp(e) {
    const t = e._h || e._d;
    if (t)
        return t;
    const n = e.textContent || e.innerHTML;
    return n || `${e.tag}:${Object.entries(e.props).map( ([r,i]) => `${r}:${String(i)}`).join(",")}`
}
function $c(e, t, n) {
    typeof e === "function" && (!n || n !== "titleTemplate" && !(n[0] === "o" && n[1] === "n")) && (e = e());
    let i;
    if (t && (i = t(n, e)),
    Array.isArray(i))
        return i.map(s => $c(s, t));
    if ((i == null ? void 0 : i.constructor) === Object) {
        const s = {};
        for (const o of Object.keys(i))
            s[o] = $c(i[o], t, o);
        return s
    }
    return i
}
function UD(e, t) {
    const n = e === "style" ? new Map : new Set;
    function r(i) {
        const s = i.trim();
        if (s)
            if (e === "style") {
                const [o,...l] = s.split(":").map(u => u.trim());
                o && l.length && n.set(o, l.join(":"))
            } else
                s.split(" ").filter(Boolean).forEach(o => n.add(o))
    }
    return typeof t == "string" ? e === "style" ? t.split(";").forEach(r) : r(t) : Array.isArray(t) ? t.forEach(i => r(i)) : t && typeof t == "object" && Object.entries(t).forEach( ([i,s]) => {
        s && s !== "false" && (e === "style" ? n.set(i.trim(), s) : r(i))
    }
    ),
    n
}
function _0(e, t) {
    return e.props = e.props || {},
    t && Object.entries(t).forEach( ([n,r]) => {
        if (r === null) {
            e.props[n] = null;
            return
        }
        if (n === "class" || n === "style") {
            e.props[n] = UD(n, r);
            return
        }
        if (ND.has(n)) {
            if (["textContent", "innerHTML"].includes(n) && typeof r == "object") {
                let o = t.type;
                if (t.type || (o = "application/json"),
                !(o != null && o.endsWith("json")) && o !== "speculationrules")
                    return;
                t.type = o,
                e.props.type = o,
                e[n] = JSON.stringify(r)
            } else
                e[n] = r;
            return
        }
        const i = String(r)
          , s = n.startsWith("data-");
        i === "true" || i === "" ? e.props[n] = s ? i : !0 : !r && s && i === "false" ? e.props[n] = "false" : r !== void 0 && (e.props[n] = r)
    }
    ),
    e
}
function WD(e, t) {
    const n = typeof t == "object" && typeof t != "function" ? t : {
        [e === "script" || e === "noscript" || e === "style" ? "innerHTML" : "textContent"]: t
    }
      , r = _0({
        tag: e,
        props: {}
    }, n);
    return r.key && MD.has(r.tag) && (r.props["data-hid"] = r._h = r.key),
    r.tag === "script" && typeof r.innerHTML == "object" && (r.innerHTML = JSON.stringify(r.innerHTML),
    r.props.type = r.props.type || "application/json"),
    Array.isArray(r.props.content) ? r.props.content.map(i => ({
        ...r,
        props: {
            ...r.props,
            content: i
        }
    })) : r
}
function qD(e, t) {
    if (!e)
        return [];
    typeof e == "function" && (e = e());
    const n = (i, s) => {
        for (let o = 0; o < t.length; o++)
            s = t[o](i, s);
        return s
    }
    ;
    e = n(void 0, e);
    const r = [];
    return e = $c(e, n),
    Object.entries(e || {}).forEach( ([i,s]) => {
        if (s !== void 0)
            for (const o of Array.isArray(s) ? s : [s])
                r.push(WD(i, o))
    }
    ),
    r.flat()
}
const Vp = (e, t) => e._w === t._w ? e._p - t._p : e._w - t._w
  , jp = {
    base: -10,
    title: 10
}
  , GD = {
    critical: -8,
    high: -1,
    low: 2
}
  , zp = {
    meta: {
        "content-security-policy": -30,
        charset: -20,
        viewport: -15
    },
    link: {
        preconnect: 20,
        stylesheet: 60,
        preload: 70,
        modulepreload: 70,
        prefetch: 90,
        "dns-prefetch": 90,
        prerender: 90
    },
    script: {
        async: 30,
        defer: 80,
        sync: 50
    },
    style: {
        imported: 40,
        sync: 60
    }
}
  , YD = /@import/
  , Fl = e => e === "" || e === !0;
function KD(e, t) {
    var s;
    if (typeof t.tagPriority == "number")
        return t.tagPriority;
    let n = 100;
    const r = GD[t.tagPriority] || 0
      , i = e.resolvedOptions.disableCapoSorting ? {
        link: {},
        script: {},
        style: {}
    } : zp;
    if (t.tag in jp)
        n = jp[t.tag];
    else if (t.tag === "meta") {
        const o = t.props["http-equiv"] === "content-security-policy" ? "content-security-policy" : t.props.charset ? "charset" : t.props.name === "viewport" ? "viewport" : null;
        o && (n = zp.meta[o])
    } else
        t.tag === "link" && t.props.rel ? n = i.link[t.props.rel] : t.tag === "script" ? Fl(t.props.async) ? n = i.script.async : t.props.src && !Fl(t.props.defer) && !Fl(t.props.async) && t.props.type !== "module" && !((s = t.props.type) != null && s.endsWith("json")) ? n = i.script.sync : Fl(t.props.defer) && t.props.src && !Fl(t.props.async) && (n = i.script.defer) : t.tag === "style" && (n = t.innerHTML && YD.test(t.innerHTML) ? i.style.imported : i.style.sync);
    return (n || 100) + r
}
function Up(e, t) {
    const n = typeof t == "function" ? t(e) : t
      , r = n.key || String(e.plugins.size + 1);
    e.plugins.get(r) || (e.plugins.set(r, n),
    e.hooks.addHooks(n.hooks || {}))
}
function XD(e={}) {
    var l;
    const t = Qm();
    t.addHooks(e.hooks || {});
    const n = !e.document
      , r = new Map
      , i = new Map
      , s = []
      , o = {
        _entryCount: 1,
        plugins: i,
        dirty: !1,
        resolvedOptions: e,
        hooks: t,
        ssr: n,
        entries: r,
        headEntries() {
            return [...r.values()]
        },
        use: u => Up(o, u),
        push(u, p) {
            const h = {
                ...p || {}
            };
            delete h.head;
            const g = h._index ?? o._entryCount++
              , m = {
                _i: g,
                input: u,
                options: h
            }
              , w = {
                _poll(E=!1) {
                    o.dirty = !0,
                    !E && s.push(g),
                    t.callHook("entries:updated", o)
                },
                dispose() {
                    r.delete(g) && w._poll(!0)
                },
                patch(E) {
                    (!h.mode || h.mode === "server" && n || h.mode === "client" && !n) && (m.input = E,
                    r.set(g, m),
                    w._poll())
                }
            };
            return w.patch(u),
            w
        },
        async resolveTags() {
            var w;
            const u = {
                tagMap: new Map,
                tags: [],
                entries: [...o.entries.values()]
            };
            for (await t.callHook("entries:resolve", u); s.length; ) {
                const E = s.shift()
                  , y = r.get(E);
                if (y) {
                    const R = {
                        tags: qD(y.input, e.propResolvers || []).map(P => Object.assign(P, y.options)),
                        entry: y
                    };
                    await t.callHook("entries:normalize", R),
                    y._tags = R.tags.map( (P, x) => (P._w = KD(o, P),
                    P._p = (y._i << 10) + x,
                    P._d = kd(P),
                    P))
                }
            }
            let p = !1;
            u.entries.flatMap(E => (E._tags || []).map(y => ({
                ...y,
                props: {
                    ...y.props
                }
            }))).sort(Vp).reduce( (E, y) => {
                const R = String(y._d || y._p);
                if (!E.has(R))
                    return E.set(R, y);
                const P = E.get(R);
                if (((y == null ? void 0 : y.tagDuplicateStrategy) || ($D.has(y.tag) ? "merge" : null) || (y.key && y.key === P.key ? "merge" : null)) === "merge") {
                    const v = {
                        ...P.props
                    };
                    Object.entries(y.props).forEach( ([k,S]) => v[k] = k === "style" ? new Map([...P.props.style || new Map, ...S]) : k === "class" ? new Set([...P.props.class || new Set, ...S]) : S),
                    E.set(R, {
                        ...y,
                        props: v
                    })
                } else
                    y._p >> 10 === P._p >> 10 && g0(y._d) ? (E.set(R, Object.assign([...Array.isArray(P) ? P : [P], y], y)),
                    p = !0) : (y._w === P._w ? y._p > P._p : (y == null ? void 0 : y._w) < (P == null ? void 0 : P._w)) && E.set(R, y);
                return E
            }
            , u.tagMap);
            const h = u.tagMap.get("title")
              , g = u.tagMap.get("titleTemplate");
            if (o._title = h == null ? void 0 : h.textContent,
            g) {
                const E = g == null ? void 0 : g.textContent;
                if (o._titleTemplate = E,
                E) {
                    let y = typeof E == "function" ? E(h == null ? void 0 : h.textContent) : E;
                    typeof y == "string" && !o.plugins.has("template-params") && (y = y.replace("%s", (h == null ? void 0 : h.textContent) || "")),
                    h ? y === null ? u.tagMap.delete("title") : u.tagMap.set("title", {
                        ...h,
                        textContent: y
                    }) : (g.tag = "title",
                    g.textContent = y)
                }
            }
            u.tags = Array.from(u.tagMap.values()),
            p && (u.tags = u.tags.flat().sort(Vp)),
            await t.callHook("tags:beforeResolve", u),
            await t.callHook("tags:resolve", u),
            await t.callHook("tags:afterResolve", u);
            const m = [];
            for (const E of u.tags) {
                const {innerHTML: y, tag: R, props: P} = E;
                if (FD.has(R) && !(Object.keys(P).length === 0 && !E.innerHTML && !E.textContent) && !(R === "meta" && !P.content && !P["http-equiv"] && !P.charset)) {
                    if (R === "script" && y) {
                        if ((w = P.type) != null && w.endsWith("json")) {
                            const x = typeof y == "string" ? y : JSON.stringify(y);
                            E.innerHTML = x.replace(/</g, "\\u003C")
                        } else
                            typeof y == "string" && (E.innerHTML = y.replace(new RegExp(`</${R}`,"g"), `<\\/${R}`));
                        E._d = kd(E)
                    }
                    m.push(E)
                }
            }
            return m
        }
    };
    return ((e == null ? void 0 : e.plugins) || []).forEach(u => Up(o, u)),
    o.hooks.callHook("init", o),
    (l = e.init) == null || l.forEach(u => u && o.push(u)),
    o
}
const QD = (e, t) => sr(t) ? Qr(t) : t
  , Ch = "usehead";
function JD(e) {
    return {
        install(n) {
            n.config.globalProperties.$unhead = e,
            n.config.globalProperties.$head = e,
            n.provide(Ch, e)
        }
    }.install
}
function m0() {
    if (Na()) {
        const e = pr(Ch);
        if (!e)
            throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.");
        return e
    }
    throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.")
}
function y0(e, t={}) {
    const n = t.head || m0();
    return n.ssr ? n.push(e || {}, t) : ZD(n, e, t)
}
function ZD(e, t, n={}) {
    const r = Ut(!1);
    let i;
    return fs( () => {
        const o = r.value ? {} : $c(t, QD);
        i ? i.patch(o) : i = e.push(o, n)
    }
    ),
    Or() && (Io( () => {
        i.dispose()
    }
    ),
    sh( () => {
        r.value = !0
    }
    ),
    ih( () => {
        r.value = !1
    }
    )),
    i
}
function eE(e={}, t={}) {
    (t.head || m0()).use(jD);
    const {title: r, titleTemplate: i, ...s} = e;
    return y0({
        title: r,
        titleTemplate: i,
        _flatMeta: s
    }, t)
}
function xh(e) {
    var n;
    const t = e || e0();
    return ((n = t == null ? void 0 : t.ssrContext) == null ? void 0 : n.head) || (t == null ? void 0 : t.runWithContext( () => {
        if (Na())
            return pr(Ch)
    }
    ))
}
function v0(e, t={}) {
    const n = xh(t.nuxt);
    if (n)
        return y0(e, {
            head: n,
            ...t
        })
}
function SA(e, t={}) {
    const n = xh(t.nuxt);
    if (n)
        return eE(e, {
            head: n,
            ...t
        })
}
const tE = "modulepreload"
  , nE = function(e, t) {
    return new URL(e,t).href
}
  , Wp = {}
  , Vt = function(t, n, r) {
    let i = Promise.resolve();
    if (n && n.length > 0) {
        let o = function(h) {
            return Promise.all(h.map(g => Promise.resolve(g).then(m => ({
                status: "fulfilled",
                value: m
            }), m => ({
                status: "rejected",
                reason: m
            }))))
        };
        const l = document.getElementsByTagName("link")
          , u = document.querySelector("meta[property=csp-nonce]")
          , p = (u == null ? void 0 : u.nonce) || (u == null ? void 0 : u.getAttribute("nonce"));
        i = o(n.map(h => {
            if (h = nE(h, r),
            h in Wp)
                return;
            Wp[h] = !0;
            const g = h.endsWith(".css")
              , m = g ? '[rel="stylesheet"]' : "";
            if (!!r)
                for (let y = l.length - 1; y >= 0; y--) {
                    const R = l[y];
                    if (R.href === h && (!g || R.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${h}"]${m}`))
                return;
            const E = document.createElement("link");
            if (E.rel = g ? "stylesheet" : tE,
            g || (E.as = "script"),
            E.crossOrigin = "",
            E.href = h,
            p && E.setAttribute("nonce", p),
            document.head.appendChild(E),
            g)
                return new Promise( (y, R) => {
                    E.addEventListener("load", y),
                    E.addEventListener("error", () => R(new Error(`Unable to preload CSS for ${h}`)))
                }
                )
        }
        ))
    }
    function s(o) {
        const l = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (l.payload = o,
        window.dispatchEvent(l),
        !l.defaultPrevented)
            throw o
    }
    return i.then(o => {
        for (const l of o || [])
            l.status === "rejected" && s(l.reason);
        return t().catch(s)
    }
    )
};
let dc, hc;
function rE() {
    return dc = $fetch(Dh(`builds/meta/${qs().app.buildId}.json`), {
        responseType: "json"
    }),
    dc.then(e => {
        hc = iD(e.matcher)
    }
    ).catch(e => {
        console.error("[nuxt] Error fetching app manifest.", e)
    }
    ),
    dc
}
function cf() {
    return dc || rE()
}
async function Sh(e) {
    const t = typeof e == "string" ? e : e.path;
    if (await cf(),
    !hc)
        return console.error("[nuxt] Error creating app manifest matcher.", hc),
        {};
    try {
        return lf({}, ...hc.matchAll(t).reverse())
    } catch (n) {
        return console.error("[nuxt] Error matching route rules.", n),
        {}
    }
}
async function qp(e, t={}) {
    if (!await w0(e))
        return null;
    const r = await sE(e, t);
    return await b0(r) || null
}
const iE = "_payload.json";
async function sE(e, t={}) {
    const n = new URL(e,"http://localhost");
    if (n.host !== "localhost" || ao(n.pathname, {
        acceptRelative: !0
    }))
        throw new Error("Payload URL must not include hostname: " + e);
    const r = qs()
      , i = t.hash || (t.fresh ? Date.now() : r.app.buildId)
      , s = r.app.cdnURL
      , o = s && await w0(e) ? s : r.app.baseURL;
    return af(o, n.pathname, iE + (i ? `?${i}` : ""))
}
async function b0(e) {
    const t = fetch(e, {
        cache: "force-cache"
    }).then(n => n.text().then(D0));
    try {
        return await t
    } catch (n) {
        console.warn("[nuxt] Cannot load payload ", e, n)
    }
    return null
}
async function w0(e=Pu().path) {
    const t = Tr();
    return e = fl(e),
    (await cf()).prerendered.includes(e) ? !0 : t.runWithContext(async () => {
        const r = await Sh({
            path: e
        });
        return !!r.prerender && !r.redirect
    }
    )
}
let Da = null;
async function oE() {
    var r;
    if (Da)
        return Da;
    const e = document.getElementById("__NUXT_DATA__");
    if (!e)
        return {};
    const t = await D0(e.textContent || "")
      , n = e.dataset.src ? await b0(e.dataset.src) : void 0;
    return Da = {
        ...t,
        ...n,
        ...window.__NUXT__
    },
    (r = Da.config) != null && r.public && (Da.config.public = Gr(Da.config.public)),
    Da
}
async function D0(e) {
    return await RD(e, Tr()._payloadRevivers)
}
function E0(e, t) {
    Tr()._payloadRevivers[e] = t
}
const aE = nD( () => {
    E0("skipHydrate", e => {}
    )
}
)
  , lE = [["NuxtError", e => ra(e)], ["EmptyShallowRef", e => qr(e === "_" ? void 0 : e === "0n" ? BigInt(0) : Oc(e))], ["EmptyRef", e => Ut(e === "_" ? void 0 : e === "0n" ? BigInt(0) : Oc(e))], ["ShallowRef", e => qr(e)], ["ShallowReactive", e => Ts(e)], ["Ref", e => Ut(e)], ["Reactive", e => Gr(e)]]
  , uE = ki({
    name: "nuxt:revive-payload:client",
    order: -30,
    async setup(e) {
        let t, n;
        for (const [r,i] of lE)
            E0(r, i);
        Object.assign(e.payload, ([t,n] = il( () => e.runWithContext(oE)),
        t = await t,
        n(),
        t)),
        window.__NUXT__ = e.payload
    }
});
async function Th(e, t={}) {
    const n = t.document || e.resolvedOptions.document;
    if (!n || !e.dirty)
        return;
    const r = {
        shouldRender: !0,
        tags: []
    };
    if (await e.hooks.callHook("dom:beforeRender", r),
    !!r.shouldRender)
        return e._domUpdatePromise || (e._domUpdatePromise = new Promise(async i => {
            var w;
            const s = new Map
              , o = new Promise(E => {
                e.resolveTags().then(y => {
                    E(y.map(R => {
                        const P = s.get(R._d) || 0
                          , x = {
                            tag: R,
                            id: (P ? `${R._d}:${P}` : R._d) || Hp(R),
                            shouldRender: !0
                        };
                        return R._d && g0(R._d) && s.set(R._d, P + 1),
                        x
                    }
                    ))
                }
                )
            }
            );
            let l = e._dom;
            if (!l) {
                l = {
                    title: n.title,
                    elMap: new Map().set("htmlAttrs", n.documentElement).set("bodyAttrs", n.body)
                };
                for (const E of ["body", "head"]) {
                    const y = (w = n[E]) == null ? void 0 : w.children;
                    for (const R of y) {
                        const P = R.tagName.toLowerCase();
                        if (!$p.has(P))
                            continue;
                        const x = _0({
                            tag: P,
                            props: {}
                        }, {
                            innerHTML: R.innerHTML,
                            ...R.getAttributeNames().reduce( (v, k) => (v[k] = R.getAttribute(k),
                            v), {}) || {}
                        });
                        if (x.key = R.getAttribute("data-hid") || void 0,
                        x._d = kd(x) || Hp(x),
                        l.elMap.has(x._d)) {
                            let v = 1
                              , k = x._d;
                            for (; l.elMap.has(k); )
                                k = `${x._d}:${v++}`;
                            l.elMap.set(k, R)
                        } else
                            l.elMap.set(x._d, R)
                    }
                }
            }
            l.pendingSideEffects = {
                ...l.sideEffects
            },
            l.sideEffects = {};
            function u(E, y, R) {
                const P = `${E}:${y}`;
                l.sideEffects[P] = R,
                delete l.pendingSideEffects[P]
            }
            function p({id: E, $el: y, tag: R}) {
                const P = R.tag.endsWith("Attrs");
                l.elMap.set(E, y),
                P || (R.textContent && R.textContent !== y.textContent && (y.textContent = R.textContent),
                R.innerHTML && R.innerHTML !== y.innerHTML && (y.innerHTML = R.innerHTML),
                u(E, "el", () => {
                    y == null || y.remove(),
                    l.elMap.delete(E)
                }
                ));
                for (const x in R.props) {
                    if (!Object.prototype.hasOwnProperty.call(R.props, x))
                        continue;
                    const v = R.props[x];
                    if (x.startsWith("on") && typeof v == "function") {
                        const S = y == null ? void 0 : y.dataset;
                        if (S && S[`${x}fired`]) {
                            const W = x.slice(0, -5);
                            v.call(y, new Event(W.substring(2)))
                        }
                        y.getAttribute(`data-${x}`) !== "" && ((R.tag === "bodyAttrs" ? n.defaultView : y).addEventListener(x.substring(2), v.bind(y)),
                        y.setAttribute(`data-${x}`, ""));
                        continue
                    }
                    const k = `attr:${x}`;
                    if (x === "class") {
                        if (!v)
                            continue;
                        for (const S of v)
                            P && u(E, `${k}:${S}`, () => y.classList.remove(S)),
                            !y.classList.contains(S) && y.classList.add(S)
                    } else if (x === "style") {
                        if (!v)
                            continue;
                        for (const [S,W] of v)
                            u(E, `${k}:${S}`, () => {
                                y.style.removeProperty(S)
                            }
                            ),
                            y.style.setProperty(S, W)
                    } else
                        v !== !1 && v !== null && (y.getAttribute(x) !== v && y.setAttribute(x, v === !0 ? "" : String(v)),
                        P && u(E, k, () => y.removeAttribute(x)))
                }
            }
            const h = []
              , g = {
                bodyClose: void 0,
                bodyOpen: void 0,
                head: void 0
            }
              , m = await o;
            for (const E of m) {
                const {tag: y, shouldRender: R, id: P} = E;
                if (R) {
                    if (y.tag === "title") {
                        n.title = y.textContent,
                        u("title", "", () => n.title = l.title);
                        continue
                    }
                    E.$el = E.$el || l.elMap.get(P),
                    E.$el ? p(E) : $p.has(y.tag) && h.push(E)
                }
            }
            for (const E of h) {
                const y = E.tag.tagPosition || "head";
                E.$el = n.createElement(E.tag.tag),
                p(E),
                g[y] = g[y] || n.createDocumentFragment(),
                g[y].appendChild(E.$el)
            }
            for (const E of m)
                await e.hooks.callHook("dom:renderTag", E, n, u);
            g.head && n.head.appendChild(g.head),
            g.bodyOpen && n.body.insertBefore(g.bodyOpen, n.body.firstChild),
            g.bodyClose && n.body.appendChild(g.bodyClose);
            for (const E in l.pendingSideEffects)
                l.pendingSideEffects[E]();
            e._dom = l,
            await e.hooks.callHook("dom:rendered", {
                renders: m
            }),
            i()
        }
        ).finally( () => {
            e._domUpdatePromise = void 0,
            e.dirty = !1
        }
        )),
        e._domUpdatePromise
}
function cE(e={}) {
    var r, i, s;
    const t = ((r = e.domOptions) == null ? void 0 : r.render) || Th;
    e.document = e.document || (typeof window < "u" ? document : void 0);
    const n = ((s = (i = e.document) == null ? void 0 : i.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : s.innerHTML) || !1;
    return XD({
        ...e,
        plugins: [...e.plugins || [], {
            key: "client",
            hooks: {
                "entries:updated": t
            }
        }],
        init: [n ? JSON.parse(n) : !1, ...e.init || []]
    })
}
function fE(e, t) {
    let n = 0;
    return () => {
        const r = ++n;
        t( () => {
            n === r && e()
        }
        )
    }
}
function dE(e={}) {
    const t = cE({
        domOptions: {
            render: fE( () => Th(t), n => setTimeout(n, 0))
        },
        ...e
    });
    return t.install = JD(t),
    t
}
const hE = new Set(["onload", "onerror"]);
const pE = (e, t) => e._w === t._w ? e._p - t._p : e._w - t._w
  , Jo = "%separator"
  , gE = new RegExp(`${Jo}(?:\\s*${Jo})*`,"g");
function _E(e, t, n=!1) {
    var i;
    let r;
    if (t === "s" || t === "pageTitle")
        r = e.pageTitle;
    else if (t.includes(".")) {
        const s = t.indexOf(".");
        r = (i = e[t.substring(0, s)]) == null ? void 0 : i[t.substring(s + 1)]
    } else
        r = e[t];
    if (r !== void 0)
        return n ? (r || "").replace(/\\/g, "\\\\").replace(/</g, "\\u003C").replace(/"/g, '\\"') : r || ""
}
function ec(e, t, n, r=!1) {
    if (typeof e != "string" || !e.includes("%"))
        return e;
    let i = e;
    try {
        i = decodeURI(e)
    } catch {}
    const s = i.match(/%\w+(?:\.\w+)?/g);
    if (!s)
        return e;
    const o = e.includes(Jo);
    return e = e.replace(/%\w+(?:\.\w+)?/g, l => {
        if (l === Jo || !s.includes(l))
            return l;
        const u = _E(t, l.slice(1), r);
        return u !== void 0 ? u : l
    }
    ).trim(),
    o && (e.endsWith(Jo) && (e = e.slice(0, -Jo.length)),
    e.startsWith(Jo) && (e = e.slice(Jo.length)),
    e = e.replace(gE, n || "").trim()),
    e
}
const Gp = e => e.includes(":key") ? e : e.split(":").join(":key:")
  , mE = {
    key: "aliasSorting",
    hooks: {
        "tags:resolve": e => {
            let t = !1;
            for (const n of e.tags) {
                const r = n.tagPriority;
                if (!r)
                    continue;
                const i = String(r);
                if (i.startsWith("before:")) {
                    const s = Gp(i.slice(7))
                      , o = e.tagMap.get(s);
                    o && (typeof o.tagPriority == "number" && (n.tagPriority = o.tagPriority),
                    n._p = o._p - 1,
                    t = !0)
                } else if (i.startsWith("after:")) {
                    const s = Gp(i.slice(6))
                      , o = e.tagMap.get(s);
                    o && (typeof o.tagPriority == "number" && (n.tagPriority = o.tagPriority),
                    n._p = o._p + 1,
                    t = !0)
                }
            }
            t && (e.tags = e.tags.sort(pE))
        }
    }
}
  , yE = {
    key: "deprecations",
    hooks: {
        "entries:normalize": ({tags: e}) => {
            for (const t of e)
                t.props.children && (t.innerHTML = t.props.children,
                delete t.props.children),
                t.props.hid && (t.key = t.props.hid,
                delete t.props.hid),
                t.props.vmid && (t.key = t.props.vmid,
                delete t.props.vmid),
                t.props.body && (t.tagPosition = "bodyClose",
                delete t.props.body)
        }
    }
};
async function Ad(e) {
    if (typeof e === "function")
        return e;
    if (e instanceof Promise)
        return await e;
    if (Array.isArray(e))
        return await Promise.all(e.map(n => Ad(n)));
    if ((e == null ? void 0 : e.constructor) === Object) {
        const n = {};
        for (const r of Object.keys(e))
            n[r] = await Ad(e[r]);
        return n
    }
    return e
}
const vE = {
    key: "promises",
    hooks: {
        "entries:resolve": async e => {
            const t = [];
            for (const n in e.entries)
                e.entries[n]._promisesProcessed || t.push(Ad(e.entries[n].input).then(r => {
                    e.entries[n].input = r,
                    e.entries[n]._promisesProcessed = !0
                }
                ));
            await Promise.all(t)
        }
    }
}
  , bE = {
    meta: "content",
    link: "href",
    htmlAttrs: "lang"
}
  , wE = ["innerHTML", "textContent"]
  , DE = e => ({
    key: "template-params",
    hooks: {
        "entries:normalize": t => {
            var r, i, s;
            const n = ((i = (r = t.tags.filter(o => o.tag === "templateParams" && o.mode === "server")) == null ? void 0 : r[0]) == null ? void 0 : i.props) || {};
            Object.keys(n).length && (e._ssrPayload = {
                templateParams: {
                    ...((s = e._ssrPayload) == null ? void 0 : s.templateParams) || {},
                    ...n
                }
            })
        }
        ,
        "tags:resolve": ({tagMap: t, tags: n}) => {
            var s;
            const r = ((s = t.get("templateParams")) == null ? void 0 : s.props) || {}
              , i = r.separator || "|";
            delete r.separator,
            r.pageTitle = ec(r.pageTitle || e._title || "", r, i);
            for (const o of n) {
                if (o.processTemplateParams === !1)
                    continue;
                const l = bE[o.tag];
                if (l && typeof o.props[l] == "string")
                    o.props[l] = ec(o.props[l], r, i);
                else if (o.processTemplateParams || o.tag === "titleTemplate" || o.tag === "title")
                    for (const u of wE)
                        typeof o[u] == "string" && (o[u] = ec(o[u], r, i, o.tag === "script" && o.props.type.endsWith("json")))
            }
            e._templateParams = r,
            e._separator = i
        }
        ,
        "tags:afterResolve": ({tagMap: t}) => {
            const n = t.get("title");
            n != null && n.textContent && n.processTemplateParams !== !1 && (n.textContent = ec(n.textContent, e._templateParams, e._separator))
        }
    }
})
  , EE = {
    disableDefaults: !0,
    disableCapoSorting: !1,
    plugins: [yE, vE, DE, mE]
}
  , CE = ki({
    name: "nuxt:head",
    enforce: "pre",
    setup(e) {
        const t = dE(EE);
        e.vueApp.use(t);
        {
            let n = !0;
            const r = async () => {
                n = !1,
                await Th(t)
            }
            ;
            t.hooks.hook("dom:beforeRender", i => {
                i.shouldRender = !n
            }
            ),
            e.hooks.hook("page:start", () => {
                n = !0
            }
            ),
            e.hooks.hook("page:finish", () => {
                e.isHydrating || r()
            }
            ),
            e.hooks.hook("app:error", r),
            e.hooks.hook("app:suspense:resolve", r)
        }
    }
});
/*!
  * vue-router v4.5.1
  * (c) 2025 Eduardo San Martin Morote
  * @license MIT
  */
const Ya = typeof document < "u";
function C0(e) {
    return typeof e == "object" || "displayName"in e || "props"in e || "__vccOpts"in e
}
function xE(e) {
    return e.__esModule || e[Symbol.toStringTag] === "Module" || e.default && C0(e.default)
}
const ir = Object.assign;
function $f(e, t) {
    const n = {};
    for (const r in t) {
        const i = t[r];
        n[r] = Ws(i) ? i.map(e) : e(i)
    }
    return n
}
const iu = () => {}
  , Ws = Array.isArray
  , x0 = /#/g
  , SE = /&/g
  , TE = /\//g
  , PE = /=/g
  , kE = /\?/g
  , S0 = /\+/g
  , AE = /%5B/g
  , RE = /%5D/g
  , T0 = /%5E/g
  , OE = /%60/g
  , P0 = /%7B/g
  , ME = /%7C/g
  , k0 = /%7D/g
  , LE = /%20/g;
function Ph(e) {
    return encodeURI("" + e).replace(ME, "|").replace(AE, "[").replace(RE, "]")
}
function FE(e) {
    return Ph(e).replace(P0, "{").replace(k0, "}").replace(T0, "^")
}
function Rd(e) {
    return Ph(e).replace(S0, "%2B").replace(LE, "+").replace(x0, "%23").replace(SE, "%26").replace(OE, "`").replace(P0, "{").replace(k0, "}").replace(T0, "^")
}
function IE(e) {
    return Rd(e).replace(PE, "%3D")
}
function NE(e) {
    return Ph(e).replace(x0, "%23").replace(kE, "%3F")
}
function $E(e) {
    return e == null ? "" : NE(e).replace(TE, "%2F")
}
function yu(e) {
    try {
        return decodeURIComponent("" + e)
    } catch {}
    return "" + e
}
const BE = /\/$/
  , HE = e => e.replace(BE, "");
function Bf(e, t, n="/") {
    let r, i = {}, s = "", o = "";
    const l = t.indexOf("#");
    let u = t.indexOf("?");
    return l < u && l >= 0 && (u = -1),
    u > -1 && (r = t.slice(0, u),
    s = t.slice(u + 1, l > -1 ? l : t.length),
    i = e(s)),
    l > -1 && (r = r || t.slice(0, l),
    o = t.slice(l, t.length)),
    r = UE(r ?? t, n),
    {
        fullPath: r + (s && "?") + s + o,
        path: r,
        query: i,
        hash: yu(o)
    }
}
function VE(e, t) {
    const n = t.query ? e(t.query) : "";
    return t.path + (n && "?") + n + (t.hash || "")
}
function Yp(e, t) {
    return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}
function jE(e, t, n) {
    const r = t.matched.length - 1
      , i = n.matched.length - 1;
    return r > -1 && r === i && dl(t.matched[r], n.matched[i]) && A0(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
}
function dl(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}
function A0(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const n in e)
        if (!zE(e[n], t[n]))
            return !1;
    return !0
}
function zE(e, t) {
    return Ws(e) ? Kp(e, t) : Ws(t) ? Kp(t, e) : e === t
}
function Kp(e, t) {
    return Ws(t) ? e.length === t.length && e.every( (n, r) => n === t[r]) : e.length === 1 && e[0] === t
}
function UE(e, t) {
    if (e.startsWith("/"))
        return e;
    if (!e)
        return t;
    const n = t.split("/")
      , r = e.split("/")
      , i = r[r.length - 1];
    (i === ".." || i === ".") && r.push("");
    let s = n.length - 1, o, l;
    for (o = 0; o < r.length; o++)
        if (l = r[o],
        l !== ".")
            if (l === "..")
                s > 1 && s--;
            else
                break;
    return n.slice(0, s).join("/") + "/" + r.slice(o).join("/")
}
const xs = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var vu;
(function(e) {
    e.pop = "pop",
    e.push = "push"
}
)(vu || (vu = {}));
var su;
(function(e) {
    e.back = "back",
    e.forward = "forward",
    e.unknown = ""
}
)(su || (su = {}));
function WE(e) {
    if (!e)
        if (Ya) {
            const t = document.querySelector("base");
            e = t && t.getAttribute("href") || "/",
            e = e.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            e = "/";
    return e[0] !== "/" && e[0] !== "#" && (e = "/" + e),
    HE(e)
}
const qE = /^[^#]+#/;
function GE(e, t) {
    return e.replace(qE, "#") + t
}
function YE(e, t) {
    const n = document.documentElement.getBoundingClientRect()
      , r = e.getBoundingClientRect();
    return {
        behavior: t.behavior,
        left: r.left - n.left - (t.left || 0),
        top: r.top - n.top - (t.top || 0)
    }
}
const ff = () => ({
    left: window.scrollX,
    top: window.scrollY
});
function KE(e) {
    let t;
    if ("el"in e) {
        const n = e.el
          , r = typeof n == "string" && n.startsWith("#")
          , i = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!i)
            return;
        t = YE(i, e)
    } else
        t = e;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
}
function Xp(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const Od = new Map;
function XE(e, t) {
    Od.set(e, t)
}
function QE(e) {
    const t = Od.get(e);
    return Od.delete(e),
    t
}
let JE = () => location.protocol + "//" + location.host;
function R0(e, t) {
    const {pathname: n, search: r, hash: i} = t
      , s = e.indexOf("#");
    if (s > -1) {
        let l = i.includes(e.slice(s)) ? e.slice(s).length : 1
          , u = i.slice(l);
        return u[0] !== "/" && (u = "/" + u),
        Yp(u, "")
    }
    return Yp(n, e) + r + i
}
function ZE(e, t, n, r) {
    let i = []
      , s = []
      , o = null;
    const l = ({state: m}) => {
        const w = R0(e, location)
          , E = n.value
          , y = t.value;
        let R = 0;
        if (m) {
            if (n.value = w,
            t.value = m,
            o && o === E) {
                o = null;
                return
            }
            R = y ? m.position - y.position : 0
        } else
            r(w);
        i.forEach(P => {
            P(n.value, E, {
                delta: R,
                type: vu.pop,
                direction: R ? R > 0 ? su.forward : su.back : su.unknown
            })
        }
        )
    }
    ;
    function u() {
        o = n.value
    }
    function p(m) {
        i.push(m);
        const w = () => {
            const E = i.indexOf(m);
            E > -1 && i.splice(E, 1)
        }
        ;
        return s.push(w),
        w
    }
    function h() {
        const {history: m} = window;
        m.state && m.replaceState(ir({}, m.state, {
            scroll: ff()
        }), "")
    }
    function g() {
        for (const m of s)
            m();
        s = [],
        window.removeEventListener("popstate", l),
        window.removeEventListener("beforeunload", h)
    }
    return window.addEventListener("popstate", l),
    window.addEventListener("beforeunload", h, {
        passive: !0
    }),
    {
        pauseListeners: u,
        listen: p,
        destroy: g
    }
}
function Qp(e, t, n, r=!1, i=!1) {
    return {
        back: e,
        current: t,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: i ? ff() : null
    }
}
function eC(e) {
    const {history: t, location: n} = window
      , r = {
        value: R0(e, n)
    }
      , i = {
        value: t.state
    };
    i.value || s(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function s(u, p, h) {
        const g = e.indexOf("#")
          , m = g > -1 ? (n.host && document.querySelector("base") ? e : e.slice(g)) + u : JE() + e + u;
        try {
            t[h ? "replaceState" : "pushState"](p, "", m),
            i.value = p
        } catch (w) {
            console.error(w),
            n[h ? "replace" : "assign"](m)
        }
    }
    function o(u, p) {
        const h = ir({}, t.state, Qp(i.value.back, u, i.value.forward, !0), p, {
            position: i.value.position
        });
        s(u, h, !0),
        r.value = u
    }
    function l(u, p) {
        const h = ir({}, i.value, t.state, {
            forward: u,
            scroll: ff()
        });
        s(h.current, h, !0);
        const g = ir({}, Qp(r.value, u, null), {
            position: h.position + 1
        }, p);
        s(u, g, !1),
        r.value = u
    }
    return {
        location: r,
        state: i,
        push: l,
        replace: o
    }
}
function tC(e) {
    e = WE(e);
    const t = eC(e)
      , n = ZE(e, t.state, t.location, t.replace);
    function r(s, o=!0) {
        o || n.pauseListeners(),
        history.go(s)
    }
    const i = ir({
        location: "",
        base: e,
        go: r,
        createHref: GE.bind(null, e)
    }, t, n);
    return Object.defineProperty(i, "location", {
        enumerable: !0,
        get: () => t.location.value
    }),
    Object.defineProperty(i, "state", {
        enumerable: !0,
        get: () => t.state.value
    }),
    i
}
function nC(e) {
    return typeof e == "string" || e && typeof e == "object"
}
function O0(e) {
    return typeof e == "string" || typeof e == "symbol"
}
const M0 = Symbol("");
var Jp;
(function(e) {
    e[e.aborted = 4] = "aborted",
    e[e.cancelled = 8] = "cancelled",
    e[e.duplicated = 16] = "duplicated"
}
)(Jp || (Jp = {}));
function hl(e, t) {
    return ir(new Error, {
        type: e,
        [M0]: !0
    }, t)
}
function vo(e, t) {
    return e instanceof Error && M0 in e && (t == null || !!(e.type & t))
}
const Zp = "[^/]+?"
  , rC = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
  , iC = /[.+*?^${}()[\]/\\]/g;
function sC(e, t) {
    const n = ir({}, rC, t)
      , r = [];
    let i = n.start ? "^" : "";
    const s = [];
    for (const p of e) {
        const h = p.length ? [] : [90];
        n.strict && !p.length && (i += "/");
        for (let g = 0; g < p.length; g++) {
            const m = p[g];
            let w = 40 + (n.sensitive ? .25 : 0);
            if (m.type === 0)
                g || (i += "/"),
                i += m.value.replace(iC, "\\$&"),
                w += 40;
            else if (m.type === 1) {
                const {value: E, repeatable: y, optional: R, regexp: P} = m;
                s.push({
                    name: E,
                    repeatable: y,
                    optional: R
                });
                const x = P || Zp;
                if (x !== Zp) {
                    w += 10;
                    try {
                        new RegExp(`(${x})`)
                    } catch (k) {
                        throw new Error(`Invalid custom RegExp for param "${E}" (${x}): ` + k.message)
                    }
                }
                let v = y ? `((?:${x})(?:/(?:${x}))*)` : `(${x})`;
                g || (v = R && p.length < 2 ? `(?:/${v})` : "/" + v),
                R && (v += "?"),
                i += v,
                w += 20,
                R && (w += -8),
                y && (w += -20),
                x === ".*" && (w += -50)
            }
            h.push(w)
        }
        r.push(h)
    }
    if (n.strict && n.end) {
        const p = r.length - 1;
        r[p][r[p].length - 1] += .7000000000000001
    }
    n.strict || (i += "/?"),
    n.end ? i += "$" : n.strict && !i.endsWith("/") && (i += "(?:/|$)");
    const o = new RegExp(i,n.sensitive ? "" : "i");
    function l(p) {
        const h = p.match(o)
          , g = {};
        if (!h)
            return null;
        for (let m = 1; m < h.length; m++) {
            const w = h[m] || ""
              , E = s[m - 1];
            g[E.name] = w && E.repeatable ? w.split("/") : w
        }
        return g
    }
    function u(p) {
        let h = ""
          , g = !1;
        for (const m of e) {
            (!g || !h.endsWith("/")) && (h += "/"),
            g = !1;
            for (const w of m)
                if (w.type === 0)
                    h += w.value;
                else if (w.type === 1) {
                    const {value: E, repeatable: y, optional: R} = w
                      , P = E in p ? p[E] : "";
                    if (Ws(P) && !y)
                        throw new Error(`Provided param "${E}" is an array but it is not repeatable (* or + modifiers)`);
                    const x = Ws(P) ? P.join("/") : P;
                    if (!x)
                        if (R)
                            m.length < 2 && (h.endsWith("/") ? h = h.slice(0, -1) : g = !0);
                        else
                            throw new Error(`Missing required param "${E}"`);
                    h += x
                }
        }
        return h || "/"
    }
    return {
        re: o,
        score: r,
        keys: s,
        parse: l,
        stringify: u
    }
}
function oC(e, t) {
    let n = 0;
    for (; n < e.length && n < t.length; ) {
        const r = t[n] - e[n];
        if (r)
            return r;
        n++
    }
    return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0
}
function L0(e, t) {
    let n = 0;
    const r = e.score
      , i = t.score;
    for (; n < r.length && n < i.length; ) {
        const s = oC(r[n], i[n]);
        if (s)
            return s;
        n++
    }
    if (Math.abs(i.length - r.length) === 1) {
        if (eg(r))
            return 1;
        if (eg(i))
            return -1
    }
    return i.length - r.length
}
function eg(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0
}
const aC = {
    type: 0,
    value: ""
}
  , lC = /[a-zA-Z0-9_]/;
function uC(e) {
    if (!e)
        return [[]];
    if (e === "/")
        return [[aC]];
    if (!e.startsWith("/"))
        throw new Error(`Invalid path "${e}"`);
    function t(w) {
        throw new Error(`ERR (${n})/"${p}": ${w}`)
    }
    let n = 0
      , r = n;
    const i = [];
    let s;
    function o() {
        s && i.push(s),
        s = []
    }
    let l = 0, u, p = "", h = "";
    function g() {
        p && (n === 0 ? s.push({
            type: 0,
            value: p
        }) : n === 1 || n === 2 || n === 3 ? (s.length > 1 && (u === "*" || u === "+") && t(`A repeatable param (${p}) must be alone in its segment. eg: '/:ids+.`),
        s.push({
            type: 1,
            value: p,
            regexp: h,
            repeatable: u === "*" || u === "+",
            optional: u === "*" || u === "?"
        })) : t("Invalid state to consume buffer"),
        p = "")
    }
    function m() {
        p += u
    }
    for (; l < e.length; ) {
        if (u = e[l++],
        u === "\\" && n !== 2) {
            r = n,
            n = 4;
            continue
        }
        switch (n) {
        case 0:
            u === "/" ? (p && g(),
            o()) : u === ":" ? (g(),
            n = 1) : m();
            break;
        case 4:
            m(),
            n = r;
            break;
        case 1:
            u === "(" ? n = 2 : lC.test(u) ? m() : (g(),
            n = 0,
            u !== "*" && u !== "?" && u !== "+" && l--);
            break;
        case 2:
            u === ")" ? h[h.length - 1] == "\\" ? h = h.slice(0, -1) + u : n = 3 : h += u;
            break;
        case 3:
            g(),
            n = 0,
            u !== "*" && u !== "?" && u !== "+" && l--,
            h = "";
            break;
        default:
            t("Unknown state");
            break
        }
    }
    return n === 2 && t(`Unfinished custom RegExp for param "${p}"`),
    g(),
    o(),
    i
}
function cC(e, t, n) {
    const r = sC(uC(e.path), n)
      , i = ir(r, {
        record: e,
        parent: t,
        children: [],
        alias: []
    });
    return t && !i.record.aliasOf == !t.record.aliasOf && t.children.push(i),
    i
}
function fC(e, t) {
    const n = []
      , r = new Map;
    t = ig({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t);
    function i(g) {
        return r.get(g)
    }
    function s(g, m, w) {
        const E = !w
          , y = ng(g);
        y.aliasOf = w && w.record;
        const R = ig(t, g)
          , P = [y];
        if ("alias"in g) {
            const k = typeof g.alias == "string" ? [g.alias] : g.alias;
            for (const S of k)
                P.push(ng(ir({}, y, {
                    components: w ? w.record.components : y.components,
                    path: S,
                    aliasOf: w ? w.record : y
                })))
        }
        let x, v;
        for (const k of P) {
            const {path: S} = k;
            if (m && S[0] !== "/") {
                const W = m.record.path
                  , K = W[W.length - 1] === "/" ? "" : "/";
                k.path = m.record.path + (S && K + S)
            }
            if (x = cC(k, m, R),
            w ? w.alias.push(x) : (v = v || x,
            v !== x && v.alias.push(x),
            E && g.name && !rg(x) && o(g.name)),
            F0(x) && u(x),
            y.children) {
                const W = y.children;
                for (let K = 0; K < W.length; K++)
                    s(W[K], x, w && w.children[K])
            }
            w = w || x
        }
        return v ? () => {
            o(v)
        }
        : iu
    }
    function o(g) {
        if (O0(g)) {
            const m = r.get(g);
            m && (r.delete(g),
            n.splice(n.indexOf(m), 1),
            m.children.forEach(o),
            m.alias.forEach(o))
        } else {
            const m = n.indexOf(g);
            m > -1 && (n.splice(m, 1),
            g.record.name && r.delete(g.record.name),
            g.children.forEach(o),
            g.alias.forEach(o))
        }
    }
    function l() {
        return n
    }
    function u(g) {
        const m = pC(g, n);
        n.splice(m, 0, g),
        g.record.name && !rg(g) && r.set(g.record.name, g)
    }
    function p(g, m) {
        let w, E = {}, y, R;
        if ("name"in g && g.name) {
            if (w = r.get(g.name),
            !w)
                throw hl(1, {
                    location: g
                });
            R = w.record.name,
            E = ir(tg(m.params, w.keys.filter(v => !v.optional).concat(w.parent ? w.parent.keys.filter(v => v.optional) : []).map(v => v.name)), g.params && tg(g.params, w.keys.map(v => v.name))),
            y = w.stringify(E)
        } else if (g.path != null)
            y = g.path,
            w = n.find(v => v.re.test(y)),
            w && (E = w.parse(y),
            R = w.record.name);
        else {
            if (w = m.name ? r.get(m.name) : n.find(v => v.re.test(m.path)),
            !w)
                throw hl(1, {
                    location: g,
                    currentLocation: m
                });
            R = w.record.name,
            E = ir({}, m.params, g.params),
            y = w.stringify(E)
        }
        const P = [];
        let x = w;
        for (; x; )
            P.unshift(x.record),
            x = x.parent;
        return {
            name: R,
            path: y,
            params: E,
            matched: P,
            meta: hC(P)
        }
    }
    e.forEach(g => s(g));
    function h() {
        n.length = 0,
        r.clear()
    }
    return {
        addRoute: s,
        resolve: p,
        removeRoute: o,
        clearRoutes: h,
        getRoutes: l,
        getRecordMatcher: i
    }
}
function tg(e, t) {
    const n = {};
    for (const r of t)
        r in e && (n[r] = e[r]);
    return n
}
function ng(e) {
    const t = {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: e.aliasOf,
        beforeEnter: e.beforeEnter,
        props: dC(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in e ? e.components || null : e.component && {
            default: e.component
        }
    };
    return Object.defineProperty(t, "mods", {
        value: {}
    }),
    t
}
function dC(e) {
    const t = {}
      , n = e.props || !1;
    if ("component"in e)
        t.default = n;
    else
        for (const r in e.components)
            t[r] = typeof n == "object" ? n[r] : n;
    return t
}
function rg(e) {
    for (; e; ) {
        if (e.record.aliasOf)
            return !0;
        e = e.parent
    }
    return !1
}
function hC(e) {
    return e.reduce( (t, n) => ir(t, n.meta), {})
}
function ig(e, t) {
    const n = {};
    for (const r in e)
        n[r] = r in t ? t[r] : e[r];
    return n
}
function pC(e, t) {
    let n = 0
      , r = t.length;
    for (; n !== r; ) {
        const s = n + r >> 1;
        L0(e, t[s]) < 0 ? r = s : n = s + 1
    }
    const i = gC(e);
    return i && (r = t.lastIndexOf(i, r - 1)),
    r
}
function gC(e) {
    let t = e;
    for (; t = t.parent; )
        if (F0(t) && L0(e, t) === 0)
            return t
}
function F0({record: e}) {
    return !!(e.name || e.components && Object.keys(e.components).length || e.redirect)
}
function _C(e) {
    const t = {};
    if (e === "" || e === "?")
        return t;
    const r = (e[0] === "?" ? e.slice(1) : e).split("&");
    for (let i = 0; i < r.length; ++i) {
        const s = r[i].replace(S0, " ")
          , o = s.indexOf("=")
          , l = yu(o < 0 ? s : s.slice(0, o))
          , u = o < 0 ? null : yu(s.slice(o + 1));
        if (l in t) {
            let p = t[l];
            Ws(p) || (p = t[l] = [p]),
            p.push(u)
        } else
            t[l] = u
    }
    return t
}
function sg(e) {
    let t = "";
    for (let n in e) {
        const r = e[n];
        if (n = IE(n),
        r == null) {
            r !== void 0 && (t += (t.length ? "&" : "") + n);
            continue
        }
        (Ws(r) ? r.map(s => s && Rd(s)) : [r && Rd(r)]).forEach(s => {
            s !== void 0 && (t += (t.length ? "&" : "") + n,
            s != null && (t += "=" + s))
        }
        )
    }
    return t
}
function mC(e) {
    const t = {};
    for (const n in e) {
        const r = e[n];
        r !== void 0 && (t[n] = Ws(r) ? r.map(i => i == null ? null : "" + i) : r == null ? r : "" + r)
    }
    return t
}
const yC = Symbol("")
  , og = Symbol("")
  , df = Symbol("")
  , kh = Symbol("")
  , Md = Symbol("");
function Il() {
    let e = [];
    function t(r) {
        return e.push(r),
        () => {
            const i = e.indexOf(r);
            i > -1 && e.splice(i, 1)
        }
    }
    function n() {
        e = []
    }
    return {
        add: t,
        list: () => e.slice(),
        reset: n
    }
}
function Zo(e, t, n, r, i, s=o => o()) {
    const o = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []);
    return () => new Promise( (l, u) => {
        const p = m => {
            m === !1 ? u(hl(4, {
                from: n,
                to: t
            })) : m instanceof Error ? u(m) : nC(m) ? u(hl(2, {
                from: t,
                to: m
            })) : (o && r.enterCallbacks[i] === o && typeof m == "function" && o.push(m),
            l())
        }
          , h = s( () => e.call(r && r.instances[i], t, n, p));
        let g = Promise.resolve(h);
        e.length < 3 && (g = g.then(p)),
        g.catch(m => u(m))
    }
    )
}
function Hf(e, t, n, r, i=s => s()) {
    const s = [];
    for (const o of e)
        for (const l in o.components) {
            let u = o.components[l];
            if (!(t !== "beforeRouteEnter" && !o.instances[l]))
                if (C0(u)) {
                    const h = (u.__vccOpts || u)[t];
                    h && s.push(Zo(h, n, r, o, l, i))
                } else {
                    let p = u();
                    s.push( () => p.then(h => {
                        if (!h)
                            throw new Error(`Couldn't resolve component "${l}" at "${o.path}"`);
                        const g = xE(h) ? h.default : h;
                        o.mods[l] = h,
                        o.components[l] = g;
                        const w = (g.__vccOpts || g)[t];
                        return w && Zo(w, n, r, o, l, i)()
                    }
                    ))
                }
        }
    return s
}
function ag(e) {
    const t = pr(df)
      , n = pr(kh)
      , r = zt( () => {
        const u = Re(e.to);
        return t.resolve(u)
    }
    )
      , i = zt( () => {
        const {matched: u} = r.value
          , {length: p} = u
          , h = u[p - 1]
          , g = n.matched;
        if (!h || !g.length)
            return -1;
        const m = g.findIndex(dl.bind(null, h));
        if (m > -1)
            return m;
        const w = lg(u[p - 2]);
        return p > 1 && lg(h) === w && g[g.length - 1].path !== w ? g.findIndex(dl.bind(null, u[p - 2])) : m
    }
    )
      , s = zt( () => i.value > -1 && EC(n.params, r.value.params))
      , o = zt( () => i.value > -1 && i.value === n.matched.length - 1 && A0(n.params, r.value.params));
    function l(u={}) {
        if (DC(u)) {
            const p = t[Re(e.replace) ? "replace" : "push"](Re(e.to)).catch(iu);
            return e.viewTransition && typeof document < "u" && "startViewTransition"in document && document.startViewTransition( () => p),
            p
        }
        return Promise.resolve()
    }
    return {
        route: r,
        href: zt( () => r.value.href),
        isActive: s,
        isExactActive: o,
        navigate: l
    }
}
function vC(e) {
    return e.length === 1 ? e[0] : e
}
const bC = Mn({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        },
        viewTransition: Boolean
    },
    useLink: ag,
    setup(e, {slots: t}) {
        const n = Gr(ag(e))
          , {options: r} = pr(df)
          , i = zt( () => ({
            [ug(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
            [ug(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
        }));
        return () => {
            const s = t.default && vC(t.default(n));
            return e.custom ? s : ar("a", {
                "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: i.value
            }, s)
        }
    }
})
  , wC = bC;
function DC(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
            const t = e.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(t))
                return
        }
        return e.preventDefault && e.preventDefault(),
        !0
    }
}
function EC(e, t) {
    for (const n in t) {
        const r = t[n]
          , i = e[n];
        if (typeof r == "string") {
            if (r !== i)
                return !1
        } else if (!Ws(i) || i.length !== r.length || r.some( (s, o) => s !== i[o]))
            return !1
    }
    return !0
}
function lg(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const ug = (e, t, n) => e ?? t ?? n
  , CC = Mn({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(e, {attrs: t, slots: n}) {
        const r = pr(Md)
          , i = zt( () => e.route || r.value)
          , s = pr(og, 0)
          , o = zt( () => {
            let p = Re(s);
            const {matched: h} = i.value;
            let g;
            for (; (g = h[p]) && !g.components; )
                p++;
            return p
        }
        )
          , l = zt( () => i.value.matched[o.value]);
        ns(og, zt( () => o.value + 1)),
        ns(yC, l),
        ns(Md, i);
        const u = Ut();
        return tr( () => [u.value, l.value, e.name], ([p,h,g], [m,w,E]) => {
            h && (h.instances[g] = p,
            w && w !== h && p && p === m && (h.leaveGuards.size || (h.leaveGuards = w.leaveGuards),
            h.updateGuards.size || (h.updateGuards = w.updateGuards))),
            p && h && (!w || !dl(h, w) || !m) && (h.enterCallbacks[g] || []).forEach(y => y(p))
        }
        , {
            flush: "post"
        }),
        () => {
            const p = i.value
              , h = e.name
              , g = l.value
              , m = g && g.components[h];
            if (!m)
                return cg(n.default, {
                    Component: m,
                    route: p
                });
            const w = g.props[h]
              , E = w ? w === !0 ? p.params : typeof w == "function" ? w(p) : w : null
              , R = ar(m, ir({}, E, t, {
                onVnodeUnmounted: P => {
                    P.component.isUnmounted && (g.instances[h] = null)
                }
                ,
                ref: u
            }));
            return cg(n.default, {
                Component: R,
                route: p
            }) || R
        }
    }
});
function cg(e, t) {
    if (!e)
        return null;
    const n = e(t);
    return n.length === 1 ? n[0] : n
}
const I0 = CC;
function xC(e) {
    const t = fC(e.routes, e)
      , n = e.parseQuery || _C
      , r = e.stringifyQuery || sg
      , i = e.history
      , s = Il()
      , o = Il()
      , l = Il()
      , u = qr(xs);
    let p = xs;
    Ya && e.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const h = $f.bind(null, he => "" + he)
      , g = $f.bind(null, $E)
      , m = $f.bind(null, yu);
    function w(he, ve) {
        let ae, ze;
        return O0(he) ? (ae = t.getRecordMatcher(he),
        ze = ve) : ze = he,
        t.addRoute(ze, ae)
    }
    function E(he) {
        const ve = t.getRecordMatcher(he);
        ve && t.removeRoute(ve)
    }
    function y() {
        return t.getRoutes().map(he => he.record)
    }
    function R(he) {
        return !!t.getRecordMatcher(he)
    }
    function P(he, ve) {
        if (ve = ir({}, ve || u.value),
        typeof he == "string") {
            const $ = Bf(n, he, ve.path)
              , de = t.resolve({
                path: $.path
            }, ve)
              , Me = i.createHref($.fullPath);
            return ir($, de, {
                params: m(de.params),
                hash: yu($.hash),
                redirectedFrom: void 0,
                href: Me
            })
        }
        let ae;
        if (he.path != null)
            ae = ir({}, he, {
                path: Bf(n, he.path, ve.path).path
            });
        else {
            const $ = ir({}, he.params);
            for (const de in $)
                $[de] == null && delete $[de];
            ae = ir({}, he, {
                params: g($)
            }),
            ve.params = g(ve.params)
        }
        const ze = t.resolve(ae, ve)
          , Se = he.hash || "";
        ze.params = h(m(ze.params));
        const Je = VE(r, ir({}, he, {
            hash: FE(Se),
            path: ze.path
        }))
          , I = i.createHref(Je);
        return ir({
            fullPath: Je,
            hash: Se,
            query: r === sg ? mC(he.query) : he.query || {}
        }, ze, {
            redirectedFrom: void 0,
            href: I
        })
    }
    function x(he) {
        return typeof he == "string" ? Bf(n, he, u.value.path) : ir({}, he)
    }
    function v(he, ve) {
        if (p !== he)
            return hl(8, {
                from: ve,
                to: he
            })
    }
    function k(he) {
        return K(he)
    }
    function S(he) {
        return k(ir(x(he), {
            replace: !0
        }))
    }
    function W(he) {
        const ve = he.matched[he.matched.length - 1];
        if (ve && ve.redirect) {
            const {redirect: ae} = ve;
            let ze = typeof ae == "function" ? ae(he) : ae;
            return typeof ze == "string" && (ze = ze.includes("?") || ze.includes("#") ? ze = x(ze) : {
                path: ze
            },
            ze.params = {}),
            ir({
                query: he.query,
                hash: he.hash,
                params: ze.path != null ? {} : he.params
            }, ze)
        }
    }
    function K(he, ve) {
        const ae = p = P(he)
          , ze = u.value
          , Se = he.state
          , Je = he.force
          , I = he.replace === !0
          , $ = W(ae);
        if ($)
            return K(ir(x($), {
                state: typeof $ == "object" ? ir({}, Se, $.state) : Se,
                force: Je,
                replace: I
            }), ve || ae);
        const de = ae;
        de.redirectedFrom = ve;
        let Me;
        return !Je && jE(r, ze, ae) && (Me = hl(16, {
            to: de,
            from: ze
        }),
        qe(ze, ze, !0, !1)),
        (Me ? Promise.resolve(Me) : ge(de, ze)).catch(Te => vo(Te) ? vo(Te, 2) ? Te : Ze(Te) : se(Te, de, ze)).then(Te => {
            if (Te) {
                if (vo(Te, 2))
                    return K(ir({
                        replace: I
                    }, x(Te.to), {
                        state: typeof Te.to == "object" ? ir({}, Se, Te.to.state) : Se,
                        force: Je
                    }), ve || de)
            } else
                Te = re(de, ze, !0, I, Se);
            return J(de, ze, Te),
            Te
        }
        )
    }
    function be(he, ve) {
        const ae = v(he, ve);
        return ae ? Promise.reject(ae) : Promise.resolve()
    }
    function fe(he) {
        const ve = yt.values().next().value;
        return ve && typeof ve.runWithContext == "function" ? ve.runWithContext(he) : he()
    }
    function ge(he, ve) {
        let ae;
        const [ze,Se,Je] = SC(he, ve);
        ae = Hf(ze.reverse(), "beforeRouteLeave", he, ve);
        for (const $ of ze)
            $.leaveGuards.forEach(de => {
                ae.push(Zo(de, he, ve))
            }
            );
        const I = be.bind(null, he, ve);
        return ae.push(I),
        Tt(ae).then( () => {
            ae = [];
            for (const $ of s.list())
                ae.push(Zo($, he, ve));
            return ae.push(I),
            Tt(ae)
        }
        ).then( () => {
            ae = Hf(Se, "beforeRouteUpdate", he, ve);
            for (const $ of Se)
                $.updateGuards.forEach(de => {
                    ae.push(Zo(de, he, ve))
                }
                );
            return ae.push(I),
            Tt(ae)
        }
        ).then( () => {
            ae = [];
            for (const $ of Je)
                if ($.beforeEnter)
                    if (Ws($.beforeEnter))
                        for (const de of $.beforeEnter)
                            ae.push(Zo(de, he, ve));
                    else
                        ae.push(Zo($.beforeEnter, he, ve));
            return ae.push(I),
            Tt(ae)
        }
        ).then( () => (he.matched.forEach($ => $.enterCallbacks = {}),
        ae = Hf(Je, "beforeRouteEnter", he, ve, fe),
        ae.push(I),
        Tt(ae))).then( () => {
            ae = [];
            for (const $ of o.list())
                ae.push(Zo($, he, ve));
            return ae.push(I),
            Tt(ae)
        }
        ).catch($ => vo($, 8) ? $ : Promise.reject($))
    }
    function J(he, ve, ae) {
        l.list().forEach(ze => fe( () => ze(he, ve, ae)))
    }
    function re(he, ve, ae, ze, Se) {
        const Je = v(he, ve);
        if (Je)
            return Je;
        const I = ve === xs
          , $ = Ya ? history.state : {};
        ae && (ze || I ? i.replace(he.fullPath, ir({
            scroll: I && $ && $.scroll
        }, Se)) : i.push(he.fullPath, Se)),
        u.value = he,
        qe(he, ve, ae, I),
        Ze()
    }
    let ee;
    function Y() {
        ee || (ee = i.listen( (he, ve, ae) => {
            if (!At.listening)
                return;
            const ze = P(he)
              , Se = W(ze);
            if (Se) {
                K(ir(Se, {
                    replace: !0,
                    force: !0
                }), ze).catch(iu);
                return
            }
            p = ze;
            const Je = u.value;
            Ya && XE(Xp(Je.fullPath, ae.delta), ff()),
            ge(ze, Je).catch(I => vo(I, 12) ? I : vo(I, 2) ? (K(ir(x(I.to), {
                force: !0
            }), ze).then($ => {
                vo($, 20) && !ae.delta && ae.type === vu.pop && i.go(-1, !1)
            }
            ).catch(iu),
            Promise.reject()) : (ae.delta && i.go(-ae.delta, !1),
            se(I, ze, Je))).then(I => {
                I = I || re(ze, Je, !1),
                I && (ae.delta && !vo(I, 8) ? i.go(-ae.delta, !1) : ae.type === vu.pop && vo(I, 20) && i.go(-1, !1)),
                J(ze, Je, I)
            }
            ).catch(iu)
        }
        ))
    }
    let Z = Il(), Q = Il(), ue;
    function se(he, ve, ae) {
        Ze(he);
        const ze = Q.list();
        return ze.length ? ze.forEach(Se => Se(he, ve, ae)) : console.error(he),
        Promise.reject(he)
    }
    function ye() {
        return ue && u.value !== xs ? Promise.resolve() : new Promise( (he, ve) => {
            Z.add([he, ve])
        }
        )
    }
    function Ze(he) {
        return ue || (ue = !he,
        Y(),
        Z.list().forEach( ([ve,ae]) => he ? ae(he) : ve()),
        Z.reset()),
        he
    }
    function qe(he, ve, ae, ze) {
        const {scrollBehavior: Se} = e;
        if (!Ya || !Se)
            return Promise.resolve();
        const Je = !ae && QE(Xp(he.fullPath, 0)) || (ze || !ae) && history.state && history.state.scroll || null;
        return Ci().then( () => Se(he, ve, Je)).then(I => I && KE(I)).catch(I => se(I, he, ve))
    }
    const nt = he => i.go(he);
    let mt;
    const yt = new Set
      , At = {
        currentRoute: u,
        listening: !0,
        addRoute: w,
        removeRoute: E,
        clearRoutes: t.clearRoutes,
        hasRoute: R,
        getRoutes: y,
        resolve: P,
        options: e,
        push: k,
        replace: S,
        go: nt,
        back: () => nt(-1),
        forward: () => nt(1),
        beforeEach: s.add,
        beforeResolve: o.add,
        afterEach: l.add,
        onError: Q.add,
        isReady: ye,
        install(he) {
            const ve = this;
            he.component("RouterLink", wC),
            he.component("RouterView", I0),
            he.config.globalProperties.$router = ve,
            Object.defineProperty(he.config.globalProperties, "$route", {
                enumerable: !0,
                get: () => Re(u)
            }),
            Ya && !mt && u.value === xs && (mt = !0,
            k(i.location).catch(Se => {}
            ));
            const ae = {};
            for (const Se in xs)
                Object.defineProperty(ae, Se, {
                    get: () => u.value[Se],
                    enumerable: !0
                });
            he.provide(df, ve),
            he.provide(kh, Ts(ae)),
            he.provide(Md, u);
            const ze = he.unmount;
            yt.add(he),
            he.unmount = function() {
                yt.delete(he),
                yt.size < 1 && (p = xs,
                ee && ee(),
                ee = null,
                u.value = xs,
                mt = !1,
                ue = !1),
                ze()
            }
        }
    };
    function Tt(he) {
        return he.reduce( (ve, ae) => ve.then( () => fe(ae)), Promise.resolve())
    }
    return At
}
function SC(e, t) {
    const n = []
      , r = []
      , i = []
      , s = Math.max(t.matched.length, e.matched.length);
    for (let o = 0; o < s; o++) {
        const l = t.matched[o];
        l && (e.matched.find(p => dl(p, l)) ? r.push(l) : n.push(l));
        const u = e.matched[o];
        u && (t.matched.find(p => dl(p, u)) || i.push(u))
    }
    return [n, r, i]
}
function TC() {
    return pr(df)
}
function PC(e) {
    return pr(kh)
}
const kC = /(:\w+)\([^)]+\)/g
  , AC = /(:\w+)[?+*]/g
  , RC = /:\w+/g
  , OC = (e, t) => t.path.replace(kC, "$1").replace(AC, "$1").replace(RC, n => {
    var r;
    return ((r = e.params[n.slice(1)]) == null ? void 0 : r.toString()) || ""
}
)
  , Ld = (e, t) => {
    const n = e.route.matched.find(i => {
        var s;
        return ((s = i.components) == null ? void 0 : s.default) === e.Component.type
    }
    )
      , r = t ?? (n == null ? void 0 : n.meta.key) ?? (n && OC(e.route, n));
    return typeof r == "function" ? r(e.route) : r
}
  , MC = (e, t) => ({
    default: () => e ? ar(P_, e === !0 ? {} : e, t) : t
});
function Ah(e) {
    return Array.isArray(e) ? e : [e]
}
const Cs = null
  , tc = {}
  , Vf = [{
    name: "about",
    path: "/about",
    component: () => Vt( () => import("./CbZ2X_fh.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]), import.meta.url)
}, {
    name: "index",
    path: "/",
    component: () => Vt( () => import("./BuBxfxJl.js"), __vite__mapDeps([20, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21]), import.meta.url)
}, {
    name: "press",
    path: "/press",
    component: () => Vt( () => import("./BCRGQsX2.js"), __vite__mapDeps([22, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 23]), import.meta.url)
}, {
    name: "config",
    path: "/config",
    component: () => Vt( () => import("./BxQ8Vkc_.js"), __vite__mapDeps([24, 25]), import.meta.url)
}, {
    name: "system",
    path: "/system",
    component: () => Vt( () => import("./BIWO7QxN.js"), __vite__mapDeps([26, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 27]), import.meta.url)
}, {
    name: "careers",
    path: "/careers",
    component: () => Vt( () => import("./BbrcitPk.js"), __vite__mapDeps([28, 29, 30, 31, 32, 33, 34, 35, 36, 11, 12, 37, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 13, 14, 15, 16, 17, 18, 38]), import.meta.url)
}, {
    name: "contact",
    path: "/contact",
    component: () => Vt( () => import("./C-BRwMMA.js"), __vite__mapDeps([39, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 40]), import.meta.url)
}, {
    name: "security",
    path: "/security",
    component: () => Vt( () => import("./Bzlz6xBK.js"), __vite__mapDeps([41, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 42]), import.meta.url)
}, {
    name: "slug",
    path: "/:slug(.*)*",
    component: () => Vt( () => import("./CkF0v0bl.js"), __vite__mapDeps([43, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]), import.meta.url)
}, {
    name: "blog-slug",
    path: "/blog/:slug()",
    component: () => Vt( () => import("./uf-KtDSq.js"), __vite__mapDeps([44, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18]), import.meta.url)
}, {
    name: "privacy-policy",
    path: "/privacy-policy",
    component: () => Vt( () => import("./Dtqi9rxa.js"), __vite__mapDeps([45, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 46]), import.meta.url)
}, {
    name: "terms-of-service",
    path: "/terms-of-service",
    component: () => Vt( () => import("./Br5iTxUS.js"), __vite__mapDeps([47, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 48]), import.meta.url)
}, {
    name: Cs == null ? void 0 : Cs.name,
    path: "/home",
    component: tc
}, {
    name: Cs == null ? void 0 : Cs.name,
    path: "/global/*",
    component: tc
}, {
    name: Cs == null ? void 0 : Cs.name,
    path: "/authors/*",
    component: tc
}, {
    name: Cs == null ? void 0 : Cs.name,
    path: "/clipboard",
    component: tc
}]
  , N0 = (e, t) => ({
    default: () => {
        var n;
        return e ? ar(bm, e === !0 ? {} : e, t) : (n = t.default) == null ? void 0 : n.call(t)
    }
})
  , LC = /(:\w+)\([^)]+\)/g
  , FC = /(:\w+)[?+*]/g
  , IC = /:\w+/g;
function fg(e) {
    const t = (e == null ? void 0 : e.meta.key) ?? e.path.replace(LC, "$1").replace(FC, "$1").replace(IC, n => {
        var r;
        return ((r = e.params[n.slice(1)]) == null ? void 0 : r.toString()) || ""
    }
    );
    return typeof t == "function" ? t(e) : t
}
function NC(e, t) {
    return e === t || t === xs ? !1 : fg(e) !== fg(t) ? !0 : !e.matched.every( (r, i) => {
        var s, o;
        return r.components && r.components.default === ((o = (s = t.matched[i]) == null ? void 0 : s.components) == null ? void 0 : o.default)
    }
    )
}
const $C = {
    scrollBehavior(e, t, n) {
        var u;
        const r = Tr()
          , i = ((u = rs().options) == null ? void 0 : u.scrollBehaviorType) ?? "auto";
        if (e.path === t.path)
            return t.hash && !e.hash ? {
                left: 0,
                top: 0
            } : e.hash ? {
                el: e.hash,
                top: $0(e.hash),
                behavior: i
            } : !1;
        if ((typeof e.meta.scrollToTop == "function" ? e.meta.scrollToTop(e, t) : e.meta.scrollToTop) === !1)
            return !1;
        let o = n || void 0;
        !o && NC(e, t) && (o = {
            left: 0,
            top: 0
        });
        const l = r._runningTransition ? "page:transition:finish" : "page:loading:end";
        return new Promise(p => {
            if (t === xs) {
                p(dg(e, "instant", o));
                return
            }
            r.hooks.hookOnce(l, () => {
                requestAnimationFrame( () => p(dg(e, "instant", o)))
            }
            )
        }
        )
    }
};
function $0(e) {
    try {
        const t = document.querySelector(e);
        if (t)
            return (Number.parseFloat(getComputedStyle(t).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle(document.documentElement).scrollPaddingTop) || 0)
    } catch {}
    return 0
}
function dg(e, t, n) {
    return n || (e.hash ? {
        el: e.hash,
        top: $0(e.hash),
        behavior: t
    } : {
        left: 0,
        top: 0,
        behavior: t
    })
}
const BC = {
    hashMode: !1,
    scrollBehaviorType: "auto"
}
  , eo = {
    ...BC,
    ...$C
}
  , HC = async (e, t) => {
    var o;
    let n, r;
    if (!((o = e.meta) != null && o.validate))
        return;
    const i = ([n,r] = il( () => Promise.resolve(e.meta.validate(e))),
    n = await n,
    r(),
    n);
    if (i === !0)
        return;
    const s = ra({
        fatal: !0,
        statusCode: i && i.statusCode || 404,
        statusMessage: i && i.statusMessage || `Page Not Found: ${e.fullPath}`,
        data: {
            path: e.fullPath
        }
    });
    return typeof window < "u" && window.history.pushState({}, "", t.fullPath),
    s
}
  , VC = async e => {
    let t, n;
    const r = ([t,n] = il( () => Sh({
        path: e.path
    })),
    t = await t,
    n(),
    t);
    if (r.redirect)
        return ao(r.redirect, {
            acceptRelative: !0
        }) ? (window.location.href = r.redirect,
        !1) : r.redirect
}
  , jC = [HC, VC]
  , ou = {};
function zC(e, t, n) {
    const {pathname: r, search: i, hash: s} = t
      , o = e.indexOf("#");
    if (o > -1) {
        const p = s.includes(e.slice(o)) ? e.slice(o).length : 1;
        let h = s.slice(p);
        return h[0] !== "/" && (h = "/" + h),
        Sp(h, "")
    }
    const l = Sp(r, e)
      , u = !n || gw(l, n) ? l : n;
    return u + (u.includes("?") ? "" : i) + s
}
const UC = ki({
    name: "nuxt:router",
    enforce: "pre",
    async setup(e) {
        var R;
        let t, n, r = qs().app.baseURL;
        const i = ((R = eo.history) == null ? void 0 : R.call(eo, r)) ?? tC(r)
          , s = eo.routes ? ([t,n] = il( () => eo.routes(Vf)),
        t = await t,
        n(),
        t ?? Vf) : Vf;
        let o;
        const l = xC({
            ...eo,
            scrollBehavior: (P, x, v) => {
                if (x === xs) {
                    o = v;
                    return
                }
                if (eo.scrollBehavior) {
                    if (l.options.scrollBehavior = eo.scrollBehavior,
                    "scrollRestoration"in window.history) {
                        const k = l.beforeEach( () => {
                            k(),
                            window.history.scrollRestoration = "manual"
                        }
                        )
                    }
                    return eo.scrollBehavior(P, xs, o || v)
                }
            }
            ,
            history: i,
            routes: s
        });
        "scrollRestoration"in window.history && (window.history.scrollRestoration = "auto"),
        e.vueApp.use(l);
        const u = qr(l.currentRoute.value);
        l.afterEach( (P, x) => {
            u.value = x
        }
        ),
        Object.defineProperty(e.vueApp.config.globalProperties, "previousRoute", {
            get: () => u.value
        });
        const p = zC(r, window.location, e.payload.path)
          , h = qr(l.currentRoute.value)
          , g = () => {
            h.value = l.currentRoute.value
        }
        ;
        e.hook("page:finish", g),
        l.afterEach( (P, x) => {
            var v, k, S, W;
            ((k = (v = P.matched[0]) == null ? void 0 : v.components) == null ? void 0 : k.default) === ((W = (S = x.matched[0]) == null ? void 0 : S.components) == null ? void 0 : W.default) && g()
        }
        );
        const m = {};
        for (const P in h.value)
            Object.defineProperty(m, P, {
                get: () => h.value[P],
                enumerable: !0
            });
        e._route = Ts(m),
        e._middleware || (e._middleware = {
            global: [],
            named: {}
        });
        const w = uf();
        l.afterEach(async (P, x, v) => {
            delete e._processingMiddleware,
            !e.isHydrating && w.value && await e.runWithContext(dD),
            v && await e.callHook("page:loading:end")
        }
        );
        try {
            [t,n] = il( () => l.isReady()),
            await t,
            n()
        } catch (P) {
            [t,n] = il( () => e.runWithContext( () => xa(P))),
            await t,
            n()
        }
        const E = p !== l.currentRoute.value.fullPath ? l.resolve(p) : l.currentRoute.value;
        g();
        const y = e.payload.state._layout;
        return l.beforeEach(async (P, x) => {
            var v;
            await e.callHook("page:loading:start"),
            P.meta = Gr(P.meta),
            e.isHydrating && y && !Ao(P.meta.layout) && (P.meta.layout = y),
            e._processingMiddleware = !0;
            {
                const k = new Set([...jC, ...e._middleware.global]);
                for (const S of P.matched) {
                    const W = S.meta.middleware;
                    if (W)
                        for (const K of Ah(W))
                            k.add(K)
                }
                {
                    const S = await e.runWithContext( () => Sh({
                        path: P.path
                    }));
                    if (S.appMiddleware)
                        for (const W in S.appMiddleware)
                            S.appMiddleware[W] ? k.add(W) : k.delete(W)
                }
                for (const S of k) {
                    const W = typeof S == "string" ? e._middleware.named[S] || await ((v = ou[S]) == null ? void 0 : v.call(ou).then(K => K.default || K)) : S;
                    if (!W)
                        throw new Error(`Unknown route middleware: '${S}'.`);
                    try {
                        const K = await e.runWithContext( () => W(P, x));
                        if (!e.payload.serverRendered && e.isHydrating && (K === !1 || K instanceof Error)) {
                            const be = K || ra({
                                statusCode: 404,
                                statusMessage: `Page Not Found: ${p}`
                            });
                            return await e.runWithContext( () => xa(be)),
                            !1
                        }
                        if (K === !0)
                            continue;
                        if (K === !1)
                            return K;
                        if (K)
                            return o0(K) && K.fatal && await e.runWithContext( () => xa(K)),
                            K
                    } catch (K) {
                        const be = ra(K);
                        return be.fatal && await e.runWithContext( () => xa(be)),
                        be
                    }
                }
            }
        }
        ),
        l.onError(async () => {
            delete e._processingMiddleware,
            await e.callHook("page:loading:end")
        }
        ),
        l.afterEach(async (P, x) => {
            P.matched.length === 0 && await e.runWithContext( () => xa(ra({
                statusCode: 404,
                fatal: !1,
                statusMessage: `Page not found: ${P.fullPath}`,
                data: {
                    path: P.fullPath
                }
            })))
        }
        ),
        e.hooks.hookOnce("app:created", async () => {
            try {
                "name"in E && (E.name = void 0),
                await l.replace({
                    ...E,
                    force: !0
                }),
                l.options.scrollBehavior = eo.scrollBehavior
            } catch (P) {
                await e.runWithContext( () => xa(P))
            }
        }
        ),
        {
            provide: {
                router: l
            }
        }
    }
})
  , B0 = Symbol.for("nuxt:client-only")
  , TA = Mn({
    name: "ClientOnly",
    inheritAttrs: !1,
    props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"],
    setup(e, {slots: t, attrs: n}) {
        const r = Ut(!1);
        xi( () => {
            r.value = !0
        }
        );
        const i = Or();
        return i && (i._nuxtClientOnly = !0),
        ns(B0, !0),
        s => {
            var p;
            if (r.value)
                return (p = t.default) == null ? void 0 : p.call(t);
            const o = t.fallback || t.placeholder;
            if (o)
                return o();
            const l = s.fallback || s.placeholder || ""
              , u = s.fallbackTag || s.placeholderTag || "span";
            return Cn(u, n, l)
        }
    }
})
  , Fd = globalThis.requestIdleCallback || (e => {
    const t = Date.now()
      , n = {
        didTimeout: !1,
        timeRemaining: () => Math.max(0, 50 - (Date.now() - t))
    };
    return setTimeout( () => {
        e(n)
    }
    , 1)
}
)
  , WC = globalThis.cancelIdleCallback || (e => {
    clearTimeout(e)
}
)
  , Au = e => {
    const t = Tr();
    t.isHydrating ? t.hooks.hookOnce("app:suspense:resolve", () => {
        Fd( () => e())
    }
    ) : Fd( () => e())
}
  , qC = e => e === "defer" || e === !1;
function GC(...e) {
    var y;
    const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0;
    typeof e[0] != "string" && typeof e[0] != "object" && !(typeof e[0] == "function" && typeof e[1] == "function") && e.unshift(t);
    let[n,r,i={}] = e;
    const s = zt( () => Qr(n));
    if (typeof s.value != "string")
        throw new TypeError("[nuxt] [useAsyncData] key must be a string.");
    if (typeof r != "function")
        throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");
    const o = Tr()
      , l = () => io.value
      , u = (R, P, x) => {
        if (P.isHydrating)
            return P.payload.data[R];
        if (x.cause !== "refresh:manual" && x.cause !== "refresh:hook")
            return P.static.data[R]
    }
    ;
    i.server ?? (i.server = !0),
    i.default ?? (i.default = l),
    i.getCachedData ?? (i.getCachedData = u),
    i.lazy ?? (i.lazy = !1),
    i.immediate ?? (i.immediate = !0),
    i.deep ?? (i.deep = io.deep),
    i.dedupe ?? (i.dedupe = "cancel"),
    i._functionName,
    o._asyncData[s.value];
    const p = i.getCachedData(s.value, o, {
        cause: "initial"
    });
    (y = o._asyncData[s.value]) != null && y._init || (o._asyncData[s.value] = hg(o, s.value, r, i, p));
    const h = o._asyncData[s.value];
    h._deps++;
    const g = () => o._asyncData[s.value].execute({
        cause: "initial",
        dedupe: i.dedupe
    })
      , m = i.server !== !1 && o.payload.serverRendered;
    {
        let R = function(S) {
            const W = o._asyncData[S];
            W != null && W._deps && (W._deps--,
            W._deps === 0 && (W == null || W._off(),
            W._init = !1,
            Id(o, S),
            W.execute = () => Promise.resolve(),
            o._asyncData[S].data.value = io.value))
        };
        const P = Or();
        if (P && m && i.immediate && !P.sp && (P.sp = []),
        P && !P._nuxtOnBeforeMountCbs) {
            P._nuxtOnBeforeMountCbs = [];
            const S = P._nuxtOnBeforeMountCbs;
            oh( () => {
                S.forEach(W => {
                    W()
                }
                ),
                S.splice(0, S.length)
            }
            ),
            bl( () => S.splice(0, S.length))
        }
        const x = P && (P._nuxtClientOnly || pr(B0, !1));
        m && o.isHydrating && (h.error.value || p != null) ? (h.pending.value = !1,
        h.status.value = h.error.value ? "error" : "success") : P && !x && (o.payload.serverRendered && o.isHydrating || i.lazy) && i.immediate ? P._nuxtOnBeforeMountCbs.push(g) : i.immediate && g();
        const v = Lo();
        if (i.watch) {
            const S = tr(i.watch, () => {
                h._execute({
                    cause: "watch",
                    dedupe: i.dedupe
                })
            }
            , {
                flush: "post"
            });
            v && ds( () => S())
        }
        const k = tr(s, (S, W) => {
            var be, fe;
            const K = ((be = o._asyncData[W]) == null ? void 0 : be.data.value) !== io.value;
            W && R(W),
            (fe = o._asyncData[S]) != null && fe._init || (o._asyncData[S] = hg(o, S, r, i, i.getCachedData(S, o, {
                cause: "initial"
            }))),
            o._asyncData[S]._deps++,
            (i.immediate || K) && o._asyncData[S].execute({
                cause: "initial",
                dedupe: i.dedupe
            })
        }
        , {
            flush: "sync"
        });
        v && ds( () => {
            k(),
            R(s.value)
        }
        )
    }
    const w = {
        data: nc( () => {
            var R;
            return (R = o._asyncData[s.value]) == null ? void 0 : R.data
        }
        ),
        pending: nc( () => {
            var R;
            return (R = o._asyncData[s.value]) == null ? void 0 : R.pending
        }
        ),
        status: nc( () => {
            var R;
            return (R = o._asyncData[s.value]) == null ? void 0 : R.status
        }
        ),
        error: nc( () => {
            var R;
            return (R = o._asyncData[s.value]) == null ? void 0 : R.error
        }
        ),
        refresh: (...R) => o._asyncData[s.value].execute(...R),
        execute: (...R) => o._asyncData[s.value].execute(...R),
        clear: () => Id(o, s.value)
    }
      , E = Promise.resolve(o._asyncDataPromises[s.value]).then( () => w);
    return Object.assign(E, w),
    E
}
function nc(e) {
    return zt({
        get() {
            var t;
            return (t = e()) == null ? void 0 : t.value
        },
        set(t) {
            const n = e();
            n && (n.value = t)
        }
    })
}
function YC(e) {
    const t = Tr();
    if (e in t.payload.data || (t.payload.data[e] = io.value),
    t._asyncData[e]) {
        const n = t._asyncData[e];
        n._deps++,
        Lo() && ds( () => {
            n._deps--,
            n._deps === 0 && (n == null || n._off(),
            n._init = !1,
            Id(t, e))
        }
        )
    }
    return {
        data: zt({
            get() {
                var n;
                return ((n = t._asyncData[e]) == null ? void 0 : n.data.value) ?? t.payload.data[e]
            },
            set(n) {
                t._asyncData[e] ? t._asyncData[e].data.value = n : t.payload.data[e] = n
            }
        })
    }
}
function Id(e, t) {
    t in e.payload.data && (e.payload.data[t] = void 0),
    t in e.payload._errors && (e.payload._errors[t] = io.errorValue),
    e._asyncData[t] && (e._asyncData[t].data.value = void 0,
    e._asyncData[t].error.value = io.errorValue,
    e._asyncData[t].pending.value = !1,
    e._asyncData[t].status.value = "idle"),
    t in e._asyncDataPromises && (e._asyncDataPromises[t] && (e._asyncDataPromises[t].cancelled = !0),
    e._asyncDataPromises[t] = void 0)
}
function KC(e, t) {
    const n = {};
    for (const r of t)
        n[r] = e[r];
    return n
}
function hg(e, t, n, r, i) {
    var p;
    (p = e.payload._errors)[t] ?? (p[t] = io.errorValue);
    const s = n
      , o = r.deep ? Ut : qr
      , l = i != null
      , u = {
        data: o(l ? i : r.default()),
        pending: qr(!l),
        error: ko(e.payload._errors, t),
        status: qr("idle"),
        execute: (h={}) => {
            if (e._asyncDataPromises[t]) {
                if (qC(h.dedupe ?? r.dedupe))
                    return e._asyncDataPromises[t];
                e._asyncDataPromises[t].cancelled = !0
            }
            if (h.cause === "initial" || e.isHydrating) {
                const m = h.cause === "initial" ? i : r.getCachedData(t, e, {
                    cause: h.cause ?? "refresh:manual"
                });
                if (m != null)
                    return e.payload.data[t] = u.data.value = m,
                    u.error.value = io.errorValue,
                    u.status.value = "success",
                    Promise.resolve(m)
            }
            u.pending.value = !0,
            u.status.value = "pending";
            const g = new Promise( (m, w) => {
                try {
                    m(s(e))
                } catch (E) {
                    w(E)
                }
            }
            ).then(async m => {
                if (g.cancelled)
                    return e._asyncDataPromises[t];
                let w = m;
                r.transform && (w = await r.transform(m)),
                r.pick && (w = KC(w, r.pick)),
                e.payload.data[t] = w,
                u.data.value = w,
                u.error.value = io.errorValue,
                u.status.value = "success"
            }
            ).catch(m => {
                if (g.cancelled)
                    return e._asyncDataPromises[t];
                u.error.value = ra(m),
                u.data.value = Re(r.default()),
                u.status.value = "error"
            }
            ).finally( () => {
                g.cancelled || (u.pending.value = !1,
                delete e._asyncDataPromises[t])
            }
            );
            return e._asyncDataPromises[t] = g,
            e._asyncDataPromises[t]
        }
        ,
        _execute: pD( (...h) => u.execute(...h), 0, {
            leading: !0
        }),
        _default: r.default,
        _deps: 0,
        _init: !0,
        _hash: void 0,
        _off: e.hook("app:data:refresh", async h => {
            (!h || h.includes(t)) && await u.execute({
                cause: "refresh:hook"
            })
        }
        )
    };
    return u
}
const XC = "$s";
function QC(...e) {
    const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0;
    typeof e[0] != "string" && e.unshift(t);
    const [n,r] = e;
    if (!n || typeof n != "string")
        throw new TypeError("[nuxt] [useState] key must be a string: " + n);
    if (r !== void 0 && typeof r != "function")
        throw new Error("[nuxt] [useState] init must be a function: " + r);
    const i = XC + n
      , s = Tr()
      , o = ko(s.payload.state, i);
    if (o.value === void 0 && r) {
        const l = r();
        if (sr(l))
            return s.payload.state[i] = l,
            l;
        o.value = l
    }
    return o
}
async function H0(e, t=rs()) {
    const {path: n, matched: r} = t.resolve(e);
    if (!r.length || (t._routePreloaded || (t._routePreloaded = new Set),
    t._routePreloaded.has(n)))
        return;
    const i = t._preloadPromises || (t._preloadPromises = []);
    if (i.length > 4)
        return Promise.all(i).then( () => H0(e, t));
    t._routePreloaded.add(n);
    const s = r.map(o => {
        var l;
        return (l = o.components) == null ? void 0 : l.default
    }
    ).filter(o => typeof o == "function");
    for (const o of s) {
        const l = Promise.resolve(o()).catch( () => {}
        ).finally( () => i.splice(i.indexOf(l)));
        i.push(l)
    }
    await Promise.all(i)
}
function JC(e={}) {
    const t = e.path || window.location.pathname;
    let n = {};
    try {
        n = Oc(sessionStorage.getItem("nuxt:reload") || "{}")
    } catch {}
    if (e.force || (n == null ? void 0 : n.path) !== t || (n == null ? void 0 : n.expires) < Date.now()) {
        try {
            sessionStorage.setItem("nuxt:reload", JSON.stringify({
                path: t,
                expires: Date.now() + (e.ttl ?? 1e4)
            }))
        } catch {}
        if (e.persistState)
            try {
                sessionStorage.setItem("nuxt:reload:state", JSON.stringify({
                    state: Tr().payload.state
                }))
            } catch {}
        window.location.pathname !== t ? window.location.href = t : window.location.reload()
    }
}
const ZC = (...e) => e.find(t => t !== void 0);
function ex(e) {
    const t = e.componentName || "NuxtLink";
    function n(s) {
        return typeof s == "string" && s.startsWith("#")
    }
    function r(s, o, l) {
        const u = l ?? e.trailingSlash;
        if (!s || u !== "append" && u !== "remove")
            return s;
        if (typeof s == "string")
            return rc(s, u);
        const p = "path"in s && s.path !== void 0 ? s.path : o(s).path;
        return {
            ...s,
            name: void 0,
            path: rc(p, u)
        }
    }
    function i(s) {
        const o = rs()
          , l = qs()
          , u = zt( () => !!s.target && s.target !== "_self")
          , p = zt( () => {
            const R = s.to || s.href || "";
            return typeof R == "string" && ao(R, {
                acceptRelative: !0
            })
        }
        )
          , h = wc("RouterLink")
          , g = h && typeof h != "string" ? h.useLink : void 0
          , m = zt( () => {
            if (s.external)
                return !0;
            const R = s.to || s.href || "";
            return typeof R == "object" ? !1 : R === "" || p.value
        }
        )
          , w = zt( () => {
            const R = s.to || s.href || "";
            return m.value ? R : r(R, o.resolve, s.trailingSlash)
        }
        )
          , E = m.value || g == null ? void 0 : g({
            ...s,
            to: w
        })
          , y = zt( () => {
            var P;
            const R = s.trailingSlash ?? e.trailingSlash;
            if (!w.value || p.value || n(w.value))
                return w.value;
            if (m.value) {
                const x = typeof w.value == "object" && "path"in w.value ? xd(w.value) : w.value
                  , v = typeof x == "object" ? o.resolve(x).href : x;
                return rc(v, R)
            }
            return typeof w.value == "object" ? ((P = o.resolve(w.value)) == null ? void 0 : P.href) ?? null : rc(af(l.app.baseURL, w.value), R)
        }
        );
        return {
            to: w,
            hasTarget: u,
            isAbsoluteUrl: p,
            isExternal: m,
            href: y,
            isActive: (E == null ? void 0 : E.isActive) ?? zt( () => w.value === o.currentRoute.value.path),
            isExactActive: (E == null ? void 0 : E.isExactActive) ?? zt( () => w.value === o.currentRoute.value.path),
            route: (E == null ? void 0 : E.route) ?? zt( () => o.resolve(w.value)),
            async navigate(R) {
                await fD(y.value, {
                    replace: s.replace,
                    external: m.value || u.value
                })
            }
        }
    }
    return Mn({
        name: t,
        props: {
            to: {
                type: [String, Object],
                default: void 0,
                required: !1
            },
            href: {
                type: [String, Object],
                default: void 0,
                required: !1
            },
            target: {
                type: String,
                default: void 0,
                required: !1
            },
            rel: {
                type: String,
                default: void 0,
                required: !1
            },
            noRel: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            prefetch: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            prefetchOn: {
                type: [String, Object],
                default: void 0,
                required: !1
            },
            noPrefetch: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            activeClass: {
                type: String,
                default: void 0,
                required: !1
            },
            exactActiveClass: {
                type: String,
                default: void 0,
                required: !1
            },
            prefetchedClass: {
                type: String,
                default: void 0,
                required: !1
            },
            replace: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            ariaCurrentValue: {
                type: String,
                default: void 0,
                required: !1
            },
            external: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            custom: {
                type: Boolean,
                default: void 0,
                required: !1
            },
            trailingSlash: {
                type: String,
                default: void 0,
                required: !1
            }
        },
        useLink: i,
        setup(s, {slots: o}) {
            const l = rs()
              , {to: u, href: p, navigate: h, isExternal: g, hasTarget: m, isAbsoluteUrl: w} = i(s)
              , E = Ut(!1)
              , y = Ut(null)
              , R = v => {
                var k;
                y.value = s.custom ? (k = v == null ? void 0 : v.$el) == null ? void 0 : k.nextElementSibling : v == null ? void 0 : v.$el
            }
            ;
            function P(v) {
                var k, S;
                return !E.value && (typeof s.prefetchOn == "string" ? s.prefetchOn === v : ((k = s.prefetchOn) == null ? void 0 : k[v]) ?? ((S = e.prefetchOn) == null ? void 0 : S[v])) && (s.prefetch ?? e.prefetch) !== !1 && s.noPrefetch !== !0 && s.target !== "_blank" && !rx()
            }
            async function x(v=Tr()) {
                if (E.value)
                    return;
                E.value = !0;
                const k = typeof u.value == "string" ? u.value : g.value ? xd(u.value) : l.resolve(u.value).fullPath
                  , S = g.value ? new URL(k,window.location.href).href : k;
                await Promise.all([v.hooks.callHook("link:prefetch", S).catch( () => {}
                ), !g.value && !m.value && H0(u.value, l).catch( () => {}
                )])
            }
            if (P("visibility")) {
                const v = Tr();
                let k, S = null;
                xi( () => {
                    const W = tx();
                    Au( () => {
                        k = Fd( () => {
                            var K;
                            (K = y == null ? void 0 : y.value) != null && K.tagName && (S = W.observe(y.value, async () => {
                                S == null || S(),
                                S = null,
                                await x(v)
                            }
                            ))
                        }
                        )
                    }
                    )
                }
                ),
                Io( () => {
                    k && WC(k),
                    S == null || S(),
                    S = null
                }
                )
            }
            return () => {
                var S;
                if (!g.value && !m.value && !n(u.value)) {
                    const W = {
                        ref: R,
                        to: u.value,
                        activeClass: s.activeClass || e.activeClass,
                        exactActiveClass: s.exactActiveClass || e.exactActiveClass,
                        replace: s.replace,
                        ariaCurrentValue: s.ariaCurrentValue,
                        custom: s.custom
                    };
                    return s.custom || (P("interaction") && (W.onPointerenter = x.bind(null, void 0),
                    W.onFocus = x.bind(null, void 0)),
                    E.value && (W.class = s.prefetchedClass || e.prefetchedClass),
                    W.rel = s.rel || void 0),
                    ar(wc("RouterLink"), W, o.default)
                }
                const v = s.target || null
                  , k = ZC(s.noRel ? "" : s.rel, e.externalRelAttribute, w.value || m.value ? "noopener noreferrer" : "") || null;
                return s.custom ? o.default ? o.default({
                    href: p.value,
                    navigate: h,
                    prefetch: x,
                    get route() {
                        if (!p.value)
                            return;
                        const W = new URL(p.value,window.location.href);
                        return {
                            path: W.pathname,
                            fullPath: W.pathname,
                            get query() {
                                return wh(W.search)
                            },
                            hash: W.hash,
                            params: {},
                            name: void 0,
                            matched: [],
                            redirectedFrom: void 0,
                            meta: {},
                            href: p.value
                        }
                    },
                    rel: k,
                    target: v,
                    isExternal: g.value || m.value,
                    isActive: !1,
                    isExactActive: !1
                }) : null : ar("a", {
                    ref: y,
                    href: p.value || null,
                    rel: k,
                    target: v
                }, (S = o.default) == null ? void 0 : S.call(o))
            }
        }
    })
}
const V0 = ex(Gw);
function rc(e, t) {
    const n = t === "append" ? zm : fl;
    return ao(e) && !e.startsWith("http") ? e : n(e, !0)
}
function tx() {
    const e = Tr();
    if (e._observer)
        return e._observer;
    let t = null;
    const n = new Map
      , r = (s, o) => (t || (t = new IntersectionObserver(l => {
        for (const u of l) {
            const p = n.get(u.target);
            (u.isIntersecting || u.intersectionRatio > 0) && p && p()
        }
    }
    )),
    n.set(s, o),
    t.observe(s),
    () => {
        n.delete(s),
        t == null || t.unobserve(s),
        n.size === 0 && (t == null || t.disconnect(),
        t = null)
    }
    );
    return e._observer = {
        observe: r
    }
}
const nx = /2g/;
function rx() {
    const e = navigator.connection;
    return !!(e && (e.saveData || nx.test(e.effectiveType)))
}
function ix(e) {
    typeof e.indexable < "u" && (e.indexable = String(e.indexable) !== "false"),
    typeof e.trailingSlash < "u" && !e.trailingSlash && (e.trailingSlash = String(e.trailingSlash) !== "false"),
    e.url && !ao(String(e.url), {
        acceptRelative: !0,
        strict: !1
    }) && (e.url = hw(String(e.url)));
    const t = Object.keys(e).sort( (r, i) => r.localeCompare(i))
      , n = {};
    for (const r of t)
        n[r] = e[r];
    return n
}
function sx(e) {
    const n = [];
    function r(s) {
        if (!s || typeof s != "object" || Object.keys(s).length === 0)
            return () => {}
            ;
        s._context;
        const o = {};
        for (const u in s) {
            const p = s[u];
            typeof p < "u" && p !== "" && (o[u] = p)
        }
        let l;
        return Object.keys(o).filter(u => !u.startsWith("_")).length > 0 && (l = n.push(o)),
        () => {
            typeof l < "u" && n.splice(l - 1, 1)
        }
    }
    function i(s) {
        var l;
        const o = {};
        s != null && s.debug && (o._context = {}),
        o._priority = {};
        for (const u in n.sort( (p, h) => (p._priority || 0) - (h._priority || 0)))
            for (const p in n[u]) {
                const h = p
                  , g = s != null && s.resolveRefs ? Qr(n[u][p]) : n[u][p];
                !p.startsWith("_") && typeof g < "u" && g !== "" && (o[p] = g,
                typeof n[u]._priority < "u" && n[u]._priority !== -1 && (o._priority[h] = n[u]._priority),
                s != null && s.debug && (o._context[h] = ((l = n[u]._context) == null ? void 0 : l[h]) || n[u]._context || "anonymous"))
            }
        return s != null && s.skipNormalize ? o : ix(o)
    }
    return {
        stack: n,
        push: r,
        get: i
    }
}
const ox = ki({
    name: "nuxt-site-config:init",
    enforce: "pre",
    async setup(e) {
        var r;
        const t = sx()
          , n = QC("site-config");
        {
            const i = n.value || window.__NUXT_SITE_CONFIG__ || {};
            for (const s in i)
                s[0] !== "_" && t.push({
                    [s]: i[s],
                    _priority: ((r = i._priority) == null ? void 0 : r[s]) || -1
                })
        }
        return {
            provide: {
                nuxtSiteConfig: t
            }
        }
    }
})
  , ax = ki({
    name: "nuxt:payload",
    setup(e) {
        const t = new Set;
        rs().beforeResolve(async (n, r) => {
            if (n.path === r.path)
                return;
            const i = await qp(n.path);
            if (i) {
                for (const s of t)
                    delete e.static.data[s];
                for (const s in i.data)
                    s in e.static.data || t.add(s),
                    e.static.data[s] = i.data[s]
            }
        }
        ),
        Au( () => {
            var n;
            e.hooks.hook("link:prefetch", async r => {
                const {hostname: i} = new URL(r,window.location.href);
                i === window.location.hostname && await qp(r).catch( () => {
                    console.warn("[nuxt] Error preloading payload for", r)
                }
                )
            }
            ),
            ((n = navigator.connection) == null ? void 0 : n.effectiveType) !== "slow-2g" && setTimeout(cf, 1e3)
        }
        )
    }
})
  , lx = ki( () => {
    const e = rs();
    Au( () => {
        e.beforeResolve(async () => {
            await new Promise(t => {
                setTimeout(t, 100),
                requestAnimationFrame( () => {
                    setTimeout(t, 0)
                }
                )
            }
            )
        }
        )
    }
    )
}
)
  , ux = ki(e => {
    let t;
    async function n() {
        const r = await cf();
        t && clearTimeout(t),
        t = setTimeout(n, Op);
        try {
            const i = await $fetch(Dh("builds/latest.json") + `?${Date.now()}`);
            i.id !== r.id && e.hooks.callHook("app:manifest:update", i)
        } catch {}
    }
    Au( () => {
        t = setTimeout(n, Op)
    }
    )
}
)
  , cx = ki({
    name: "nuxt:chunk-reload",
    setup(e) {
        const t = rs()
          , n = qs()
          , r = new Set;
        t.beforeEach( () => {
            r.clear()
        }
        ),
        e.hook("app:chunkError", ({error: s}) => {
            r.add(s)
        }
        );
        function i(s) {
            const l = "href"in s && s.href[0] === "#" ? n.app.baseURL + s.href : af(n.app.baseURL, s.fullPath);
            JC({
                path: l,
                persistState: !0
            })
        }
        e.hook("app:manifest:update", () => {
            t.beforeResolve(i)
        }
        ),
        t.onError( (s, o) => {
            r.has(s) && i(o)
        }
        )
    }
});
function fx(e={}) {
    const t = [];
    let n = -1;
    const r = (i=!1) => ({
        get(s, o, l) {
            if (!i) {
                const u = Reflect.get(s, o, l);
                if (typeof u < "u")
                    return u;
                n++,
                t[n] = []
            }
            return t[n].push({
                type: "get",
                key: o
            }),
            new Proxy( () => {}
            ,r(!0))
        },
        apply(s, o, l) {
            t[n].push({
                type: "apply",
                key: "",
                args: l
            })
        }
    });
    return {
        proxy: new Proxy(e || {},r()),
        stack: t
    }
}
function dx(e) {
    const t = {
        get(n, r, i) {
            const s = Reflect.get(n, r, i);
            return typeof s == "object" ? new Proxy(s,t) : s
        },
        apply(n, r, i) {
            Reflect.apply(n, r, i)
        }
    };
    return new Proxy(e,t)
}
function hx(e, t) {
    t.forEach(n => {
        let r = e
          , i = e;
        n.forEach( ({type: s, key: o, args: l}) => {
            s === "get" ? (i = r,
            r = r[o]) : s === "apply" && (r = r.call(i, ...l))
        }
        )
    }
    )
}
function px(e) {
    return e.key || e.src || (typeof e.innerHTML == "string" ? e.innerHTML : "")
}
const gx = ["preconnect", "dns-prefetch"];
function _x(e, t, n) {
    var E, y, R;
    const r = typeof t == "string" ? {
        src: t
    } : t
      , i = n || {}
      , s = px(r)
      , o = (E = e._scripts) == null ? void 0 : E[s];
    if (o)
        return o.setupTriggerHandler(i.trigger),
        o;
    (y = i.beforeInit) == null || y.call(i);
    const l = P => {
        m.status = P,
        e.hooks.callHook("script:updated", w)
    }
    ;
    hE.forEach(P => {
        const x = P
          , v = typeof r[x] == "function" ? r[x].bind(i.eventContext) : null;
        r[x] = k => {
            l(P === "onload" ? "loaded" : P === "onerror" ? "error" : "loading"),
            v == null || v(k)
        }
    }
    );
    const u = {
        loaded: [],
        error: []
    }
      , p = new Set
      , h = (P, x, v) => {
        if (!e.ssr) {
            if (v != null && v.key) {
                const k = `${v == null ? void 0 : v.key}:${v.key}`;
                if (p.has(k))
                    return;
                p.add(k)
            }
            if (u[P]) {
                const k = u[P].push(x);
                return () => {
                    var S;
                    return (S = u[P]) == null ? void 0 : S.splice(k - 1, 1)
                }
            }
            return x(m.instance),
            () => {}
        }
    }
      , g = new Promise(P => {
        if (e.ssr)
            return;
        const x = k => requestAnimationFrame( () => P(k))
          , v = e.hooks.hook("script:updated", ({script: k}) => {
            const S = k.status;
            if (k.id === s && (S === "loaded" || S === "error")) {
                if (S === "loaded")
                    if (typeof i.use == "function") {
                        const W = i.use();
                        W && x(W)
                    } else
                        x({});
                else
                    S === "error" && P(!1);
                v()
            }
        }
        )
    }
    )
      , m = {
        _loadPromise: g,
        instance: !e.ssr && ((R = i == null ? void 0 : i.use) == null ? void 0 : R.call(i)) || null,
        proxy: null,
        id: s,
        status: "awaitingLoad",
        remove() {
            var P, x, v;
            return (P = m._triggerAbortController) == null || P.abort(),
            m._triggerPromises = [],
            (x = m._warmupEl) == null || x.dispose(),
            m.entry ? (m.entry.dispose(),
            m.entry = void 0,
            l("removed"),
            (v = e._scripts) == null || delete v[s],
            !0) : !1
        },
        warmup(P) {
            const {src: x} = r
              , v = !x.startsWith("/") || x.startsWith("//")
              , k = P && gx.includes(P);
            let S = x;
            if (!P || k && !v)
                return;
            if (k) {
                const K = new URL(x);
                S = `${K.protocol}//${K.host}`
            }
            const W = {
                href: S,
                rel: P,
                crossorigin: typeof r.crossorigin < "u" ? r.crossorigin : v ? "anonymous" : void 0,
                referrerpolicy: typeof r.referrerpolicy < "u" ? r.referrerpolicy : v ? "no-referrer" : void 0,
                fetchpriority: typeof r.fetchpriority < "u" ? r.fetchpriority : "low",
                integrity: r.integrity,
                as: P === "preload" ? "script" : void 0
            };
            return m._warmupEl = e.push({
                link: [W]
            }, {
                head: e,
                tagPriority: "high"
            }),
            m._warmupEl
        },
        load(P) {
            var x;
            if ((x = m._triggerAbortController) == null || x.abort(),
            m._triggerPromises = [],
            !m.entry) {
                l("loading");
                const v = {
                    defer: !0,
                    fetchpriority: "low"
                };
                r.src && (r.src.startsWith("http") || r.src.startsWith("//")) && (v.crossorigin = "anonymous",
                v.referrerpolicy = "no-referrer"),
                m.entry = e.push({
                    script: [{
                        ...v,
                        ...r
                    }]
                }, i)
            }
            return P && h("loaded", P),
            g
        },
        onLoaded(P, x) {
            return h("loaded", P, x)
        },
        onError(P, x) {
            return h("error", P, x)
        },
        setupTriggerHandler(P) {
            if (m.status === "awaitingLoad")
                if ((typeof P > "u" || P === "client") && !e.ssr || P === "server")
                    m.load();
                else if (P instanceof Promise) {
                    if (e.ssr)
                        return;
                    m._triggerAbortController || (m._triggerAbortController = new AbortController,
                    m._triggerAbortPromise = new Promise(v => {
                        m._triggerAbortController.signal.addEventListener("abort", () => {
                            m._triggerAbortController = null,
                            v()
                        }
                        )
                    }
                    )),
                    m._triggerPromises = m._triggerPromises || [];
                    const x = m._triggerPromises.push(Promise.race([P.then(v => typeof v > "u" || v ? m.load : void 0), m._triggerAbortPromise]).catch( () => {}
                    ).then(v => {
                        v == null || v()
                    }
                    ).finally( () => {
                        var v;
                        (v = m._triggerPromises) == null || v.splice(x, 1)
                    }
                    ))
                } else
                    typeof P == "function" && P(m.load)
        },
        _cbs: u
    };
    g.then(P => {
        var x, v;
        P !== !1 ? (m.instance = P,
        (x = u.loaded) == null || x.forEach(k => k(P)),
        u.loaded = null) : ((v = u.error) == null || v.forEach(k => k()),
        u.error = null)
    }
    );
    const w = {
        script: m
    };
    if (m.setupTriggerHandler(i.trigger),
    i.use) {
        const {proxy: P, stack: x} = fx(e.ssr ? {} : i.use() || {});
        m.proxy = P,
        m.onLoaded(v => {
            hx(v, x),
            m.proxy = dx(v)
        }
        )
    }
    return !i.warmupStrategy && (typeof i.trigger > "u" || i.trigger === "client") && (i.warmupStrategy = "preload"),
    i.warmupStrategy && m.warmup(i.warmupStrategy),
    e._scripts = Object.assign(e._scripts || {}, {
        [s]: m
    }),
    m
}
const mx = "usehead";
function yx() {
    if (Na()) {
        const e = pr(mx);
        if (!e)
            throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.");
        return e
    }
    throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.")
}
function vx(e, t) {
    if (!t)
        return;
    const n = (r, i) => {
        if (!e._cbs[r])
            return i(e.instance),
            () => {}
            ;
        let s = e._cbs[r].push(i);
        const o = () => {
            var l;
            s && ((l = e._cbs[r]) == null || l.splice(s - 1, 1),
            s = null)
        }
        ;
        return ds(o),
        o
    }
    ;
    e.onLoaded = r => n("loaded", r),
    e.onError = r => n("error", r),
    ds( () => {
        var r;
        (r = e._triggerAbortController) == null || r.abort()
    }
    )
}
function bx(e, t) {
    const n = typeof e == "string" ? {
        src: e
    } : e
      , r = t || {}
      , i = (r == null ? void 0 : r.head) || yx();
    r.head = i;
    const s = Or();
    if (r.eventContext = s,
    s && typeof r.trigger > "u")
        r.trigger = xi;
    else if (sr(r.trigger)) {
        const l = r.trigger;
        let u;
        r.trigger = new Promise(p => {
            u = tr(l, h => {
                h && p(!0)
            }
            , {
                immediate: !0
            }),
            ds( () => p(!1), !0)
        }
        ).then(p => (u == null || u(),
        p))
    }
    i._scriptStatusWatcher = i._scriptStatusWatcher || i.hooks.hook("script:updated", ({script: l}) => {
        l._statusRef.value = l.status
    }
    );
    const o = _x(i, n, r);
    return o._statusRef = o._statusRef || Ut(o.status),
    vx(o, s),
    new Proxy(o,{
        get(l, u, p) {
            return Reflect.get(l, u === "status" ? "_statusRef" : u, p)
        }
    })
}
function wx() {
    return qs().public["nuxt-scripts"]
}
function Dx(e) {
    return e.key || e.src || (typeof e.innerHTML == "string" ? e.innerHTML : "")
}
function Ex(e, t) {
    var o, l;
    e = typeof e == "string" ? {
        src: e
    } : e,
    t = lf(t, (o = wx()) == null ? void 0 : o.defaultScriptOptions);
    const n = String(Dx(e))
      , r = Tr();
    if (t.head = t.head || xh(),
    !t.head)
        throw new Error("useScript() has been called without Nuxt context.");
    r.$scripts = r.$scripts || Gr({}),
    (l = r.$scripts) != null && l[n],
    (t.trigger === "onNuxtReady" || t.trigger === "client") && (t.warmupStrategy || (t.warmupStrategy = "preload"),
    t.trigger === "onNuxtReady" && (t.trigger = Au));
    const i = bx(e, t)
      , s = i.remove;
    return i.remove = () => (r.$scripts[n] = void 0,
    s()),
    r.$scripts[n] = i,
    i
}
const wl = Object.freeze(Object.assign( () => {}
, {
    __mock__: !0
}))
  , Cx = wl
  , Ea = wl
  , jf = wl
  , bo = wl
  , zf = wl
  , Uf = wl;
function xx(e) {
    return (qs().public.scripts || {})[e]
}
function Sx(e, t, n) {
    const r = xx(e)
      , i = Object.assign(n || {}, typeof r == "object" ? r : {})
      , s = t(i)
      , o = lf(i.scriptInput, s.scriptInput, {
        key: e
    })
      , l = Object.assign((i == null ? void 0 : i.scriptOptions) || {}, s.scriptOptions || {})
      , u = l.beforeInit;
    return l.beforeInit = () => {
        var p;
        u == null || u(),
        (p = s.clientInit) == null || p.call(s)
    }
    ,
    Ex(o, l)
}
Cx({
    id: Ea(),
    l: bo(Ea()),
    auth: bo(Ea()),
    preview: bo(Ea()),
    cookiesWin: bo(Uf([jf(), zf("x")])),
    debug: bo(Uf([jf(), zf("x")])),
    npa: bo(Uf([jf(), zf("1")])),
    dataLayer: bo(Ea()),
    envName: bo(Ea()),
    authReferrerPolicy: bo(Ea())
});
function Tx(e) {
    return Sx((e == null ? void 0 : e.key) || "googleTagManager", t => {
        const n = (t == null ? void 0 : t.l) ?? (t == null ? void 0 : t.dataLayer) ?? "dataLayer";
        return {
            scriptInput: {
                src: _u("https://www.googletagmanager.com/gtm.js", {
                    id: t.id,
                    l: t.l,
                    gtm_auth: t.auth,
                    gtm_preview: t.preview,
                    gtm_cookies_win: t.cookiesWin ? "x" : void 0,
                    gtm_debug: t.debug ? "x" : void 0,
                    gtm_npa: t.npa ? "1" : void 0,
                    gtm_data_layer: t.dataLayer,
                    gtm_env: t.envName,
                    gtm_auth_referrer_policy: t.authReferrerPolicy
                })
            },
            schema: void 0,
            scriptOptions: {
                use: () => ({
                    dataLayer: window[n],
                    google_tag_manager: window.google_tag_manager
                }),
                performanceMarkFeature: "nuxt-third-parties-gtm",
                tagPriority: 1
            },
            clientInit: () => {
                var i;
                window[n] = window[n] || [];
                function r(...s) {
                    window[n].push(s)
                }
                (i = e == null ? void 0 : e.onBeforeGtmStart) == null || i.call(e, r),
                window[n].push({
                    "gtm.start": new Date().getTime(),
                    event: "gtm.js"
                })
            }
        }
    }
    , e)
}
const Px = ki({
    name: "scripts:init",
    env: {
        islands: !1
    },
    parallel: !0,
    setup() {
        return {
            provide: {
                $scripts: {
                    googleTagManager: Tx({
                        id: "GTM-NLZX33DL"
                    })
                }
            }
        }
    }
})
  , kx = ki({
    name: "pinia",
    setup(e) {
        const t = _D();
        return e.vueApp.use(t),
        ku(t),
        e.payload && e.payload.pinia && (t.state.value = e.payload.pinia),
        {
            provide: {
                pinia: t
            }
        }
    }
})
  , Ax = Xt( () => Vt( () => Promise.resolve().then( () => gA), void 0, import.meta.url).then(e => e.default || e.default || e))
  , Rx = Xt( () => Vt( () => Promise.resolve().then( () => qk), void 0, import.meta.url).then(e => e.default || e.default || e))
  , Ox = Xt( () => Vt( () => import("./DMco0rdt.js"), __vite__mapDeps([11, 12]), import.meta.url).then(e => e.default || e.default || e))
  , Mx = Xt( () => Vt( () => import("./BxJ63bii.js"), __vite__mapDeps([2, 3]), import.meta.url).then(e => e.default || e.default || e))
  , Lx = Xt( () => Vt( () => Promise.resolve().then( () => A2), void 0, import.meta.url).then(e => e.default || e.default || e))
  , Fx = Xt( () => Vt( () => import("./X2iQyDR3.js"), __vite__mapDeps([33, 34]), import.meta.url).then(e => e.default || e.default || e))
  , Ix = Xt( () => Vt( () => import("./D_MGx2mw.js"), __vite__mapDeps([35, 36]), import.meta.url).then(e => e.default || e.default || e))
  , Nx = Xt( () => Vt( () => import("./BqJij3jk.js"), __vite__mapDeps([49, 30, 35, 36, 50]), import.meta.url).then(e => e.default || e.default || e))
  , $x = Xt( () => Vt( () => import("./DuRqwrrY.js"), __vite__mapDeps([51, 52]), import.meta.url).then(e => e.default || e.default || e))
  , Bx = Xt( () => Vt( () => import("./-ncqVWPL.js"), __vite__mapDeps([53, 54, 9, 10, 11, 12, 13, 14, 55]), import.meta.url).then(e => e.default || e.default || e))
  , Hx = Xt( () => Vt( () => import("./B5mzQEIC.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , Vx = Xt( () => Vt( () => Promise.resolve().then( () => P2), void 0, import.meta.url).then(e => e.default || e.default || e))
  , jx = Xt( () => Vt( () => import("./DaDwZ53i.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , zx = Xt( () => Vt( () => import("./BFfbkEzJ.js"), __vite__mapDeps([56, 57, 5, 30, 58]), import.meta.url).then(e => e.default || e.default || e))
  , Ux = Xt( () => Vt( () => Promise.resolve().then( () => qP), void 0, import.meta.url).then(e => e.default || e.default || e))
  , Wx = Xt( () => Vt( () => import("./UXbsRNbb.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , qx = Xt( () => Vt( () => import("./DWjXqeLZ.js"), __vite__mapDeps([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]), import.meta.url).then(e => e.default || e.default || e))
  , Gx = Xt( () => Vt( () => Promise.resolve().then( () => hk), void 0, import.meta.url).then(e => e.default || e.default || e))
  , Yx = Xt( () => Vt( () => import("./CRca66RA.js"), __vite__mapDeps([59, 35, 36, 60]), import.meta.url).then(e => e.default || e.default || e))
  , Kx = Xt( () => Vt( () => import("./BiKF1uHK.js"), __vite__mapDeps([61, 62]), import.meta.url).then(e => e.default || e.default || e))
  , Xx = Xt( () => Vt( () => import("./DetfEEUb.js"), __vite__mapDeps([63, 64]), import.meta.url).then(e => e.default || e.default || e))
  , Qx = Xt( () => Vt( () => import("./D5u-uEeA.js"), __vite__mapDeps([65, 33, 34, 35, 36, 56, 57, 5, 30, 58, 11, 12, 9, 10, 13, 14, 66]), import.meta.url).then(e => e.default || e.default || e))
  , Jx = Xt( () => Vt( () => import("./S5LwJpeA.js").then(e => e.A), __vite__mapDeps([67, 59, 35, 36, 60, 4, 5, 49, 30, 50, 68, 69, 70, 71]), import.meta.url).then(e => e.default || e.default || e))
  , Zx = Xt( () => Vt( () => import("./D2U9k6xf.js"), __vite__mapDeps([72, 56, 57, 5, 30, 58, 73, 74, 75]), import.meta.url).then(e => e.default || e.default || e))
  , eS = Xt( () => Vt( () => import("./Bd3kFPqD.js"), __vite__mapDeps([76, 6, 7, 8, 77]), import.meta.url).then(e => e.default || e.default || e))
  , tS = Xt( () => Vt( () => import("./Cis9g7J4.js"), __vite__mapDeps([78, 56, 57, 5, 30, 58, 35, 36, 6, 7, 8, 79]), import.meta.url).then(e => e.default || e.default || e))
  , nS = Xt( () => Vt( () => import("./BcOJFtKS.js"), __vite__mapDeps([80, 78, 56, 57, 5, 30, 58, 35, 36, 6, 7, 8, 79]), import.meta.url).then(e => e.default || e.default || e))
  , rS = Xt( () => Vt( () => import("./CSQBpqcQ.js"), __vite__mapDeps([81, 6, 7, 8, 15, 82]), import.meta.url).then(e => e.default || e.default || e))
  , iS = Xt( () => Vt( () => import("./miBiR62R.js"), __vite__mapDeps([10, 11, 12, 13]), import.meta.url).then(e => e.default || e.default || e))
  , sS = Xt( () => Vt( () => import("./DKxMU-wA.js"), __vite__mapDeps([83, 84]), import.meta.url).then(e => e.default || e.default || e))
  , oS = Xt( () => Vt( () => import("./BVtaWYQw.js"), __vite__mapDeps([85, 56, 57, 5, 30, 58, 6, 7, 8, 86]), import.meta.url).then(e => e.default || e.default || e))
  , aS = Xt( () => Vt( () => import("./DCfZCkD0.js"), __vite__mapDeps([87, 56, 57, 5, 30, 58, 35, 36, 73, 74, 88]), import.meta.url).then(e => e.default || e.default || e))
  , lS = Xt( () => Vt( () => import("./Cl5NWGaN.js"), __vite__mapDeps([89, 68, 69, 70, 90]), import.meta.url).then(e => e.default || e.default || e))
  , uS = Xt( () => Vt( () => import("./Cys__Kp9.js"), __vite__mapDeps([91, 92, 56, 57, 5, 30, 58, 35, 36, 93, 7, 15, 94]), import.meta.url).then(e => e.default || e.default || e))
  , cS = Xt( () => Vt( () => import("./DKPMjus8.js"), __vite__mapDeps([95, 30, 92, 56, 57, 5, 58, 35, 36, 7, 15, 96]), import.meta.url).then(e => e.default || e.default || e))
  , fS = Xt( () => Vt( () => import("./Dd93XKWM.js"), __vite__mapDeps([97, 56, 57, 5, 30, 58, 63, 64, 53, 54, 9, 10, 11, 12, 13, 14, 55, 35, 36, 98]), import.meta.url).then(e => e.default || e.default || e))
  , dS = Xt( () => Vt( () => import("./D3129BPP.js"), __vite__mapDeps([99, 100, 101, 56, 57, 5, 30, 58, 9, 10, 11, 12, 13, 14, 93, 102]), import.meta.url).then(e => e.default || e.default || e))
  , hS = Xt( () => Vt( () => import("./JJ0bgXXV.js"), __vite__mapDeps([103, 54, 35, 36, 9, 10, 11, 12, 13, 14, 7, 104]), import.meta.url).then(e => e.default || e.default || e))
  , pS = Xt( () => Vt( () => import("./CSBK0bRj.js"), __vite__mapDeps([105, 103, 54, 35, 36, 9, 10, 11, 12, 13, 14, 7, 104]), import.meta.url).then(e => e.default || e.default || e))
  , gS = Xt( () => Vt( () => import("./C1uiNH32.js"), __vite__mapDeps([106, 56, 57, 5, 30, 58, 100, 101, 73, 74, 9, 10, 11, 12, 13, 14, 107]), import.meta.url).then(e => e.default || e.default || e))
  , _S = Xt( () => Vt( () => import("./DvDbbmhX.js"), __vite__mapDeps([108, 56, 57, 5, 30, 58, 73, 74, 109]), import.meta.url).then(e => e.default || e.default || e))
  , mS = Xt( () => Vt( () => import("./DP-7vt3f.js"), __vite__mapDeps([110, 111, 30, 112, 73, 74, 113, 114]), import.meta.url).then(e => e.default || e.default || e))
  , yS = Xt( () => Vt( () => import("./aKHjDkkP.js"), __vite__mapDeps([115, 116, 29, 30, 31, 56, 57, 5, 58, 35, 36, 93, 92, 70, 117]), import.meta.url).then(e => e.default || e.default || e))
  , vS = Xt( () => Vt( () => import("./B9GCsJEt.js"), __vite__mapDeps([118, 111, 30, 112, 119]), import.meta.url).then(e => e.default || e.default || e))
  , bS = Xt( () => Vt( () => import("./BhF38yHI.js"), __vite__mapDeps([120, 33, 34, 57, 5, 11, 12, 121]), import.meta.url).then(e => e.default || e.default || e))
  , wS = Xt( () => Vt( () => import("./D0GSe9oA.js").then(e => e.N), __vite__mapDeps([116, 29, 30, 31, 56, 57, 5, 58, 35, 36, 93, 92, 70, 117]), import.meta.url).then(e => e.default || e.default || e))
  , DS = Xt( () => Vt( () => import("./CXwOP54l.js"), __vite__mapDeps([122, 111, 30, 112, 4, 5, 59, 35, 36, 60, 49, 50, 9, 10, 11, 12, 13, 14, 116, 29, 31, 56, 57, 58, 93, 92, 70, 117, 123, 6, 7, 8, 73, 74, 15, 124, 125]), import.meta.url).then(e => e.default || e.default || e))
  , ES = Xt( () => Vt( () => import("./08tjNvWn.js"), __vite__mapDeps([126, 35, 36, 32, 33, 34, 11, 12, 37, 127]), import.meta.url).then(e => e.default || e.default || e))
  , CS = Xt( () => Vt( () => import("./E4c-oP3M.js"), __vite__mapDeps([128, 111, 30, 112, 7, 15, 129]), import.meta.url).then(e => e.default || e.default || e))
  , xS = Xt( () => Vt( () => import("./Ftaie4Kp.js"), __vite__mapDeps([130, 56, 57, 5, 30, 58, 73, 74, 131]), import.meta.url).then(e => e.default || e.default || e))
  , SS = Xt( () => Vt( () => import("./Ag6wi3mv.js"), __vite__mapDeps([132, 6, 7, 8, 111, 30, 112, 133]), import.meta.url).then(e => e.default || e.default || e))
  , TS = Xt( () => Vt( () => import("./cJ4SfDLX.js"), __vite__mapDeps([123, 6, 7, 8, 56, 57, 5, 30, 58, 111, 112, 35, 36, 73, 74, 15, 124]), import.meta.url).then(e => e.default || e.default || e))
  , PS = Xt( () => Vt( () => import("./DZYxXXtm.js"), __vite__mapDeps([134, 6, 7, 8, 56, 57, 5, 30, 58, 73, 74, 15, 35, 36, 135]), import.meta.url).then(e => e.default || e.default || e))
  , kS = Xt( () => Vt( () => import("./Cvqf3Hfi.js"), __vite__mapDeps([136, 73, 74, 137]), import.meta.url).then(e => e.default || e.default || e))
  , AS = Xt( () => Vt( () => import("./COn8KyPB.js"), __vite__mapDeps([138, 139, 140, 100, 101, 9, 10, 11, 12, 13, 14, 141]), import.meta.url).then(e => e.default || e.default || e))
  , RS = Xt( () => Vt( () => import("./BSt46Xi-.js"), __vite__mapDeps([142, 56, 57, 5, 30, 58, 73, 74, 35, 36, 143]), import.meta.url).then(e => e.default || e.default || e))
  , OS = Xt( () => Vt( () => import("./MtFr25ii.js"), __vite__mapDeps([144, 35, 36, 56, 57, 5, 30, 58, 9, 10, 11, 12, 13, 14, 7, 15, 145]), import.meta.url).then(e => e.default || e.default || e))
  , MS = Xt( () => Vt( () => import("./YRepJa2O.js"), [], import.meta.url).then(e => e.default || e.default || e))
  , LS = Xt( () => Vt( () => import("./CcUsvXqT.js"), __vite__mapDeps([146, 15, 7, 147]), import.meta.url).then(e => e.default || e.default || e))
  , FS = Xt( () => Vt( () => import("./B_Pww068.js"), __vite__mapDeps([148, 139, 140, 149]), import.meta.url).then(e => e.default || e.default || e))
  , IS = Xt( () => Vt( () => import("./1VzHhDmg.js"), __vite__mapDeps([150, 111, 30, 112, 73, 74, 113, 151]), import.meta.url).then(e => e.default || e.default || e))
  , NS = [["AppLoader", Ax], ["AppTransition", Rx], ["BorderHover", Ox], ["ButtonTilt", Mx], ["Container", Lx], ["CrossFlicker", Fx], ["DSButton", Ix], ["DSDropdownButton", Nx], ["DesignGrid", $x], ["HoverCard", Bx], ["Logo", Hx], ["LogoLettering", Vx], ["LogoOutline", jx], ["Media", zx], ["NavigationDropdown", Ux], ["RichTextParagraph", Wx], ["SiteFooter", qx], ["SiteHeader", Gx], ["TagButtonList", Yx], ["TextReveal", Kx], ["TextRevealChar", Xx], ["AboutLeaders", Qx], ["AllResources", Jx], ["BigImageWithContent", Zx], ["BigText", eS], ["CaseStudy", tS], ["CaseStudyReference", nS], ["ComparisonTable", rS], ["ContentExpander", iS], ["ContentExpanderStandAlone", sS], ["ExpandableFeatureCards", oS], ["FeatureSection", aS], ["FeaturedBlogPosts", lS], ["FeaturesCarousel", uS], ["FeaturesCarouselExpandable", cS], ["FeaturesGrid", fS], ["FeaturesSteps", dS], ["FormBuilder", hS], ["FormReference", pS], ["FullscreenFeatures", gS], ["HeroImage", _S], ["InfoSection", mS], ["LatestNews", yS], ["LinksList", vS], ["LogoGrid", bS], ["NewsSection", wS], ["Post", DS], ["PressSection", ES], ["ProofPoints", CS], ["Quote", xS], ["ResultsSection", SS], ["SectionIntroduction", TS], ["SectionsGrid", PS], ["SeparatorNotch", kS], ["SolutionsFeatures", AS], ["SolutionsFull", RS], ["SolutionsValue", OS], ["StoryblokPage", MS], ["TabbedAccordion", LS], ["VideoCarousel", FS], ["YOSSection", IS]]
  , $S = ki({
    name: "nuxt:global-components",
    setup(e) {
        for (const [t,n] of NS)
            e.vueApp.component(t, n),
            e.vueApp.component("Lazy" + t, n)
    }
})
  , ea = {
    default: Xt( () => Vt( () => import("./sBtd8UHQ.js"), __vite__mapDeps([152, 153]), import.meta.url).then(e => e.default || e))
}
  , BS = ki({
    name: "nuxt:prefetch",
    setup(e) {
        const t = rs();
        e.hooks.hook("app:mounted", () => {
            t.beforeEach(async n => {
                var i;
                const r = (i = n == null ? void 0 : n.meta) == null ? void 0 : i.layout;
                r && typeof ea[r] == "function" && await ea[r]()
            }
            )
        }
        ),
        e.hooks.hook("link:prefetch", n => {
            if (ao(n))
                return;
            const r = t.resolve(n);
            if (!r)
                return;
            const i = r.meta.layout;
            let s = Ah(r.meta.middleware);
            s = s.filter(o => typeof o == "string");
            for (const o of s)
                typeof ou[o] == "function" && ou[o]();
            i && typeof ea[i] == "function" && ea[i]()
        }
        )
    }
});
function Wf(...e) {
    var t;
    (t = window.dataLayer) == null || t.push(arguments)
}
function HS({tags: e}) {
    window.dataLayer = window.dataLayer || [];
    for (const t of e)
        for (const n of t.initCommands ?? [])
            Wf(...n);
    Wf("js", new Date);
    for (const t of e)
        Wf("config", t.id, t.config ?? {})
}
function VS(e) {
    const t = Nn(e)
      , n = t.tags.filter(Boolean).map(r => typeof r == "string" ? {
        id: r
    } : r);
    if (t.id) {
        const {id: r, config: i, initCommands: s} = t;
        n.unshift({
            id: r,
            config: i,
            initCommands: s
        })
    }
    return n
}
const jS = ki({
    parallel: !0,
    setup() {
        const e = qs().public.gtag
          , t = VS(e);
        if (!t.length || (HS({
            tags: t
        }),
        e.initMode === "manual"))
            return;
        const n = e.loadingStrategy === "async" ? "async" : "defer";
        v0({
            link: [{
                rel: "preload",
                as: "script",
                href: _u(e.url, {
                    id: t[0].id
                })
            }],
            script: [{
                src: _u(e.url, {
                    id: t[0].id
                }),
                [n]: !0,
                "data-gtag": ""
            }]
        })
    }
});
function zS(e, t) {
    if (!t)
        return {
            src: e,
            attrs: {}
        };
    let n = 0
      , r = 0;
    const i = {}
      , s = [];
    function o(u, p, h, g, m) {
        typeof u != "number" || u <= p || u >= h ? console.warn(`[StoryblokRichText] - ${g.charAt(0).toUpperCase() + g.slice(1)} value must be a number between ${p} and ${h} (inclusive)`) : m.push(`${g}(${u})`)
    }
    if (typeof t == "object") {
        if (typeof t.width == "number" && t.width > 0 ? (i.width = t.width,
        n = t.width) : console.warn("[StoryblokRichText] - Width value must be a number greater than 0"),
        t.height && typeof t.height == "number" && t.height > 0 ? (i.height = t.height,
        r = t.height) : console.warn("[StoryblokRichText] - Height value must be a number greater than 0"),
        t.loading && ["lazy", "eager"].includes(t.loading) && (i.loading = t.loading),
        t.class && (i.class = t.class),
        t.filters) {
            const {filters: u} = t || {}
              , {blur: p, brightness: h, fill: g, format: m, grayscale: w, quality: E, rotate: y} = u || {};
            p && o(p, 0, 100, "blur", s),
            E && o(E, 0, 100, "quality", s),
            h && o(h, 0, 100, "brightness", s),
            g && s.push(`fill(${g})`),
            w && s.push("grayscale()"),
            y && [0, 90, 180, 270].includes(t.filters.rotate || 0) && s.push(`rotate(${y})`),
            m && ["webp", "png", "jpeg"].includes(m) && s.push(`format(${m})`)
        }
        t.srcset && (i.srcset = t.srcset.map(u => {
            if (typeof u == "number")
                return `${e}/m/${u}x0/${s.length > 0 ? `filters:${s.join(":")}` : ""} ${u}w`;
            if (Array.isArray(u) && u.length === 2) {
                const [p,h] = u;
                return `${e}/m/${p}x${h}/${s.length > 0 ? `filters:${s.join(":")}` : ""} ${p}w`
            } else {
                console.warn("[StoryblokRichText] - srcset entry must be a number or a tuple of two numbers");
                return
            }
        }
        ).join(", ")),
        t.sizes && (i.sizes = t.sizes.join(", "))
    }
    let l = `${e}/m/`;
    return n > 0 && r > 0 && (l = `${l}${n}x${r}/`),
    s.length > 0 && (l = `${l}filters:${s.join(":")}`),
    {
        src: l,
        attrs: i
    }
}
var vi = (e => (e.DOCUMENT = "doc",
e.HEADING = "heading",
e.PARAGRAPH = "paragraph",
e.QUOTE = "blockquote",
e.OL_LIST = "ordered_list",
e.UL_LIST = "bullet_list",
e.LIST_ITEM = "list_item",
e.CODE_BLOCK = "code_block",
e.HR = "horizontal_rule",
e.BR = "hard_break",
e.IMAGE = "image",
e.EMOJI = "emoji",
e.COMPONENT = "blok",
e.TABLE = "table",
e.TABLE_ROW = "tableRow",
e.TABLE_CELL = "tableCell",
e.TABLE_HEADER = "tableHeader",
e))(vi || {})
  , _s = (e => (e.BOLD = "bold",
e.STRONG = "strong",
e.STRIKE = "strike",
e.UNDERLINE = "underline",
e.ITALIC = "italic",
e.CODE = "code",
e.LINK = "link",
e.ANCHOR = "anchor",
e.STYLED = "styled",
e.SUPERSCRIPT = "superscript",
e.SUBSCRIPT = "subscript",
e.TEXT_STYLE = "textStyle",
e.HIGHLIGHT = "highlight",
e))(_s || {})
  , j0 = (e => (e.TEXT = "text",
e))(j0 || {})
  , Hl = (e => (e.URL = "url",
e.STORY = "story",
e.ASSET = "asset",
e.EMAIL = "email",
e))(Hl || {});
const US = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"]
  , WS = (e={}) => Object.keys(e).map(t => `${t}="${e[t]}"`).join(" ")
  , qS = (e={}) => Object.keys(e).map(t => `${t}: ${e[t]}`).join("; ");
function GS(e) {
    return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;")
}
const ic = e => Object.fromEntries(Object.entries(e).filter( ([t,n]) => n !== void 0));
function pg(e, t={}, n) {
    const r = WS(t)
      , i = r ? `${e} ${r}` : e
      , s = Array.isArray(n) ? n.join("") : n || "";
    if (e) {
        if (US.includes(e))
            return `<${i}>`
    } else
        return s;
    return `<${i}>${s}</${e}>`
}
function YS(e={}) {
    const t = new Map
      , {renderFn: n=pg, textFn: r=GS, resolvers: i={}, optimizeImages: s=!1, keyedResolvers: o=!1} = e
      , l = n !== pg
      , u = J => (re, ee) => {
        const Y = re.attrs || {};
        return ee.render(J, Y, re.children || null)
    }
      , p = (J, re) => {
        const {src: ee, alt: Y, title: Z, srcset: Q, sizes: ue} = J.attrs || {};
        let se = ee
          , ye = {};
        if (s) {
            const {src: qe, attrs: nt} = zS(ee, s);
            se = qe,
            ye = nt
        }
        const Ze = {
            src: se,
            alt: Y,
            title: Z,
            srcset: Q,
            sizes: ue,
            ...ye
        };
        return re.render("img", ic(Ze))
    }
      , h = (J, re) => {
        const {level: ee, ...Y} = J.attrs || {};
        return re.render(`h${ee}`, Y, J.children)
    }
      , g = (J, re) => {
        var ee, Y, Z, Q;
        const ue = re.render("img", {
            src: (ee = J.attrs) == null ? void 0 : ee.fallbackImage,
            alt: (Y = J.attrs) == null ? void 0 : Y.alt,
            style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
            draggable: "false",
            loading: "lazy"
        });
        return re.render("span", {
            "data-type": "emoji",
            "data-name": (Z = J.attrs) == null ? void 0 : Z.name,
            "data-emoji": (Q = J.attrs) == null ? void 0 : Q.emoji
        }, ue)
    }
      , m = (J, re) => re.render("pre", J.attrs || {}, re.render("code", {}, J.children || ""))
      , w = (J, re=!1) => ({text: ee, attrs: Y}, Z) => {
        const {class: Q, id: ue, ...se} = Y || {}
          , ye = re ? {
            class: Q,
            id: ue,
            style: qS(se) || void 0
        } : Y || {};
        return Z.render(J, ic(ye), ee)
    }
      , E = J => ge(J)
      , y = J => {
        const {marks: re, ...ee} = J;
        if ("text"in J) {
            if (re)
                return re.reduce( (Z, Q) => E({
                    ...Q,
                    text: Z
                }), E({
                    ...ee,
                    children: ee.children
                }));
            const Y = J.attrs || {};
            if (o) {
                const Z = t.get("txt") || 0;
                t.set("txt", Z + 1),
                Y.key = `txt-${Z}`
            }
            return r(ee.text, Y)
        }
        return ""
    }
      , R = (J, re) => {
        const {linktype: ee, href: Y, anchor: Z, ...Q} = J.attrs || {};
        let ue = "";
        switch (ee) {
        case Hl.ASSET:
        case Hl.URL:
            ue = Y;
            break;
        case Hl.EMAIL:
            ue = `mailto:${Y}`;
            break;
        case Hl.STORY:
            ue = Y,
            Z && (ue = `${ue}#${Z}`);
            break;
        default:
            ue = Y;
            break
        }
        const se = {
            ...Q
        };
        return ue && (se.href = ue),
        re.render("a", se, J.text)
    }
      , P = (J, re) => {
        var ee, Y;
        return console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage"),
        re.render("span", {
            blok: (ee = J == null ? void 0 : J.attrs) == null ? void 0 : ee.body[0],
            id: (Y = J.attrs) == null ? void 0 : Y.id,
            style: "display: none"
        })
    }
      , x = (J, re) => {
        const ee = {}
          , Y = re.render("tbody", {}, J.children);
        return re.render("table", ee, Y)
    }
      , v = (J, re) => {
        const ee = {};
        return re.render("tr", ee, J.children)
    }
      , k = (J, re) => {
        const {colspan: ee, rowspan: Y, colwidth: Z, backgroundColor: Q, ...ue} = J.attrs || {}
          , se = {
            ...ue
        };
        ee > 1 && (se.colspan = ee),
        Y > 1 && (se.rowspan = Y);
        const ye = [];
        return Z && ye.push(`width: ${Z}px;`),
        Q && ye.push(`background-color: ${Q};`),
        ye.length > 0 && (se.style = ye.join(" ")),
        re.render("td", ic(se), J.children)
    }
      , S = (J, re) => {
        const {colspan: ee, rowspan: Y, colwidth: Z, backgroundColor: Q, ...ue} = J.attrs || {}
          , se = {
            ...ue
        };
        ee > 1 && (se.colspan = ee),
        Y > 1 && (se.rowspan = Y);
        const ye = [];
        return Z && ye.push(`width: ${Z}px;`),
        Q && ye.push(`background-color: ${Q};`),
        ye.length > 0 && (se.style = ye.join(" ")),
        re.render("th", ic(se), J.children)
    }
      , W = new Map([[vi.DOCUMENT, u("")], [vi.HEADING, h], [vi.PARAGRAPH, u("p")], [vi.UL_LIST, u("ul")], [vi.OL_LIST, u("ol")], [vi.LIST_ITEM, u("li")], [vi.IMAGE, p], [vi.EMOJI, g], [vi.CODE_BLOCK, m], [vi.HR, u("hr")], [vi.BR, u("br")], [vi.QUOTE, u("blockquote")], [vi.COMPONENT, P], [j0.TEXT, y], [_s.LINK, R], [_s.ANCHOR, R], [_s.STYLED, w("span", !0)], [_s.BOLD, w("strong")], [_s.TEXT_STYLE, w("span", !0)], [_s.ITALIC, w("em")], [_s.UNDERLINE, w("u")], [_s.STRIKE, w("s")], [_s.CODE, w("code")], [_s.SUPERSCRIPT, w("sup")], [_s.SUBSCRIPT, w("sub")], [_s.HIGHLIGHT, w("mark")], [vi.TABLE, x], [vi.TABLE_ROW, v], [vi.TABLE_CELL, k], [vi.TABLE_HEADER, S]])
      , K = new Map([...W, ...Object.entries(i).map( ([J,re]) => [J, re])])
      , be = () => ({
        render: (J, re={}, ee) => {
            if (o && J) {
                const Y = t.get(J) || 0;
                t.set(J, Y + 1),
                re.key = `${J}-${Y}`
            }
            return n(J, re, ee)
        }
        ,
        originalResolvers: W,
        mergedResolvers: K
    });
    function fe(J) {
        const re = K.get(J.type);
        if (!re)
            return console.error("<Storyblok>", `No resolver found for node type ${J.type}`),
            "";
        const ee = be();
        if (J.type === "text")
            return re(J, ee);
        const Y = J.content ? J.content.map(ge) : void 0;
        return re({
            ...J,
            children: Y
        }, ee)
    }
    function ge(J) {
        return J.type === "doc" ? l ? J.content.map(fe) : J.content.map(fe).join("") : Array.isArray(J) ? J.map(fe) : fe(J)
    }
    return {
        render: ge
    }
}
let gg = !1;
const _g = []
  , KS = e => new Promise( (t, n) => {
    if (typeof window > "u") {
        n(new Error("Cannot load Storyblok bridge: window is undefined (server-side environment)"));
        return
    }
    if (window.storyblokRegisterEvent = i => {
        if (window.location === window.parent.location) {
            console.warn("You are not in Draft Mode or in the Visual Editor.");
            return
        }
        gg ? i() : _g.push(i)
    }
    ,
    document.getElementById("storyblok-javascript-bridge")) {
        t(void 0);
        return
    }
    const r = document.createElement("script");
    r.async = !0,
    r.src = e,
    r.id = "storyblok-javascript-bridge",
    r.onerror = i => n(i),
    r.onload = i => {
        _g.forEach(s => s()),
        gg = !0,
        t(i)
    }
    ,
    document.getElementsByTagName("head")[0].appendChild(r)
}
);
var XS = Object.defineProperty
  , QS = (e, t, n) => t in e ? XS(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : e[t] = n
  , Wr = (e, t, n) => QS(e, typeof t != "symbol" ? t + "" : t, n);
class JS extends Error {
    constructor(t) {
        super(t),
        this.name = "AbortError"
    }
}
function ZS(e, t, n) {
    if (!Number.isFinite(t))
        throw new TypeError("Expected `limit` to be a finite number");
    if (!Number.isFinite(n))
        throw new TypeError("Expected `interval` to be a finite number");
    const r = [];
    let i = []
      , s = 0
      , o = !1;
    const l = async () => {
        s++;
        const p = r.shift();
        if (p)
            try {
                const g = await e(...p.args);
                p.resolve(g)
            } catch (g) {
                p.reject(g)
            }
        const h = setTimeout( () => {
            s--,
            r.length > 0 && l(),
            i = i.filter(g => g !== h)
        }
        , n);
        i.includes(h) || i.push(h)
    }
      , u = (...p) => o ? Promise.reject(new Error("Throttled function is already aborted and not accepting new promises")) : new Promise( (h, g) => {
        r.push({
            resolve: h,
            reject: g,
            args: p
        }),
        s < t && l()
    }
    );
    return u.abort = () => {
        o = !0,
        i.forEach(clearTimeout),
        i = [],
        r.forEach(p => p.reject( () => new JS("Throttle function aborted"))),
        r.length = 0
    }
    ,
    u
}
const eT = (e="") => e.includes("/cdn/")
  , tT = (e, t=25, n=1) => ({
    ...e,
    per_page: t,
    page: n
})
  , nT = e => new Promise(t => setTimeout(t, e))
  , rT = (e=0, t) => Array.from({
    length: e
}, t)
  , iT = (e=0, t=e) => {
    const n = Math.abs(t - e) || 0
      , r = e < t ? 1 : -1;
    return rT(n, (i, s) => s * r + e)
}
  , sT = async (e, t) => Promise.all(e.map(t))
  , oT = (e=[], t) => e.map(t).reduce( (n, r) => [...n, ...r], [])
  , Rh = (e, t, n) => {
    const r = [];
    for (const i in e) {
        if (!Object.prototype.hasOwnProperty.call(e, i))
            continue;
        const s = e[i];
        if (s == null)
            continue;
        const o = n ? "" : encodeURIComponent(i);
        let l;
        typeof s == "object" ? l = Rh(s, t ? t + encodeURIComponent(`[${o}]`) : o, Array.isArray(s)) : l = `${t ? t + encodeURIComponent(`[${o}]`) : o}=${encodeURIComponent(s)}`,
        r.push(l)
    }
    return r.join("&")
}
  , mg = e => {
    const t = {
        eu: "api.storyblok.com",
        us: "api-us.storyblok.com",
        cn: "app.storyblokchina.cn",
        ap: "api-ap.storyblok.com",
        ca: "api-ca.storyblok.com"
    };
    return t[e] ?? t.eu
}
;
class aT {
    constructor(t) {
        Wr(this, "baseURL"),
        Wr(this, "timeout"),
        Wr(this, "headers"),
        Wr(this, "responseInterceptor"),
        Wr(this, "fetch"),
        Wr(this, "ejectInterceptor"),
        Wr(this, "url"),
        Wr(this, "parameters"),
        Wr(this, "fetchOptions"),
        this.baseURL = t.baseURL,
        this.headers = t.headers || new Headers,
        this.timeout = t != null && t.timeout ? t.timeout * 1e3 : 0,
        this.responseInterceptor = t.responseInterceptor,
        this.fetch = (...n) => t.fetch ? t.fetch(...n) : fetch(...n),
        this.ejectInterceptor = !1,
        this.url = "",
        this.parameters = {},
        this.fetchOptions = {}
    }
    get(t, n) {
        return this.url = t,
        this.parameters = n,
        this._methodHandler("get")
    }
    post(t, n) {
        return this.url = t,
        this.parameters = n,
        this._methodHandler("post")
    }
    put(t, n) {
        return this.url = t,
        this.parameters = n,
        this._methodHandler("put")
    }
    delete(t, n) {
        return this.url = t,
        this.parameters = n ?? {},
        this._methodHandler("delete")
    }
    async _responseHandler(t) {
        const n = []
          , r = {
            data: {},
            headers: {},
            status: 0,
            statusText: ""
        };
        t.status !== 204 && await t.json().then(i => {
            r.data = i
        }
        );
        for (const i of t.headers.entries())
            n[i[0]] = i[1];
        return r.headers = {
            ...n
        },
        r.status = t.status,
        r.statusText = t.statusText,
        r
    }
    async _methodHandler(t) {
        let n = `${this.baseURL}${this.url}`
          , r = null;
        t === "get" ? n = `${this.baseURL}${this.url}?${Rh(this.parameters)}` : r = JSON.stringify(this.parameters);
        const i = new URL(n)
          , s = new AbortController
          , {signal: o} = s;
        let l;
        this.timeout && (l = setTimeout( () => s.abort(), this.timeout));
        try {
            const u = await this.fetch(`${i}`, {
                method: t,
                headers: this.headers,
                body: r,
                signal: o,
                ...this.fetchOptions
            });
            this.timeout && clearTimeout(l);
            const p = await this._responseHandler(u);
            return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(p)) : this._statusHandler(p)
        } catch (u) {
            return {
                message: u
            }
        }
    }
    setFetchOptions(t={}) {
        Object.keys(t).length > 0 && "method"in t && delete t.method,
        this.fetchOptions = {
            ...t
        }
    }
    eject() {
        this.ejectInterceptor = !0
    }
    _normalizeErrorMessage(t) {
        if (Array.isArray(t))
            return t[0] || "Unknown error";
        if (t && typeof t == "object") {
            if (t.error)
                return t.error;
            for (const n in t) {
                if (Array.isArray(t[n]))
                    return `${n}: ${t[n][0]}`;
                if (typeof t[n] == "string")
                    return `${n}: ${t[n]}`
            }
            if (t.slug)
                return t.slug
        }
        return "Unknown error"
    }
    _statusHandler(t) {
        const n = /20[0-6]/g;
        return new Promise( (r, i) => {
            if (n.test(`${t.status}`))
                return r(t);
            const s = {
                message: this._normalizeErrorMessage(t.data),
                status: t.status,
                response: t
            };
            i(s)
        }
        )
    }
}
const yg = "SB-Agent"
  , qf = {
    defaultAgentName: "SB-JS-CLIENT",
    defaultAgentVersion: "SB-Agent-Version",
    packageVersion: "6.0.0"
}
  , lT = {
    DRAFT: "draft"
};
let sc = {};
const jo = {};
class uT {
    constructor(t, n) {
        Wr(this, "client"),
        Wr(this, "maxRetries"),
        Wr(this, "retriesDelay"),
        Wr(this, "throttle"),
        Wr(this, "accessToken"),
        Wr(this, "cache"),
        Wr(this, "resolveCounter"),
        Wr(this, "relations"),
        Wr(this, "links"),
        Wr(this, "version"),
        Wr(this, "richTextResolver"),
        Wr(this, "resolveNestedRelations"),
        Wr(this, "stringifiedStoriesCache"),
        Wr(this, "inlineAssets");
        let r = t.endpoint || n;
        if (!r) {
            const o = t.https === !1 ? "http" : "https";
            t.oauthToken ? r = `${o}://${mg(t.region)}/v1` : r = `${o}://${mg(t.region)}/v2`
        }
        const i = new Headers;
        i.set("Content-Type", "application/json"),
        i.set("Accept", "application/json"),
        t.headers && (t.headers.constructor.name === "Headers" ? t.headers.entries().toArray() : Object.entries(t.headers)).forEach( ([o,l]) => {
            i.set(o, l)
        }
        ),
        i.has(yg) || (i.set(yg, qf.defaultAgentName),
        i.set(qf.defaultAgentVersion, qf.packageVersion));
        let s = 5;
        t.oauthToken && (i.set("Authorization", t.oauthToken),
        s = 3),
        t.rateLimit && (s = t.rateLimit),
        this.maxRetries = t.maxRetries || 10,
        this.retriesDelay = 300,
        this.throttle = ZS(this.throttledRequest.bind(this), s, 1e3),
        this.accessToken = t.accessToken || "",
        this.relations = {},
        this.links = {},
        this.cache = t.cache || {
            clear: "manual"
        },
        this.resolveCounter = 0,
        this.resolveNestedRelations = t.resolveNestedRelations || !0,
        this.stringifiedStoriesCache = {},
        this.version = t.version || lT.DRAFT,
        this.inlineAssets = t.inlineAssets || !1,
        this.client = new aT({
            baseURL: r,
            timeout: t.timeout || 0,
            headers: i,
            responseInterceptor: t.responseInterceptor,
            fetch: t.fetch
        })
    }
    parseParams(t) {
        return t.token || (t.token = this.getToken()),
        t.cv || (t.cv = jo[t.token]),
        Array.isArray(t.resolve_relations) && (t.resolve_relations = t.resolve_relations.join(",")),
        typeof t.resolve_relations < "u" && (t.resolve_level = 2),
        t
    }
    factoryParamOptions(t, n) {
        return eT(t) ? this.parseParams(n) : n
    }
    makeRequest(t, n, r, i, s) {
        const o = this.factoryParamOptions(t, tT(n, r, i));
        return this.cacheResponse(t, o, void 0, s)
    }
    get(t, n={}, r) {
        n || (n = {});
        const i = `/${t}`;
        n.version = n.version || this.version;
        const s = this.factoryParamOptions(i, n);
        return this.cacheResponse(i, s, void 0, r)
    }
    async getAll(t, n={}, r, i) {
        const s = (n == null ? void 0 : n.per_page) || 25
          , o = `/${t}`.replace(/\/$/, "")
          , l = r ?? o.substring(o.lastIndexOf("/") + 1);
        n.version = n.version || this.version;
        const u = 1
          , p = await this.makeRequest(o, n, s, u, i)
          , h = p.total ? Math.ceil(p.total / s) : 1
          , g = await sT(iT(u, h), m => this.makeRequest(o, n, s, m + 1, i));
        return oT([p, ...g], m => Object.values(m.data[l]))
    }
    post(t, n={}, r) {
        const i = `/${t}`;
        return this.throttle("post", i, n, r)
    }
    put(t, n={}, r) {
        const i = `/${t}`;
        return this.throttle("put", i, n, r)
    }
    delete(t, n={}, r) {
        n || (n = {});
        const i = `/${t}`;
        return this.throttle("delete", i, n, r)
    }
    getStories(t={}, n) {
        return this._addResolveLevel(t),
        this.get("cdn/stories", t, n)
    }
    getStory(t, n={}, r) {
        return this._addResolveLevel(n),
        this.get(`cdn/stories/${t}`, n, r)
    }
    getToken() {
        return this.accessToken
    }
    ejectInterceptor() {
        this.client.eject()
    }
    _addResolveLevel(t) {
        typeof t.resolve_relations < "u" && (t.resolve_level = 2)
    }
    _cleanCopy(t) {
        return JSON.parse(JSON.stringify(t))
    }
    _insertLinks(t, n, r) {
        const i = t[n];
        i && i.fieldtype === "multilink" && i.linktype === "story" && typeof i.id == "string" && this.links[r][i.id] ? i.story = this._cleanCopy(this.links[r][i.id]) : i && i.linktype === "story" && typeof i.uuid == "string" && this.links[r][i.uuid] && (i.story = this._cleanCopy(this.links[r][i.uuid]))
    }
    getStoryReference(t, n) {
        return this.relations[t][n] ? JSON.parse(this.stringifiedStoriesCache[n] || JSON.stringify(this.relations[t][n])) : n
    }
    _resolveField(t, n, r) {
        const i = t[n];
        typeof i == "string" ? t[n] = this.getStoryReference(r, i) : Array.isArray(i) && (t[n] = i.map(s => this.getStoryReference(r, s)).filter(Boolean))
    }
    _insertRelations(t, n, r, i) {
        if (Array.isArray(r) ? r.find(o => o.endsWith(`.${n}`)) : r.endsWith(`.${n}`)) {
            this._resolveField(t, n, i);
            return
        }
        const s = t.component ? `${t.component}.${n}` : n;
        (Array.isArray(r) ? r.includes(s) : r === s) && this._resolveField(t, n, i)
    }
    iterateTree(t, n, r) {
        const i = (s, o="") => {
            if (!(!s || s._stopResolving)) {
                if (Array.isArray(s))
                    s.forEach( (l, u) => i(l, `${o}[${u}]`));
                else if (typeof s == "object")
                    for (const l in s) {
                        const u = o ? `${o}.${l}` : l;
                        (s.component && s._uid || s.type === "link") && (this._insertRelations(s, l, n, r),
                        this._insertLinks(s, l, r)),
                        i(s[l], u)
                    }
            }
        }
        ;
        i(t.content)
    }
    async resolveLinks(t, n, r) {
        let i = [];
        if (t.link_uuids) {
            const s = t.link_uuids.length
              , o = []
              , l = 50;
            for (let u = 0; u < s; u += l) {
                const p = Math.min(s, u + l);
                o.push(t.link_uuids.slice(u, p))
            }
            for (let u = 0; u < o.length; u++)
                (await this.getStories({
                    per_page: l,
                    language: n.language,
                    version: n.version,
                    starts_with: n.starts_with,
                    by_uuids: o[u].join(",")
                })).data.stories.forEach(p => {
                    i.push(p)
                }
                )
        } else
            i = t.links;
        i.forEach(s => {
            this.links[r][s.uuid] = {
                ...s,
                _stopResolving: !0
            }
        }
        )
    }
    async resolveRelations(t, n, r) {
        let i = [];
        if (t.rel_uuids) {
            const s = t.rel_uuids.length
              , o = []
              , l = 50;
            for (let u = 0; u < s; u += l) {
                const p = Math.min(s, u + l);
                o.push(t.rel_uuids.slice(u, p))
            }
            for (let u = 0; u < o.length; u++)
                (await this.getStories({
                    per_page: l,
                    language: n.language,
                    version: n.version,
                    starts_with: n.starts_with,
                    by_uuids: o[u].join(","),
                    excluding_fields: n.excluding_fields
                })).data.stories.forEach(p => {
                    i.push(p)
                }
                );
            i.length > 0 && (t.rels = i,
            delete t.rel_uuids)
        } else
            i = t.rels;
        i && i.length > 0 && i.forEach(s => {
            this.relations[r][s.uuid] = {
                ...s,
                _stopResolving: !0
            }
        }
        )
    }
    async resolveStories(t, n, r) {
        var i, s;
        let o = [];
        if (this.links[r] = {},
        this.relations[r] = {},
        typeof n.resolve_relations < "u" && n.resolve_relations.length > 0 && (typeof n.resolve_relations == "string" && (o = n.resolve_relations.split(",")),
        await this.resolveRelations(t, n, r)),
        n.resolve_links && ["1", "story", "url", "link"].includes(n.resolve_links) && ((i = t.links) != null && i.length || (s = t.link_uuids) != null && s.length) && await this.resolveLinks(t, n, r),
        this.resolveNestedRelations)
            for (const l in this.relations[r])
                this.iterateTree(this.relations[r][l], o, r);
        t.story ? this.iterateTree(t.story, o, r) : t.stories.forEach(l => {
            this.iterateTree(l, o, r)
        }
        ),
        this.stringifiedStoriesCache = {},
        delete this.links[r],
        delete this.relations[r]
    }
    async cacheResponse(t, n, r, i) {
        const s = Rh({
            url: t,
            params: n
        })
          , o = this.cacheProvider();
        if (n.version === "published" && t !== "/cdn/spaces/me") {
            const l = await o.get(s);
            if (l)
                return Promise.resolve(l)
        }
        return new Promise(async (l, u) => {
            var p;
            try {
                const h = await this.throttle("get", t, n, i);
                if (h.status !== 200)
                    return u(h);
                let g = {
                    data: h.data,
                    headers: h.headers
                };
                if ((p = h.headers) != null && p["per-page"] && (g = Object.assign({}, g, {
                    perPage: h.headers["per-page"] ? Number.parseInt(h.headers["per-page"]) : 0,
                    total: h.headers["per-page"] ? Number.parseInt(h.headers.total) : 0
                })),
                g.data.story || g.data.stories) {
                    const w = this.resolveCounter = ++this.resolveCounter % 1e3;
                    await this.resolveStories(g.data, n, `${w}`),
                    g = await this.processInlineAssets(g)
                }
                n.version === "published" && t !== "/cdn/spaces/me" && await o.set(s, g);
                const m = this.cache.clear === "onpreview" && n.version === "draft" || this.cache.clear === "auto";
                return n.token && g.data.cv && (m && jo[n.token] && jo[n.token] !== g.data.cv && await this.flushCache(),
                jo[n.token] = g.data.cv),
                l(g)
            } catch (h) {
                if (h.response && h.status === 429 && (r = typeof r > "u" ? 0 : r + 1,
                r < this.maxRetries))
                    return console.log(`Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`),
                    await nT(this.retriesDelay),
                    this.cacheResponse(t, n, r).then(l).catch(u);
                u(h)
            }
        }
        )
    }
    throttledRequest(t, n, r, i) {
        return this.client.setFetchOptions(i),
        this.client[t](n, r)
    }
    cacheVersions() {
        return jo
    }
    cacheVersion() {
        return jo[this.accessToken]
    }
    setCacheVersion(t) {
        this.accessToken && (jo[this.accessToken] = t)
    }
    clearCacheVersion() {
        this.accessToken && (jo[this.accessToken] = 0)
    }
    cacheProvider() {
        switch (this.cache.type) {
        case "memory":
            return {
                get(t) {
                    return Promise.resolve(sc[t])
                },
                getAll() {
                    return Promise.resolve(sc)
                },
                set(t, n) {
                    return sc[t] = n,
                    Promise.resolve(void 0)
                },
                flush() {
                    return sc = {},
                    Promise.resolve(void 0)
                }
            };
        case "custom":
            if (this.cache.custom)
                return this.cache.custom;
        default:
            return {
                get() {
                    return Promise.resolve()
                },
                getAll() {
                    return Promise.resolve(void 0)
                },
                set() {
                    return Promise.resolve(void 0)
                },
                flush() {
                    return Promise.resolve(void 0)
                }
            }
        }
    }
    async flushCache() {
        return await this.cacheProvider().flush(),
        this.clearCacheVersion(),
        this
    }
    async processInlineAssets(t) {
        if (!this.inlineAssets)
            return t;
        const n = r => {
            if (!r || typeof r != "object")
                return r;
            if (Array.isArray(r))
                return r.map(s => n(s));
            let i = {
                ...r
            };
            i.fieldtype === "asset" && Array.isArray(t.data.assets) && (i = {
                ...i,
                ...t.data.assets.find(s => s.id === i.id)
            });
            for (const s in i)
                typeof i[s] == "object" && (i[s] = n(i[s]));
            return i
        }
        ;
        return t.data.story && (t.data.story.content = n(t.data.story.content)),
        t.data.stories && (t.data.stories = t.data.stories.map(r => (r.content = n(r.content),
        r))),
        t
    }
}
const cT = (e={}) => {
    const {apiOptions: t} = e;
    if (!t || !t.accessToken) {
        console.error("You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication");
        return
    }
    return {
        storyblokApi: new uT(t)
    }
}
  , fT = e => {
    if (typeof e != "object" || typeof e._editable > "u")
        return {};
    try {
        const t = JSON.parse(e._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, ""));
        return t ? {
            "data-blok-c": JSON.stringify(t),
            "data-blok-uid": `${t.id}-${t.uid}`
        } : {}
    } catch {
        return {}
    }
}
;
let vg = "https://app.storyblok.com/f/storyblok-v2-latest.js";
const PA = (e, t, n={}) => {
    var r;
    const i = !(typeof window > "u") && typeof window.storyblokRegisterEvent < "u"
      , s = new URL((r = window.location) == null ? void 0 : r.href).searchParams.get("_storyblok")
      , o = s !== null && +s === e;
    if (!(!i || !o)) {
        if (!e) {
            console.warn("Story ID is not defined. Please provide a valid ID.");
            return
        }
        window.storyblokRegisterEvent( () => {
            new window.StoryblokBridge(n).on(["input", "published", "change"], l => {
                var u;
                l && (l.action === "input" && ((u = l.story) == null ? void 0 : u.id) === e ? t(l.story) : (l.action === "change" || l.action === "published") && l.storyId === e && window.location.reload())
            }
            )
        }
        )
    }
}
  , dT = (e={}) => {
    var t, n;
    const {bridge: r, accessToken: i, use: s=[], apiOptions: o={}, bridgeUrl: l} = e;
    o.accessToken = o.accessToken || i;
    const u = {
        bridge: r,
        apiOptions: o
    };
    let p = {};
    s.forEach(g => {
        p = {
            ...p,
            ...g(u)
        }
    }
    ),
    l && (vg = l);
    const h = !(typeof window > "u") && ((n = (t = window.location) == null ? void 0 : t.search) == null ? void 0 : n.includes("_storyblok_tk"));
    return r !== !1 && h && KS(vg),
    p
}
  , z0 = Mn({
    __name: "StoryblokComponent",
    props: {
        blok: {}
    },
    setup(e, {expose: t}) {
        const n = e
          , r = Ut();
        t({
            value: r
        });
        const i = typeof nl(n.blok.component) != "string"
          , s = pr("VueSDKOptions")
          , o = Ut(n.blok.component);
        return !i && s && (s.enableFallbackComponent ? (o.value = s.customFallbackComponent ?? "FallbackComponent",
        typeof nl(o.value) == "string" && console.error(`Is the Fallback component "${o.value}" registered properly?`)) : console.error(`Component could not be found for blok "${n.blok.component}"! Is it defined in main.ts as "app.component("${n.blok.component}", ${n.blok.component});"?`)),
        (l, u) => (It(),
        Wn(nl(o.value), oo({
            ref_key: "blokRef",
            ref: r
        }, {
            ...l.$props,
            ...l.$attrs
        }), null, 16))
    }
})
  , hT = e => {
    var t, n;
    return ar(z0, {
        blok: (t = e == null ? void 0 : e.attrs) == null ? void 0 : t.body[0],
        id: (n = e.attrs) == null ? void 0 : n.id
    }, e.children)
}
;
function pT(e) {
    const t = {
        renderFn: ar,
        textFn: To,
        keyedResolvers: !0,
        resolvers: {
            [vi.COMPONENT]: hT,
            ...e.resolvers
        }
    };
    return YS(t)
}
const gT = Mn({
    __name: "StoryblokRichText",
    props: {
        doc: {},
        resolvers: {}
    },
    setup(e) {
        const t = e
          , n = Ut()
          , r = () => n.value;
        return tr([ () => t.doc, () => t.resolvers], ([i,s]) => {
            const {render: o} = pT({
                resolvers: s ?? {}
            });
            n.value = o(i)
        }
        , {
            immediate: !0,
            deep: !0
        }),
        (i, s) => (It(),
        Wn(r))
    }
})
  , _T = {
    beforeMount(e, t) {
        if (t.value) {
            const n = fT(t.value);
            Object.keys(n).length > 0 && (e.setAttribute("data-blok-c", n["data-blok-c"]),
            e.setAttribute("data-blok-uid", n["data-blok-uid"]),
            e.classList.add("storyblok__outline"))
        }
    }
}
  , mT = e => {
    console.error(`You can't use ${e} if you're not loading apiPlugin. Please provide it on StoryblokVue initialization.
    `)
}
;
let Nd = null;
const yT = () => (Nd || mT("useStoryblokApi"),
Nd)
  , vT = {
    install(e, t={}) {
        e.directive("editable", _T),
        e.component("StoryblokComponent", z0),
        e.component("StoryblokRichText", gT),
        t.enableFallbackComponent && !t.customFallbackComponent && e.component("FallbackComponent", Xt( () => Vt( () => import("./CMlMa5VI.js"), [], import.meta.url)));
        const {storyblokApi: n} = dT(t);
        Nd = n || null,
        e.provide("VueSDKOptions", t)
    }
}
  , bT = ki( ({vueApp: e}) => {
    let {storyblok: t} = qs().public;
    t = JSON.parse(JSON.stringify(t)),
    e.use(vT, {
        ...t,
        use: [cT]
    })
}
);
var wT = "1.3.1";
function U0(e, t, n) {
    return Math.max(e, Math.min(t, n))
}
function DT(e, t, n) {
    return (1 - n) * e + n * t
}
function ET(e, t, n, r) {
    return DT(e, t, 1 - Math.exp(-n * r))
}
function CT(e, t) {
    return (e % t + t) % t
}
var xT = class {
    constructor() {
        St(this, "isRunning", !1);
        St(this, "value", 0);
        St(this, "from", 0);
        St(this, "to", 0);
        St(this, "currentTime", 0);
        St(this, "lerp");
        St(this, "duration");
        St(this, "easing");
        St(this, "onUpdate")
    }
    advance(e) {
        var n;
        if (!this.isRunning)
            return;
        let t = !1;
        if (this.duration && this.easing) {
            this.currentTime += e;
            const r = U0(0, this.currentTime / this.duration, 1);
            t = r >= 1;
            const i = t ? 1 : this.easing(r);
            this.value = this.from + (this.to - this.from) * i
        } else
            this.lerp ? (this.value = ET(this.value, this.to, this.lerp * 60, e),
            Math.round(this.value) === this.to && (this.value = this.to,
            t = !0)) : (this.value = this.to,
            t = !0);
        t && this.stop(),
        (n = this.onUpdate) == null || n.call(this, this.value, t)
    }
    stop() {
        this.isRunning = !1
    }
    fromTo(e, t, {lerp: n, duration: r, easing: i, onStart: s, onUpdate: o}) {
        this.from = this.value = e,
        this.to = t,
        this.lerp = n,
        this.duration = r,
        this.easing = i,
        this.currentTime = 0,
        this.isRunning = !0,
        s == null || s(),
        this.onUpdate = o
    }
}
;
function ST(e, t) {
    let n;
    return function(...r) {
        let i = this;
        clearTimeout(n),
        n = setTimeout( () => {
            n = void 0,
            e.apply(i, r)
        }
        , t)
    }
}
var TT = class {
    constructor(e, t, {autoResize: n=!0, debounce: r=250}={}) {
        St(this, "width", 0);
        St(this, "height", 0);
        St(this, "scrollHeight", 0);
        St(this, "scrollWidth", 0);
        St(this, "debouncedResize");
        St(this, "wrapperResizeObserver");
        St(this, "contentResizeObserver");
        St(this, "resize", () => {
            this.onWrapperResize(),
            this.onContentResize()
        }
        );
        St(this, "onWrapperResize", () => {
            this.wrapper instanceof Window ? (this.width = window.innerWidth,
            this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth,
            this.height = this.wrapper.clientHeight)
        }
        );
        St(this, "onContentResize", () => {
            this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight,
            this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight,
            this.scrollWidth = this.wrapper.scrollWidth)
        }
        );
        this.wrapper = e,
        this.content = t,
        n && (this.debouncedResize = ST(this.resize, r),
        this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize),
        this.wrapperResizeObserver.observe(this.wrapper)),
        this.contentResizeObserver = new ResizeObserver(this.debouncedResize),
        this.contentResizeObserver.observe(this.content)),
        this.resize()
    }
    destroy() {
        var e, t;
        (e = this.wrapperResizeObserver) == null || e.disconnect(),
        (t = this.contentResizeObserver) == null || t.disconnect(),
        this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1)
    }
    get limit() {
        return {
            x: this.scrollWidth - this.width,
            y: this.scrollHeight - this.height
        }
    }
}
  , W0 = class {
    constructor() {
        St(this, "events", {})
    }
    emit(e, ...t) {
        var r;
        let n = this.events[e] || [];
        for (let i = 0, s = n.length; i < s; i++)
            (r = n[i]) == null || r.call(n, ...t)
    }
    on(e, t) {
        var n;
        return (n = this.events[e]) != null && n.push(t) || (this.events[e] = [t]),
        () => {
            var r;
            this.events[e] = (r = this.events[e]) == null ? void 0 : r.filter(i => t !== i)
        }
    }
    off(e, t) {
        var n;
        this.events[e] = (n = this.events[e]) == null ? void 0 : n.filter(r => t !== r)
    }
    destroy() {
        this.events = {}
    }
}
  , bg = 100 / 6
  , zo = {
    passive: !1
}
  , PT = class {
    constructor(e, t={
        wheelMultiplier: 1,
        touchMultiplier: 1
    }) {
        St(this, "touchStart", {
            x: 0,
            y: 0
        });
        St(this, "lastDelta", {
            x: 0,
            y: 0
        });
        St(this, "window", {
            width: 0,
            height: 0
        });
        St(this, "emitter", new W0);
        St(this, "onTouchStart", e => {
            const {clientX: t, clientY: n} = e.targetTouches ? e.targetTouches[0] : e;
            this.touchStart.x = t,
            this.touchStart.y = n,
            this.lastDelta = {
                x: 0,
                y: 0
            },
            this.emitter.emit("scroll", {
                deltaX: 0,
                deltaY: 0,
                event: e
            })
        }
        );
        St(this, "onTouchMove", e => {
            const {clientX: t, clientY: n} = e.targetTouches ? e.targetTouches[0] : e
              , r = -(t - this.touchStart.x) * this.options.touchMultiplier
              , i = -(n - this.touchStart.y) * this.options.touchMultiplier;
            this.touchStart.x = t,
            this.touchStart.y = n,
            this.lastDelta = {
                x: r,
                y: i
            },
            this.emitter.emit("scroll", {
                deltaX: r,
                deltaY: i,
                event: e
            })
        }
        );
        St(this, "onTouchEnd", e => {
            this.emitter.emit("scroll", {
                deltaX: this.lastDelta.x,
                deltaY: this.lastDelta.y,
                event: e
            })
        }
        );
        St(this, "onWheel", e => {
            let {deltaX: t, deltaY: n, deltaMode: r} = e;
            const i = r === 1 ? bg : r === 2 ? this.window.width : 1
              , s = r === 1 ? bg : r === 2 ? this.window.height : 1;
            t *= i,
            n *= s,
            t *= this.options.wheelMultiplier,
            n *= this.options.wheelMultiplier,
            this.emitter.emit("scroll", {
                deltaX: t,
                deltaY: n,
                event: e
            })
        }
        );
        St(this, "onWindowResize", () => {
            this.window = {
                width: window.innerWidth,
                height: window.innerHeight
            }
        }
        );
        this.element = e,
        this.options = t,
        window.addEventListener("resize", this.onWindowResize, !1),
        this.onWindowResize(),
        this.element.addEventListener("wheel", this.onWheel, zo),
        this.element.addEventListener("touchstart", this.onTouchStart, zo),
        this.element.addEventListener("touchmove", this.onTouchMove, zo),
        this.element.addEventListener("touchend", this.onTouchEnd, zo)
    }
    on(e, t) {
        return this.emitter.on(e, t)
    }
    destroy() {
        this.emitter.destroy(),
        window.removeEventListener("resize", this.onWindowResize, !1),
        this.element.removeEventListener("wheel", this.onWheel, zo),
        this.element.removeEventListener("touchstart", this.onTouchStart, zo),
        this.element.removeEventListener("touchmove", this.onTouchMove, zo),
        this.element.removeEventListener("touchend", this.onTouchEnd, zo)
    }
}
  , kT = class {
    constructor({wrapper: e=window, content: t=document.documentElement, eventsTarget: n=e, smoothWheel: r=!0, syncTouch: i=!1, syncTouchLerp: s=.075, touchInertiaMultiplier: o=35, duration: l, easing: u=be => Math.min(1, 1.001 - Math.pow(2, -10 * be)), lerp: p=.1, infinite: h=!1, orientation: g="vertical", gestureOrientation: m="vertical", touchMultiplier: w=1, wheelMultiplier: E=1, autoResize: y=!0, prevent: R, virtualScroll: P, overscroll: x=!0, autoRaf: v=!1, anchors: k=!1, autoToggle: S=!1, allowNestedScroll: W=!1, __experimental__naiveDimensions: K=!1}={}) {
        St(this, "_isScrolling", !1);
        St(this, "_isStopped", !1);
        St(this, "_isLocked", !1);
        St(this, "_preventNextNativeScrollEvent", !1);
        St(this, "_resetVelocityTimeout", null);
        St(this, "__rafID", null);
        St(this, "isTouching");
        St(this, "time", 0);
        St(this, "userData", {});
        St(this, "lastVelocity", 0);
        St(this, "velocity", 0);
        St(this, "direction", 0);
        St(this, "options");
        St(this, "targetScroll");
        St(this, "animatedScroll");
        St(this, "animate", new xT);
        St(this, "emitter", new W0);
        St(this, "dimensions");
        St(this, "virtualScroll");
        St(this, "onScrollEnd", e => {
            e instanceof CustomEvent || (this.isScrolling === "smooth" || this.isScrolling === !1) && e.stopPropagation()
        }
        );
        St(this, "dispatchScrollendEvent", () => {
            this.options.wrapper.dispatchEvent(new CustomEvent("scrollend",{
                bubbles: this.options.wrapper === window,
                detail: {
                    lenisScrollEnd: !0
                }
            }))
        }
        );
        St(this, "onTransitionEnd", e => {
            if (e.propertyName.includes("overflow")) {
                const t = this.isHorizontal ? "overflow-x" : "overflow-y"
                  , n = getComputedStyle(this.rootElement)[t];
                ["hidden", "clip"].includes(n) ? this.stop() : this.start()
            }
        }
        );
        St(this, "onClick", e => {
            const n = e.composedPath().find(r => {
                var i, s, o;
                return r instanceof HTMLAnchorElement && (((i = r.getAttribute("href")) == null ? void 0 : i.startsWith("#")) || ((s = r.getAttribute("href")) == null ? void 0 : s.startsWith("/#")) || ((o = r.getAttribute("href")) == null ? void 0 : o.startsWith("./#")))
            }
            );
            if (n) {
                const r = n.getAttribute("href");
                if (r) {
                    const i = typeof this.options.anchors == "object" && this.options.anchors ? this.options.anchors : void 0;
                    let s = `#${r.split("#")[1]}`;
                    ["#", "/#", "./#", "#top", "/#top", "./#top"].includes(r) && (s = 0),
                    this.scrollTo(s, i)
                }
            }
        }
        );
        St(this, "onPointerDown", e => {
            e.button === 1 && this.reset()
        }
        );
        St(this, "onVirtualScroll", e => {
            if (typeof this.options.virtualScroll == "function" && this.options.virtualScroll(e) === !1)
                return;
            const {deltaX: t, deltaY: n, event: r} = e;
            if (this.emitter.emit("virtual-scroll", {
                deltaX: t,
                deltaY: n,
                event: r
            }),
            r.ctrlKey || r.lenisStopPropagation)
                return;
            const i = r.type.includes("touch")
              , s = r.type.includes("wheel");
            this.isTouching = r.type === "touchstart" || r.type === "touchmove";
            const o = t === 0 && n === 0;
            if (this.options.syncTouch && i && r.type === "touchstart" && o && !this.isStopped && !this.isLocked) {
                this.reset();
                return
            }
            const u = this.options.gestureOrientation === "vertical" && n === 0 || this.options.gestureOrientation === "horizontal" && t === 0;
            if (o || u)
                return;
            let p = r.composedPath();
            p = p.slice(0, p.indexOf(this.rootElement));
            const h = this.options.prevent;
            if (p.find(R => {
                var P, x, v;
                return R instanceof HTMLElement && (typeof h == "function" && (h == null ? void 0 : h(R)) || ((P = R.hasAttribute) == null ? void 0 : P.call(R, "data-lenis-prevent")) || i && ((x = R.hasAttribute) == null ? void 0 : x.call(R, "data-lenis-prevent-touch")) || s && ((v = R.hasAttribute) == null ? void 0 : v.call(R, "data-lenis-prevent-wheel")) || this.options.allowNestedScroll && this.checkNestedScroll(R, {
                    deltaX: t,
                    deltaY: n
                }))
            }
            ))
                return;
            if (this.isStopped || this.isLocked) {
                r.preventDefault();
                return
            }
            if (!(this.options.syncTouch && i || this.options.smoothWheel && s)) {
                this.isScrolling = "native",
                this.animate.stop(),
                r.lenisStopPropagation = !0;
                return
            }
            let m = n;
            this.options.gestureOrientation === "both" ? m = Math.abs(n) > Math.abs(t) ? n : t : this.options.gestureOrientation === "horizontal" && (m = t),
            (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && n > 0 || this.animatedScroll === this.limit && n < 0)) && (r.lenisStopPropagation = !0),
            r.preventDefault();
            const w = i && this.options.syncTouch
              , y = i && r.type === "touchend" && Math.abs(m) > 5;
            y && (m = this.velocity * this.options.touchInertiaMultiplier),
            this.scrollTo(this.targetScroll + m, {
                programmatic: !1,
                ...w ? {
                    lerp: y ? this.options.syncTouchLerp : 1
                } : {
                    lerp: this.options.lerp,
                    duration: this.options.duration,
                    easing: this.options.easing
                }
            })
        }
        );
        St(this, "onNativeScroll", () => {
            if (this._resetVelocityTimeout !== null && (clearTimeout(this._resetVelocityTimeout),
            this._resetVelocityTimeout = null),
            this._preventNextNativeScrollEvent) {
                this._preventNextNativeScrollEvent = !1;
                return
            }
            if (this.isScrolling === !1 || this.isScrolling === "native") {
                const e = this.animatedScroll;
                this.animatedScroll = this.targetScroll = this.actualScroll,
                this.lastVelocity = this.velocity,
                this.velocity = this.animatedScroll - e,
                this.direction = Math.sign(this.animatedScroll - e),
                this.isStopped || (this.isScrolling = "native"),
                this.emit(),
                this.velocity !== 0 && (this._resetVelocityTimeout = setTimeout( () => {
                    this.lastVelocity = this.velocity,
                    this.velocity = 0,
                    this.isScrolling = !1,
                    this.emit()
                }
                , 400))
            }
        }
        );
        St(this, "raf", e => {
            const t = e - (this.time || e);
            this.time = e,
            this.animate.advance(t * .001),
            this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
        }
        );
        window.lenisVersion = wT,
        (!e || e === document.documentElement) && (e = window),
        this.options = {
            wrapper: e,
            content: t,
            eventsTarget: n,
            smoothWheel: r,
            syncTouch: i,
            syncTouchLerp: s,
            touchInertiaMultiplier: o,
            duration: l,
            easing: u,
            lerp: p,
            infinite: h,
            gestureOrientation: m,
            orientation: g,
            touchMultiplier: w,
            wheelMultiplier: E,
            autoResize: y,
            prevent: R,
            virtualScroll: P,
            overscroll: x,
            autoRaf: v,
            anchors: k,
            autoToggle: S,
            allowNestedScroll: W,
            __experimental__naiveDimensions: K
        },
        this.dimensions = new TT(e,t,{
            autoResize: y
        }),
        this.updateClassName(),
        this.targetScroll = this.animatedScroll = this.actualScroll,
        this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1),
        this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, {
            capture: !0
        }),
        this.options.anchors && this.options.wrapper === window && this.options.wrapper.addEventListener("click", this.onClick, !1),
        this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1),
        this.virtualScroll = new PT(n,{
            touchMultiplier: w,
            wheelMultiplier: E
        }),
        this.virtualScroll.on("scroll", this.onVirtualScroll),
        this.options.autoToggle && this.rootElement.addEventListener("transitionend", this.onTransitionEnd, {
            passive: !0
        }),
        this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
    }
    destroy() {
        this.emitter.destroy(),
        this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1),
        this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, {
            capture: !0
        }),
        this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1),
        this.options.anchors && this.options.wrapper === window && this.options.wrapper.removeEventListener("click", this.onClick, !1),
        this.virtualScroll.destroy(),
        this.dimensions.destroy(),
        this.cleanUpClassName(),
        this.__rafID && cancelAnimationFrame(this.__rafID)
    }
    on(e, t) {
        return this.emitter.on(e, t)
    }
    off(e, t) {
        return this.emitter.off(e, t)
    }
    setScroll(e) {
        this.isHorizontal ? this.options.wrapper.scrollTo({
            left: e,
            behavior: "instant"
        }) : this.options.wrapper.scrollTo({
            top: e,
            behavior: "instant"
        })
    }
    resize() {
        this.dimensions.resize(),
        this.animatedScroll = this.targetScroll = this.actualScroll,
        this.emit()
    }
    emit() {
        this.emitter.emit("scroll", this)
    }
    reset() {
        this.isLocked = !1,
        this.isScrolling = !1,
        this.animatedScroll = this.targetScroll = this.actualScroll,
        this.lastVelocity = this.velocity = 0,
        this.animate.stop()
    }
    start() {
        this.isStopped && (this.reset(),
        this.isStopped = !1)
    }
    stop() {
        this.isStopped || (this.reset(),
        this.isStopped = !0)
    }
    scrollTo(e, {offset: t=0, immediate: n=!1, lock: r=!1, duration: i=this.options.duration, easing: s=this.options.easing, lerp: o=this.options.lerp, onStart: l, onComplete: u, force: p=!1, programmatic: h=!0, userData: g}={}) {
        if (!((this.isStopped || this.isLocked) && !p)) {
            if (typeof e == "string" && ["top", "left", "start"].includes(e))
                e = 0;
            else if (typeof e == "string" && ["bottom", "right", "end"].includes(e))
                e = this.limit;
            else {
                let m;
                if (typeof e == "string" ? m = document.querySelector(e) : e instanceof HTMLElement && (e != null && e.nodeType) && (m = e),
                m) {
                    if (this.options.wrapper !== window) {
                        const E = this.rootElement.getBoundingClientRect();
                        t -= this.isHorizontal ? E.left : E.top
                    }
                    const w = m.getBoundingClientRect();
                    e = (this.isHorizontal ? w.left : w.top) + this.animatedScroll
                }
            }
            if (typeof e == "number") {
                if (e += t,
                e = Math.round(e),
                this.options.infinite) {
                    if (h) {
                        this.targetScroll = this.animatedScroll = this.scroll;
                        const m = e - this.animatedScroll;
                        m > this.limit / 2 ? e = e - this.limit : m < -this.limit / 2 && (e = e + this.limit)
                    }
                } else
                    e = U0(0, e, this.limit);
                if (e === this.targetScroll) {
                    l == null || l(this),
                    u == null || u(this);
                    return
                }
                if (this.userData = g ?? {},
                n) {
                    this.animatedScroll = this.targetScroll = e,
                    this.setScroll(this.scroll),
                    this.reset(),
                    this.preventNextNativeScrollEvent(),
                    this.emit(),
                    u == null || u(this),
                    this.userData = {},
                    requestAnimationFrame( () => {
                        this.dispatchScrollendEvent()
                    }
                    );
                    return
                }
                h || (this.targetScroll = e),
                this.animate.fromTo(this.animatedScroll, e, {
                    duration: i,
                    easing: s,
                    lerp: o,
                    onStart: () => {
                        r && (this.isLocked = !0),
                        this.isScrolling = "smooth",
                        l == null || l(this)
                    }
                    ,
                    onUpdate: (m, w) => {
                        this.isScrolling = "smooth",
                        this.lastVelocity = this.velocity,
                        this.velocity = m - this.animatedScroll,
                        this.direction = Math.sign(this.velocity),
                        this.animatedScroll = m,
                        this.setScroll(this.scroll),
                        h && (this.targetScroll = m),
                        w || this.emit(),
                        w && (this.reset(),
                        this.emit(),
                        u == null || u(this),
                        this.userData = {},
                        requestAnimationFrame( () => {
                            this.dispatchScrollendEvent()
                        }
                        ),
                        this.preventNextNativeScrollEvent())
                    }
                })
            }
        }
    }
    preventNextNativeScrollEvent() {
        this._preventNextNativeScrollEvent = !0,
        requestAnimationFrame( () => {
            this._preventNextNativeScrollEvent = !1
        }
        )
    }
    checkNestedScroll(e, {deltaX: t, deltaY: n}) {
        const r = Date.now()
          , i = e._lenis ?? (e._lenis = {});
        let s, o, l, u, p, h, g, m;
        const w = this.options.gestureOrientation;
        if (r - (i.time ?? 0) > 2e3) {
            i.time = Date.now();
            const S = window.getComputedStyle(e);
            i.computedStyle = S;
            const W = S.overflowX
              , K = S.overflowY;
            if (s = ["auto", "overlay", "scroll"].includes(W),
            o = ["auto", "overlay", "scroll"].includes(K),
            i.hasOverflowX = s,
            i.hasOverflowY = o,
            !s && !o || w === "vertical" && !o || w === "horizontal" && !s)
                return !1;
            p = e.scrollWidth,
            h = e.scrollHeight,
            g = e.clientWidth,
            m = e.clientHeight,
            l = p > g,
            u = h > m,
            i.isScrollableX = l,
            i.isScrollableY = u,
            i.scrollWidth = p,
            i.scrollHeight = h,
            i.clientWidth = g,
            i.clientHeight = m
        } else
            l = i.isScrollableX,
            u = i.isScrollableY,
            s = i.hasOverflowX,
            o = i.hasOverflowY,
            p = i.scrollWidth,
            h = i.scrollHeight,
            g = i.clientWidth,
            m = i.clientHeight;
        if (!s && !o || !l && !u || w === "vertical" && (!o || !u) || w === "horizontal" && (!s || !l))
            return !1;
        let E;
        if (w === "horizontal")
            E = "x";
        else if (w === "vertical")
            E = "y";
        else {
            const S = t !== 0
              , W = n !== 0;
            S && s && l && (E = "x"),
            W && o && u && (E = "y")
        }
        if (!E)
            return !1;
        let y, R, P, x, v;
        if (E === "x")
            y = e.scrollLeft,
            R = p - g,
            P = t,
            x = s,
            v = l;
        else if (E === "y")
            y = e.scrollTop,
            R = h - m,
            P = n,
            x = o,
            v = u;
        else
            return !1;
        return (P > 0 ? y < R : y > 0) && x && v
    }
    get rootElement() {
        return this.options.wrapper === window ? document.documentElement : this.options.wrapper
    }
    get limit() {
        return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
    }
    get isHorizontal() {
        return this.options.orientation === "horizontal"
    }
    get actualScroll() {
        const e = this.options.wrapper;
        return this.isHorizontal ? e.scrollX ?? e.scrollLeft : e.scrollY ?? e.scrollTop
    }
    get scroll() {
        return this.options.infinite ? CT(this.animatedScroll, this.limit) : this.animatedScroll
    }
    get progress() {
        return this.limit === 0 ? 1 : this.scroll / this.limit
    }
    get isScrolling() {
        return this._isScrolling
    }
    set isScrolling(e) {
        this._isScrolling !== e && (this._isScrolling = e,
        this.updateClassName())
    }
    get isStopped() {
        return this._isStopped
    }
    set isStopped(e) {
        this._isStopped !== e && (this._isStopped = e,
        this.updateClassName())
    }
    get isLocked() {
        return this._isLocked
    }
    set isLocked(e) {
        this._isLocked !== e && (this._isLocked = e,
        this.updateClassName())
    }
    get isSmooth() {
        return this.isScrolling === "smooth"
    }
    get className() {
        let e = "lenis";
        return this.options.autoToggle && (e += " lenis-autoToggle"),
        this.isStopped && (e += " lenis-stopped"),
        this.isLocked && (e += " lenis-locked"),
        this.isScrolling && (e += " lenis-scrolling"),
        this.isScrolling === "smooth" && (e += " lenis-smooth"),
        e
    }
    updateClassName() {
        this.cleanUpClassName(),
        this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim()
    }
    cleanUpClassName() {
        this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim()
    }
}
  , $d = qr()
  , Bd = qr()
  , Hd = qr()
  , Oh = Symbol("LenisContext")
  , Mh = Symbol("AddCallback")
  , Lh = Symbol("RemoveCallback")
  , q0 = Mn({
    name: "VueLenis",
    props: {
        root: {
            type: Boolean,
            default: !1
        },
        autoRaf: {
            type: Boolean,
            default: !0
        },
        options: {
            type: Object,
            default: () => ({})
        },
        props: {
            type: Object,
            default: () => ({})
        }
    },
    setup(e, {slots: t, expose: n}) {
        const r = qr()
          , i = Ut()
          , s = Ut();
        n({
            lenis: r,
            wrapper: i,
            content: s
        }),
        tr([ () => e.options, i, s], () => {
            var g;
            typeof window < "u" && (!e.root && (!i.value || !s.value) || (r.value = new kT({
                ...e.options,
                ...e.root ? {} : {
                    wrapper: i.value,
                    content: s.value
                },
                autoRaf: ((g = e.options) == null ? void 0 : g.autoRaf) ?? e.autoRaf
            }),
            Aa( () => {
                var m;
                (m = r.value) == null || m.destroy(),
                r.value = void 0
            }
            )))
        }
        , {
            deep: !0,
            immediate: !0
        });
        const o = Gr([]);
        function l(h, g) {
            o.push({
                callback: h,
                priority: g
            }),
            o.sort( (m, w) => m.priority - w.priority)
        }
        function u(h) {
            o.splice(o.findIndex(g => g.callback === h), 1)
        }
        const p = h => {
            var g;
            for (let m = 0; m < o.length; m++)
                (g = o[m]) == null || g.callback(h)
        }
        ;
        return tr([r, () => e.root], ([h,g]) => {
            h == null || h.on("scroll", p),
            g && ($d.value = h,
            Bd.value = l,
            Hd.value = u,
            Aa( () => {
                $d.value = void 0,
                Bd.value = void 0,
                Hd.value = void 0
            }
            ))
        }
        , {
            immediate: !0
        }),
        e.root || (ns(Oh, r),
        ns(Mh, l),
        ns(Lh, u)),
        () => {
            var h, g;
            return e.root ? (h = t.default) == null ? void 0 : h.call(t) : ar("div", {
                ref: i,
                ...e == null ? void 0 : e.props
            }, [ar("div", {
                ref: s
            }, (g = t.default) == null ? void 0 : g.call(t))])
        }
    }
})
  , AT = e => {
    e.component("vue-lenis", q0),
    e.provide(Oh, qr(void 0)),
    e.provide(Mh, void 0),
    e.provide(Lh, void 0)
}
;
function Ru(e, t=0) {
    const n = pr(Oh)
      , r = pr(Mh)
      , i = pr(Lh)
      , s = zt( () => r || Bd.value)
      , o = zt( () => i || Hd.value)
      , l = zt( () => n != null && n.value ? n.value : $d.value);
    return typeof window < "u" && Ci( () => {
        Ci( () => {
            l.value || console.warn("No lenis instance found, either mount a root lenis instance or wrap your component in a lenis provider")
        }
        )
    }
    ),
    tr([l, s, o], ([u,p,h]) => {
        !u || !p || !h || !e || (p == null || p(e, t),
        e == null || e(u),
        Aa( () => {
            h == null || h(e)
        }
        ))
    }
    , {
        immediate: !0
    }),
    l
}
var RT = ki({
    setup(e) {
        e.vueApp.use(AT)
    }
})
  , OT = RT;
function la(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var Vl = {
    exports: {}
}, MT = Vl.exports, wg;
function LT() {
    return wg || (wg = 1,
    function(e, t) {
        (function(n, r) {
            r(t)
        }
        )(MT, function(n) {
            function r(j, a) {
                j.prototype = Object.create(a.prototype),
                j.prototype.constructor = j,
                j.__proto__ = a
            }
            function i(j) {
                if (j === void 0)
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return j
            }
            /*!
 * GSAP 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
            var s = {
                autoSleep: 120,
                force3D: "auto",
                nullTargetWarn: 1,
                units: {
                    lineHeight: ""
                }
            }, o = {
                duration: .5,
                overwrite: !1,
                delay: 0
            }, l, u, p, h = 1e8, g = 1 / h, m = Math.PI * 2, w = m / 4, E = 0, y = Math.sqrt, R = Math.cos, P = Math.sin, x = function(a) {
                return typeof a == "string"
            }, v = function(a) {
                return typeof a == "function"
            }, k = function(a) {
                return typeof a == "number"
            }, S = function(a) {
                return typeof a > "u"
            }, W = function(a) {
                return typeof a == "object"
            }, K = function(a) {
                return a !== !1
            }, be = function() {
                return typeof window < "u"
            }, fe = function(a) {
                return v(a) || x(a)
            }, ge = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
            , J = Array.isArray, re = /(?:-?\.?\d|\.)+/gi, ee = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Y = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Z = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Q = /[+-]=-?[.\d]+/, ue = /[^,'"\[\]\s]+/gi, se = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, ye, Ze, qe, nt, mt = {}, yt = {}, At, Tt = function(a) {
                return (yt = _e(a, mt)) && wn
            }, he = function(a, c) {
                return console.warn("Invalid property", a, "set to", c, "Missing plugin? gsap.registerPlugin()")
            }, ve = function(a, c) {
                return !c && console.warn(a)
            }, ae = function(a, c) {
                return a && (mt[a] = c) && yt && (yt[a] = c) || mt
            }, ze = function() {
                return 0
            }, Se = {
                suppressEvents: !0,
                isStart: !0,
                kill: !1
            }, Je = {
                suppressEvents: !0,
                kill: !1
            }, I = {
                suppressEvents: !0
            }, $ = {}, de = [], Me = {}, Te, Ne = {}, lt = {}, st = 30, Ue = [], Ge = "", wt = function(a) {
                var c = a[0], f, d;
                if (W(c) || v(c) || (a = [a]),
                !(f = (c._gsap || {}).harness)) {
                    for (d = Ue.length; d-- && !Ue[d].targetTest(c); )
                        ;
                    f = Ue[d]
                }
                for (d = a.length; d--; )
                    a[d] && (a[d]._gsap || (a[d]._gsap = new Cl(a[d],f))) || a.splice(d, 1);
                return a
            }, rt = function(a) {
                return a._gsap || wt(dt(a))[0]._gsap
            }, Dt = function(a, c, f) {
                return (f = a[c]) && v(f) ? a[c]() : S(f) && a.getAttribute && a.getAttribute(c) || f
            }, xt = function(a, c) {
                return (a = a.split(",")).forEach(c) || a
            }, Lt = function(a) {
                return Math.round(a * 1e5) / 1e5 || 0
            }, Jt = function(a) {
                return Math.round(a * 1e7) / 1e7 || 0
            }, fn = function(a, c) {
                var f = c.charAt(0)
                  , d = parseFloat(c.substr(2));
                return a = parseFloat(a),
                f === "+" ? a + d : f === "-" ? a - d : f === "*" ? a * d : a / d
            }, Fn = function(a, c) {
                for (var f = c.length, d = 0; a.indexOf(c[d]) < 0 && ++d < f; )
                    ;
                return d < f
            }, hn = function() {
                var a = de.length, c = de.slice(0), f, d;
                for (Me = {},
                de.length = 0,
                f = 0; f < a; f++)
                    d = c[f],
                    d && d._lazy && (d.render(d._lazy[0], d._lazy[1], !0)._lazy = 0)
            }, Ln = function(a) {
                return !!(a._initted || a._startAt || a.add)
            }, Kn = function(a, c, f, d) {
                de.length && !u && hn(),
                a.render(c, f, !!(u && c < 0 && Ln(a))),
                de.length && !u && hn()
            }, lr = function(a) {
                var c = parseFloat(a);
                return (c || c === 0) && (a + "").match(ue).length < 2 ? c : x(a) ? a.trim() : a
            }, ht = function(a) {
                return a
            }, X = function(a, c) {
                for (var f in c)
                    f in a || (a[f] = c[f]);
                return a
            }, ie = function(a) {
                return function(c, f) {
                    for (var d in f)
                        d in c || d === "duration" && a || d === "ease" || (c[d] = f[d])
                }
            }, _e = function(a, c) {
                for (var f in c)
                    a[f] = c[f];
                return a
            }, ke = function j(a, c) {
                for (var f in c)
                    f !== "__proto__" && f !== "constructor" && f !== "prototype" && (a[f] = W(c[f]) ? j(a[f] || (a[f] = {}), c[f]) : c[f]);
                return a
            }, Fe = function(a, c) {
                var f = {}, d;
                for (d in a)
                    d in c || (f[d] = a[d]);
                return f
            }, Ce = function(a) {
                var c = a.parent || ye
                  , f = a.keyframes ? ie(J(a.keyframes)) : X;
                if (K(a.inherit))
                    for (; c; )
                        f(a, c.vars.defaults),
                        c = c.parent || c._dp;
                return a
            }, $e = function(a, c) {
                for (var f = a.length, d = f === c.length; d && f-- && a[f] === c[f]; )
                    ;
                return f < 0
            }, Ye = function(a, c, f, d, _) {
                var D = a[d], C;
                if (_)
                    for (C = c[_]; D && D[_] > C; )
                        D = D._prev;
                return D ? (c._next = D._next,
                D._next = c) : (c._next = a[f],
                a[f] = c),
                c._next ? c._next._prev = c : a[d] = c,
                c._prev = D,
                c.parent = c._dp = a,
                c
            }, je = function(a, c, f, d) {
                f === void 0 && (f = "_first"),
                d === void 0 && (d = "_last");
                var _ = c._prev
                  , D = c._next;
                _ ? _._next = D : a[f] === c && (a[f] = D),
                D ? D._prev = _ : a[d] === c && (a[d] = _),
                c._next = c._prev = c.parent = null
            }, vt = function(a, c) {
                a.parent && (!c || a.parent.autoRemoveChildren) && a.parent.remove && a.parent.remove(a),
                a._act = 0
            }, ot = function(a, c) {
                if (a && (!c || c._end > a._dur || c._start < 0))
                    for (var f = a; f; )
                        f._dirty = 1,
                        f = f.parent;
                return a
            }, Ve = function(a) {
                for (var c = a.parent; c && c.parent; )
                    c._dirty = 1,
                    c.totalDuration(),
                    c = c.parent;
                return a
            }, ut = function(a, c, f, d) {
                return a._startAt && (u ? a._startAt.revert(Je) : a.vars.immediateRender && !a.vars.autoRevert || a._startAt.render(c, !0, d))
            }, Ft = function j(a) {
                return !a || a._ts && j(a.parent)
            }, ft = function(a) {
                return a._repeat ? gt(a._tTime, a = a.duration() + a._rDelay) * a : 0
            }, gt = function(a, c) {
                var f = Math.floor(a = Jt(a / c));
                return a && f === a ? f - 1 : f
            }, et = function(a, c) {
                return (a - c._start) * c._ts + (c._ts >= 0 ? 0 : c._dirty ? c.totalDuration() : c._tDur)
            }, Oe = function(a) {
                return a._end = Jt(a._start + (a._tDur / Math.abs(a._ts || a._rts || g) || 0))
            }, O = function(a, c) {
                var f = a._dp;
                return f && f.smoothChildTiming && a._ts && (a._start = Jt(f._time - (a._ts > 0 ? c / a._ts : ((a._dirty ? a.totalDuration() : a._tDur) - c) / -a._ts)),
                Oe(a),
                f._dirty || ot(f, a)),
                a
            }, z = function(a, c) {
                var f;
                if ((c._time || !c._dur && c._initted || c._start < a._time && (c._dur || !c.add)) && (f = et(a.rawTime(), c),
                (!c._dur || xe(0, c.totalDuration(), f) - c._tTime > g) && c.render(f, !0)),
                ot(a, c)._dp && a._initted && a._time >= a._dur && a._ts) {
                    if (a._dur < a.duration())
                        for (f = a; f._dp; )
                            f.rawTime() >= 0 && f.totalTime(f._tTime),
                            f = f._dp;
                    a._zTime = -1e-8
                }
            }, L = function(a, c, f, d) {
                return c.parent && vt(c),
                c._start = Jt((k(f) ? f : f || a !== ye ? G(a, f, c) : a._time) + c._delay),
                c._end = Jt(c._start + (c.totalDuration() / Math.abs(c.timeScale()) || 0)),
                Ye(a, c, "_first", "_last", a._sort ? "_start" : 0),
                ct(c) || (a._recent = c),
                d || z(a, c),
                a._ts < 0 && O(a, a._tTime),
                a
            }, ne = function(a, c) {
                return (mt.ScrollTrigger || he("scrollTrigger", c)) && mt.ScrollTrigger.create(c, a)
            }, le = function(a, c, f, d, _) {
                if (da(a, c, _),
                !a._initted)
                    return 1;
                if (!f && a._pt && !u && (a._dur && a.vars.lazy !== !1 || !a._dur && a.vars.lazy) && Te !== Pn.frame)
                    return de.push(a),
                    a._lazy = [_, d],
                    1
            }, Ie = function j(a) {
                var c = a.parent;
                return c && c._ts && c._initted && !c._lock && (c.rawTime() < 0 || j(c))
            }, ct = function(a) {
                var c = a.data;
                return c === "isFromStart" || c === "isStart"
            }, F = function(a, c, f, d) {
                var _ = a.ratio, D = c < 0 || !c && (!a._start && Ie(a) && !(!a._initted && ct(a)) || (a._ts < 0 || a._dp._ts < 0) && !ct(a)) ? 0 : 1, C = a._rDelay, B = 0, U, q, Ee;
                if (C && a._repeat && (B = xe(0, a._tDur, c),
                q = gt(B, C),
                a._yoyo && q & 1 && (D = 1 - D),
                q !== gt(a._tTime, C) && (_ = 1 - D,
                a.vars.repeatRefresh && a._initted && a.invalidate())),
                D !== _ || u || d || a._zTime === g || !c && a._zTime) {
                    if (!a._initted && le(a, c, d, f, B))
                        return;
                    for (Ee = a._zTime,
                    a._zTime = c || (f ? g : 0),
                    f || (f = c && !Ee),
                    a.ratio = D,
                    a._from && (D = 1 - D),
                    a._time = 0,
                    a._tTime = B,
                    U = a._pt; U; )
                        U.r(D, U.d),
                        U = U._next;
                    c < 0 && ut(a, c, f, !0),
                    a._onUpdate && !f && cr(a, "onUpdate"),
                    B && a._repeat && !f && a.parent && cr(a, "onRepeat"),
                    (c >= a._tDur || c < 0) && a.ratio === D && (D && vt(a, 1),
                    !f && !u && (cr(a, D ? "onComplete" : "onReverseComplete", !0),
                    a._prom && a._prom()))
                } else
                    a._zTime || (a._zTime = c)
            }, b = function(a, c, f) {
                var d;
                if (f > c)
                    for (d = a._first; d && d._start <= f; ) {
                        if (d.data === "isPause" && d._start > c)
                            return d;
                        d = d._next
                    }
                else
                    for (d = a._last; d && d._start >= f; ) {
                        if (d.data === "isPause" && d._start < c)
                            return d;
                        d = d._prev
                    }
            }, T = function(a, c, f, d) {
                var _ = a._repeat
                  , D = Jt(c) || 0
                  , C = a._tTime / a._tDur;
                return C && !d && (a._time *= D / a._dur),
                a._dur = D,
                a._tDur = _ ? _ < 0 ? 1e10 : Jt(D * (_ + 1) + a._rDelay * _) : D,
                C > 0 && !d && O(a, a._tTime = a._tDur * C),
                a.parent && Oe(a),
                f || ot(a.parent, a),
                a
            }, M = function(a) {
                return a instanceof oi ? ot(a) : T(a, a._dur)
            }, H = {
                _start: 0,
                endTime: ze,
                totalDuration: ze
            }, G = function j(a, c, f) {
                var d = a.labels, _ = a._recent || H, D = a.duration() >= h ? _.endTime(!1) : a._dur, C, B, U;
                return x(c) && (isNaN(c) || c in d) ? (B = c.charAt(0),
                U = c.substr(-1) === "%",
                C = c.indexOf("="),
                B === "<" || B === ">" ? (C >= 0 && (c = c.replace(/=/, "")),
                (B === "<" ? _._start : _.endTime(_._repeat >= 0)) + (parseFloat(c.substr(1)) || 0) * (U ? (C < 0 ? _ : f).totalDuration() / 100 : 1)) : C < 0 ? (c in d || (d[c] = D),
                d[c]) : (B = parseFloat(c.charAt(C - 1) + c.substr(C + 1)),
                U && f && (B = B / 100 * (J(f) ? f[0] : f).totalDuration()),
                C > 1 ? j(a, c.substr(0, C - 1), f) + B : D + B)) : c == null ? D : +c
            }, ce = function(a, c, f) {
                var d = k(c[1]), _ = (d ? 2 : 1) + (a < 2 ? 0 : 1), D = c[_], C, B;
                if (d && (D.duration = c[1]),
                D.parent = f,
                a) {
                    for (C = D,
                    B = f; B && !("immediateRender"in C); )
                        C = B.vars.defaults || {},
                        B = K(B.vars.inherit) && B.parent;
                    D.immediateRender = K(C.immediateRender),
                    a < 2 ? D.runBackwards = 1 : D.startAt = c[_ - 1]
                }
                return new jr(c[0],D,c[_ + 1])
            }, we = function(a, c) {
                return a || a === 0 ? c(a) : c
            }, xe = function(a, c, f) {
                return f < a ? a : f > c ? c : f
            }, oe = function(a, c) {
                return !x(a) || !(c = se.exec(a)) ? "" : c[1]
            }, We = function(a, c, f) {
                return we(f, function(d) {
                    return xe(a, c, d)
                })
            }, me = [].slice, Qe = function(a, c) {
                return a && W(a) && "length"in a && (!c && !a.length || a.length - 1 in a && W(a[0])) && !a.nodeType && a !== Ze
            }, tt = function(a, c, f) {
                return f === void 0 && (f = []),
                a.forEach(function(d) {
                    var _;
                    return x(d) && !c || Qe(d, 1) ? (_ = f).push.apply(_, dt(d)) : f.push(d)
                }) || f
            }, dt = function(a, c, f) {
                return p && !c && p.selector ? p.selector(a) : x(a) && !f && (qe || !Ms()) ? me.call((c || nt).querySelectorAll(a), 0) : J(a) ? tt(a, f) : Qe(a) ? me.call(a, 0) : a ? [a] : []
            }, pt = function(a) {
                return a = dt(a)[0] || ve("Invalid scope") || {},
                function(c) {
                    var f = a.current || a.nativeElement || a;
                    return dt(c, f.querySelectorAll ? f : f === a ? ve("Invalid scope") || nt.createElement("div") : a)
                }
            }, jt = function(a) {
                return a.sort(function() {
                    return .5 - Math.random()
                })
            }, Nt = function(a) {
                if (v(a))
                    return a;
                var c = W(a) ? a : {
                    each: a
                }
                  , f = Ks(c.ease)
                  , d = c.from || 0
                  , _ = parseFloat(c.base) || 0
                  , D = {}
                  , C = d > 0 && d < 1
                  , B = isNaN(d) || C
                  , U = c.axis
                  , q = d
                  , Ee = d;
                return x(d) ? q = Ee = {
                    center: .5,
                    edges: .5,
                    end: 1
                }[d] || 0 : !C && B && (q = d[0],
                Ee = d[1]),
                function(Le, He, it) {
                    var pe = (it || c).length, at = D[pe], Et, Ct, Rt, Ot, bt, qt, Gt, Kt, Mt;
                    if (!at) {
                        if (Mt = c.grid === "auto" ? 0 : (c.grid || [1, h])[1],
                        !Mt) {
                            for (Gt = -1e8; Gt < (Gt = it[Mt++].getBoundingClientRect().left) && Mt < pe; )
                                ;
                            Mt < pe && Mt--
                        }
                        for (at = D[pe] = [],
                        Et = B ? Math.min(Mt, pe) * q - .5 : d % Mt,
                        Ct = Mt === h ? 0 : B ? pe * Ee / Mt - .5 : d / Mt | 0,
                        Gt = 0,
                        Kt = h,
                        qt = 0; qt < pe; qt++)
                            Rt = qt % Mt - Et,
                            Ot = Ct - (qt / Mt | 0),
                            at[qt] = bt = U ? Math.abs(U === "y" ? Ot : Rt) : y(Rt * Rt + Ot * Ot),
                            bt > Gt && (Gt = bt),
                            bt < Kt && (Kt = bt);
                        d === "random" && jt(at),
                        at.max = Gt - Kt,
                        at.min = Kt,
                        at.v = pe = (parseFloat(c.amount) || parseFloat(c.each) * (Mt > pe ? pe - 1 : U ? U === "y" ? pe / Mt : Mt : Math.max(Mt, pe / Mt)) || 0) * (d === "edges" ? -1 : 1),
                        at.b = pe < 0 ? _ - pe : _,
                        at.u = oe(c.amount || c.each) || 0,
                        f = f && pe < 0 ? Ys(f) : f
                    }
                    return pe = (at[Le] - at.min) / at.max || 0,
                    Jt(at.b + (f ? f(pe) : pe) * at.v) + at.u
                }
            }, Pt = function(a) {
                var c = Math.pow(10, ((a + "").split(".")[1] || "").length);
                return function(f) {
                    var d = Jt(Math.round(parseFloat(f) / a) * a * c);
                    return (d - d % 1) / c + (k(f) ? 0 : oe(f))
                }
            }, Bt = function(a, c) {
                var f = J(a), d, _;
                return !f && W(a) && (d = f = a.radius || h,
                a.values ? (a = dt(a.values),
                (_ = !k(a[0])) && (d *= d)) : a = Pt(a.increment)),
                we(c, f ? v(a) ? function(D) {
                    return _ = a(D),
                    Math.abs(_ - D) <= d ? _ : D
                }
                : function(D) {
                    for (var C = parseFloat(_ ? D.x : D), B = parseFloat(_ ? D.y : 0), U = h, q = 0, Ee = a.length, Le, He; Ee--; )
                        _ ? (Le = a[Ee].x - C,
                        He = a[Ee].y - B,
                        Le = Le * Le + He * He) : Le = Math.abs(a[Ee] - C),
                        Le < U && (U = Le,
                        q = Ee);
                    return q = !d || U <= d ? a[q] : D,
                    _ || q === D || k(D) ? q : q + oe(D)
                }
                : Pt(a))
            }, $t = function(a, c, f, d) {
                return we(J(a) ? !c : f === !0 ? !!(f = 0) : !d, function() {
                    return J(a) ? a[~~(Math.random() * a.length)] : (f = f || 1e-5) && (d = f < 1 ? Math.pow(10, (f + "").length - 2) : 1) && Math.floor(Math.round((a - f / 2 + Math.random() * (c - a + f * .99)) / f) * f * d) / d
                })
            }, nn = function() {
                for (var a = arguments.length, c = new Array(a), f = 0; f < a; f++)
                    c[f] = arguments[f];
                return function(d) {
                    return c.reduce(function(_, D) {
                        return D(_)
                    }, d)
                }
            }, Zt = function(a, c) {
                return function(f) {
                    return a(parseFloat(f)) + (c || oe(f))
                }
            }, Yt = function(a, c, f) {
                return br(a, c, 0, 1, f)
            }, ln = function(a, c, f) {
                return we(f, function(d) {
                    return a[~~c(d)]
                })
            }, pn = function j(a, c, f) {
                var d = c - a;
                return J(a) ? ln(a, j(0, a.length), c) : we(f, function(_) {
                    return (d + (_ - a) % d) % d + a
                })
            }, Vr = function j(a, c, f) {
                var d = c - a
                  , _ = d * 2;
                return J(a) ? ln(a, j(0, a.length - 1), c) : we(f, function(D) {
                    return D = (_ + (D - a) % _) % _ || 0,
                    a + (D > d ? _ - D : D)
                })
            }, ur = function(a) {
                for (var c = 0, f = "", d, _, D, C; ~(d = a.indexOf("random(", c)); )
                    D = a.indexOf(")", d),
                    C = a.charAt(d + 7) === "[",
                    _ = a.substr(d + 7, D - d - 7).match(C ? ue : re),
                    f += a.substr(c, d - c) + $t(C ? _ : +_[0], C ? 0 : +_[1], +_[2] || 1e-5),
                    c = D + 1;
                return f + a.substr(c, a.length - c)
            }, br = function(a, c, f, d, _) {
                var D = c - a
                  , C = d - f;
                return we(_, function(B) {
                    return f + ((B - a) / D * C || 0)
                })
            }, wr = function j(a, c, f, d) {
                var _ = isNaN(a + c) ? 0 : function(He) {
                    return (1 - He) * a + He * c
                }
                ;
                if (!_) {
                    var D = x(a), C = {}, B, U, q, Ee, Le;
                    if (f === !0 && (d = 1) && (f = null),
                    D)
                        a = {
                            p: a
                        },
                        c = {
                            p: c
                        };
                    else if (J(a) && !J(c)) {
                        for (q = [],
                        Ee = a.length,
                        Le = Ee - 2,
                        U = 1; U < Ee; U++)
                            q.push(j(a[U - 1], a[U]));
                        Ee--,
                        _ = function(it) {
                            it *= Ee;
                            var pe = Math.min(Le, ~~it);
                            return q[pe](it - pe)
                        }
                        ,
                        f = c
                    } else
                        d || (a = _e(J(a) ? [] : {}, a));
                    if (!q) {
                        for (B in c)
                            Is.call(C, a, B, "get", c[B]);
                        _ = function(it) {
                            return Ha(it, C) || (D ? a.p : a)
                        }
                    }
                }
                return we(f, _)
            }, Pr = function(a, c, f) {
                var d = a.labels, _ = h, D, C, B;
                for (D in d)
                    C = d[D] - c,
                    C < 0 == !!f && C && _ > (C = Math.abs(C)) && (B = D,
                    _ = C);
                return B
            }, cr = function(a, c, f) {
                var d = a.vars, _ = d[c], D = p, C = a._ctx, B, U, q;
                if (_)
                    return B = d[c + "Params"],
                    U = d.callbackScope || a,
                    f && de.length && hn(),
                    C && (p = C),
                    q = B ? _.apply(U, B) : _.call(U),
                    p = D,
                    q
            }, fr = function(a) {
                return vt(a),
                a.scrollTrigger && a.scrollTrigger.kill(!!u),
                a.progress() < 1 && cr(a, "onInterrupt"),
                a
            }, qn, $n = [], Xn = function(a) {
                if (a)
                    if (a = !a.name && a.default || a,
                    be() || a.headless) {
                        var c = a.name
                          , f = v(a)
                          , d = c && !f && a.init ? function() {
                            this._props = []
                        }
                        : a
                          , _ = {
                            init: ze,
                            render: Ha,
                            add: Is,
                            kill: Va,
                            modifier: Pl,
                            rawVars: 0
                        }
                          , D = {
                            targetTest: 0,
                            get: 0,
                            getSetter: Ba,
                            aliases: {},
                            register: 0
                        };
                        if (Ms(),
                        a !== d) {
                            if (Ne[c])
                                return;
                            X(d, X(Fe(a, _), D)),
                            _e(d.prototype, _e(_, Fe(a, D))),
                            Ne[d.prop = c] = d,
                            a.targetTest && (Ue.push(d),
                            $[c] = 1),
                            c = (c === "css" ? "CSS" : c.charAt(0).toUpperCase() + c.substr(1)) + "Plugin"
                        }
                        ae(c, d),
                        a.register && a.register(wn, d, Ni)
                    } else
                        $n.push(a)
            }, en = 255, Mr = {
                aqua: [0, en, en],
                lime: [0, en, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, en],
                navy: [0, 0, 128],
                white: [en, en, en],
                olive: [128, 128, 0],
                yellow: [en, en, 0],
                orange: [en, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [en, 0, 0],
                pink: [en, 192, 203],
                cyan: [0, en, en],
                transparent: [en, en, en, 0]
            }, hi = function(a, c, f) {
                return a += a < 0 ? 1 : a > 1 ? -1 : 0,
                (a * 6 < 1 ? c + (f - c) * a * 6 : a < .5 ? f : a * 3 < 2 ? c + (f - c) * (2 / 3 - a) * 6 : c) * en + .5 | 0
            }, _r = function(a, c, f) {
                var d = a ? k(a) ? [a >> 16, a >> 8 & en, a & en] : 0 : Mr.black, _, D, C, B, U, q, Ee, Le, He, it;
                if (!d) {
                    if (a.substr(-1) === "," && (a = a.substr(0, a.length - 1)),
                    Mr[a])
                        d = Mr[a];
                    else if (a.charAt(0) === "#") {
                        if (a.length < 6 && (_ = a.charAt(1),
                        D = a.charAt(2),
                        C = a.charAt(3),
                        a = "#" + _ + _ + D + D + C + C + (a.length === 5 ? a.charAt(4) + a.charAt(4) : "")),
                        a.length === 9)
                            return d = parseInt(a.substr(1, 6), 16),
                            [d >> 16, d >> 8 & en, d & en, parseInt(a.substr(7), 16) / 255];
                        a = parseInt(a.substr(1), 16),
                        d = [a >> 16, a >> 8 & en, a & en]
                    } else if (a.substr(0, 3) === "hsl") {
                        if (d = it = a.match(re),
                        !c)
                            B = +d[0] % 360 / 360,
                            U = +d[1] / 100,
                            q = +d[2] / 100,
                            D = q <= .5 ? q * (U + 1) : q + U - q * U,
                            _ = q * 2 - D,
                            d.length > 3 && (d[3] *= 1),
                            d[0] = hi(B + 1 / 3, _, D),
                            d[1] = hi(B, _, D),
                            d[2] = hi(B - 1 / 3, _, D);
                        else if (~a.indexOf("="))
                            return d = a.match(ee),
                            f && d.length < 4 && (d[3] = 1),
                            d
                    } else
                        d = a.match(re) || Mr.transparent;
                    d = d.map(Number)
                }
                return c && !it && (_ = d[0] / en,
                D = d[1] / en,
                C = d[2] / en,
                Ee = Math.max(_, D, C),
                Le = Math.min(_, D, C),
                q = (Ee + Le) / 2,
                Ee === Le ? B = U = 0 : (He = Ee - Le,
                U = q > .5 ? He / (2 - Ee - Le) : He / (Ee + Le),
                B = Ee === _ ? (D - C) / He + (D < C ? 6 : 0) : Ee === D ? (C - _) / He + 2 : (_ - D) / He + 4,
                B *= 60),
                d[0] = ~~(B + .5),
                d[1] = ~~(U * 100 + .5),
                d[2] = ~~(q * 100 + .5)),
                f && d.length < 4 && (d[3] = 1),
                d
            }, Fi = function(a) {
                var c = []
                  , f = []
                  , d = -1;
                return a.split(Qn).forEach(function(_) {
                    var D = _.match(Y) || [];
                    c.push.apply(c, D),
                    f.push(d += D.length + 1)
                }),
                c.c = f,
                c
            }, Gn = function(a, c, f) {
                var d = "", _ = (a + d).match(Qn), D = c ? "hsla(" : "rgba(", C = 0, B, U, q, Ee;
                if (!_)
                    return a;
                if (_ = _.map(function(Le) {
                    return (Le = _r(Le, c, 1)) && D + (c ? Le[0] + "," + Le[1] + "%," + Le[2] + "%," + Le[3] : Le.join(",")) + ")"
                }),
                f && (q = Fi(a),
                B = f.c,
                B.join(d) !== q.c.join(d)))
                    for (U = a.replace(Qn, "1").split(Y),
                    Ee = U.length - 1; C < Ee; C++)
                        d += U[C] + (~B.indexOf(C) ? _.shift() || D + "0,0,0,0)" : (q.length ? q : _.length ? _ : f).shift());
                if (!U)
                    for (U = a.split(Qn),
                    Ee = U.length - 1; C < Ee; C++)
                        d += U[C] + _[C];
                return d + U[Ee]
            }, Qn = function() {
                var j = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", a;
                for (a in Mr)
                    j += "|" + a + "\\b";
                return new RegExp(j + ")","gi")
            }(), Os = /hsl[a]?\(/, gn = function(a) {
                var c = a.join(" "), f;
                if (Qn.lastIndex = 0,
                Qn.test(c))
                    return f = Os.test(c),
                    a[1] = Gn(a[1], f),
                    a[0] = Gn(a[0], f, Fi(a[1])),
                    !0
            }, Jr, Pn = function() {
                var j = Date.now, a = 500, c = 33, f = j(), d = f, _ = 1e3 / 240, D = _, C = [], B, U, q, Ee, Le, He, it = function pe(at) {
                    var Et = j() - d, Ct = at === !0, Rt, Ot, bt, qt;
                    if ((Et > a || Et < 0) && (f += Et - c),
                    d += Et,
                    bt = d - f,
                    Rt = bt - D,
                    (Rt > 0 || Ct) && (qt = ++Ee.frame,
                    Le = bt - Ee.time * 1e3,
                    Ee.time = bt = bt / 1e3,
                    D += Rt + (Rt >= _ ? 4 : _ - Rt),
                    Ot = 1),
                    Ct || (B = U(pe)),
                    Ot)
                        for (He = 0; He < C.length; He++)
                            C[He](bt, Le, qt, at)
                };
                return Ee = {
                    time: 0,
                    frame: 0,
                    tick: function() {
                        it(!0)
                    },
                    deltaRatio: function(at) {
                        return Le / (1e3 / (at || 60))
                    },
                    wake: function() {
                        At && (!qe && be() && (Ze = qe = window,
                        nt = Ze.document || {},
                        mt.gsap = wn,
                        (Ze.gsapVersions || (Ze.gsapVersions = [])).push(wn.version),
                        Tt(yt || Ze.GreenSockGlobals || !Ze.gsap && Ze || {}),
                        $n.forEach(Xn)),
                        q = typeof requestAnimationFrame < "u" && requestAnimationFrame,
                        B && Ee.sleep(),
                        U = q || function(at) {
                            return setTimeout(at, D - Ee.time * 1e3 + 1 | 0)
                        }
                        ,
                        Jr = 1,
                        it(2))
                    },
                    sleep: function() {
                        (q ? cancelAnimationFrame : clearTimeout)(B),
                        Jr = 0,
                        U = ze
                    },
                    lagSmoothing: function(at, Et) {
                        a = at || 1 / 0,
                        c = Math.min(Et || 33, a)
                    },
                    fps: function(at) {
                        _ = 1e3 / (at || 240),
                        D = Ee.time * 1e3 + _
                    },
                    add: function(at, Et, Ct) {
                        var Rt = Et ? function(Ot, bt, qt, Gt) {
                            at(Ot, bt, qt, Gt),
                            Ee.remove(Rt)
                        }
                        : at;
                        return Ee.remove(at),
                        C[Ct ? "unshift" : "push"](Rt),
                        Ms(),
                        Rt
                    },
                    remove: function(at, Et) {
                        ~(Et = C.indexOf(at)) && C.splice(Et, 1) && He >= Et && He--
                    },
                    _listeners: C
                },
                Ee
            }(), Ms = function() {
                return !Jr && Pn.wake()
            }, bn = {}, xn = /^[\d.\-M][\d.\-,\s]/, Gs = /["']/g, lo = function(a) {
                for (var c = {}, f = a.substr(1, a.length - 3).split(":"), d = f[0], _ = 1, D = f.length, C, B, U; _ < D; _++)
                    B = f[_],
                    C = _ !== D - 1 ? B.lastIndexOf(",") : B.length,
                    U = B.substr(0, C),
                    c[d] = isNaN(U) ? U.replace(Gs, "").trim() : +U,
                    d = B.substr(C + 1).trim();
                return c
            }, mf = function(a) {
                var c = a.indexOf("(") + 1
                  , f = a.indexOf(")")
                  , d = a.indexOf("(", c);
                return a.substring(c, ~d && d < f ? a.indexOf(")", f + 1) : f)
            }, Nu = function(a) {
                var c = (a + "").split("(")
                  , f = bn[c[0]];
                return f && c.length > 1 && f.config ? f.config.apply(null, ~a.indexOf("{") ? [lo(c[1])] : mf(a).split(",").map(lr)) : bn._CE && xn.test(a) ? bn._CE("", a) : f
            }, Ys = function(a) {
                return function(c) {
                    return 1 - a(1 - c)
                }
            }, Ii = function j(a, c) {
                for (var f = a._first, d; f; )
                    f instanceof oi ? j(f, c) : f.vars.yoyoEase && (!f._yoyo || !f._repeat) && f._yoyo !== c && (f.timeline ? j(f.timeline, c) : (d = f._ease,
                    f._ease = f._yEase,
                    f._yEase = d,
                    f._yoyo = c)),
                    f = f._next
            }, Ks = function(a, c) {
                return a && (v(a) ? a : bn[a] || Nu(a)) || c
            }, Ls = function(a, c, f, d) {
                f === void 0 && (f = function(B) {
                    return 1 - c(1 - B)
                }
                ),
                d === void 0 && (d = function(B) {
                    return B < .5 ? c(B * 2) / 2 : 1 - c((1 - B) * 2) / 2
                }
                );
                var _ = {
                    easeIn: c,
                    easeOut: f,
                    easeInOut: d
                }, D;
                return xt(a, function(C) {
                    bn[C] = mt[C] = _,
                    bn[D = C.toLowerCase()] = f;
                    for (var B in _)
                        bn[D + (B === "easeIn" ? ".in" : B === "easeOut" ? ".out" : ".inOut")] = bn[C + "." + B] = _[B]
                }),
                _
            }, El = function(a) {
                return function(c) {
                    return c < .5 ? (1 - a(1 - c * 2)) / 2 : .5 + a((c - .5) * 2) / 2
                }
            }, pi = function j(a, c, f) {
                var d = c >= 1 ? c : 1
                  , _ = (f || (a ? .3 : .45)) / (c < 1 ? c : 1)
                  , D = _ / m * (Math.asin(1 / d) || 0)
                  , C = function(q) {
                    return q === 1 ? 1 : d * Math.pow(2, -10 * q) * P((q - D) * _) + 1
                }
                  , B = a === "out" ? C : a === "in" ? function(U) {
                    return 1 - C(1 - U)
                }
                : El(C);
                return _ = m / _,
                B.config = function(U, q) {
                    return j(a, U, q)
                }
                ,
                B
            }, Fs = function j(a, c) {
                c === void 0 && (c = 1.70158);
                var f = function(D) {
                    return D ? --D * D * ((c + 1) * D + c) + 1 : 0
                }
                  , d = a === "out" ? f : a === "in" ? function(_) {
                    return 1 - f(1 - _)
                }
                : El(f);
                return d.config = function(_) {
                    return j(a, _)
                }
                ,
                d
            };
            xt("Linear,Quad,Cubic,Quart,Quint,Strong", function(j, a) {
                var c = a < 5 ? a + 1 : a;
                Ls(j + ",Power" + (c - 1), a ? function(f) {
                    return Math.pow(f, c)
                }
                : function(f) {
                    return f
                }
                , function(f) {
                    return 1 - Math.pow(1 - f, c)
                }, function(f) {
                    return f < .5 ? Math.pow(f * 2, c) / 2 : 1 - Math.pow((1 - f) * 2, c) / 2
                })
            }),
            bn.Linear.easeNone = bn.none = bn.Linear.easeIn,
            Ls("Elastic", pi("in"), pi("out"), pi()),
            function(j, a) {
                var c = 1 / a
                  , f = 2 * c
                  , d = 2.5 * c
                  , _ = function(C) {
                    return C < c ? j * C * C : C < f ? j * Math.pow(C - 1.5 / a, 2) + .75 : C < d ? j * (C -= 2.25 / a) * C + .9375 : j * Math.pow(C - 2.625 / a, 2) + .984375
                };
                Ls("Bounce", function(D) {
                    return 1 - _(1 - D)
                }, _)
            }(7.5625, 2.75),
            Ls("Expo", function(j) {
                return Math.pow(2, 10 * (j - 1)) * j + j * j * j * j * j * j * (1 - j)
            }),
            Ls("Circ", function(j) {
                return -(y(1 - j * j) - 1)
            }),
            Ls("Sine", function(j) {
                return j === 1 ? 1 : -R(j * w) + 1
            }),
            Ls("Back", Fs("in"), Fs("out"), Fs()),
            bn.SteppedEase = bn.steps = mt.SteppedEase = {
                config: function(a, c) {
                    a === void 0 && (a = 1);
                    var f = 1 / a
                      , d = a + (c ? 0 : 1)
                      , _ = c ? 1 : 0
                      , D = 1 - g;
                    return function(C) {
                        return ((d * xe(0, D, C) | 0) + _) * f
                    }
                }
            },
            o.ease = bn["quad.out"],
            xt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(j) {
                return Ge += j + "," + j + "Params,"
            });
            var Cl = function(a, c) {
                this.id = E++,
                a._gsap = this,
                this.target = a,
                this.harness = c,
                this.get = c ? c.get : Dt,
                this.set = c ? c.getSetter : Ba
            }
              , ca = function() {
                function j(c) {
                    this.vars = c,
                    this._delay = +c.delay || 0,
                    (this._repeat = c.repeat === 1 / 0 ? -2 : c.repeat || 0) && (this._rDelay = c.repeatDelay || 0,
                    this._yoyo = !!c.yoyo || !!c.yoyoEase),
                    this._ts = 1,
                    T(this, +c.duration, 1, 1),
                    this.data = c.data,
                    p && (this._ctx = p,
                    p.data.push(this)),
                    Jr || Pn.wake()
                }
                var a = j.prototype;
                return a.delay = function(f) {
                    return f || f === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + f - this._delay),
                    this._delay = f,
                    this) : this._delay
                }
                ,
                a.duration = function(f) {
                    return arguments.length ? this.totalDuration(this._repeat > 0 ? f + (f + this._rDelay) * this._repeat : f) : this.totalDuration() && this._dur
                }
                ,
                a.totalDuration = function(f) {
                    return arguments.length ? (this._dirty = 0,
                    T(this, this._repeat < 0 ? f : (f - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                }
                ,
                a.totalTime = function(f, d) {
                    if (Ms(),
                    !arguments.length)
                        return this._tTime;
                    var _ = this._dp;
                    if (_ && _.smoothChildTiming && this._ts) {
                        for (O(this, f),
                        !_._dp || _.parent || z(_, this); _ && _.parent; )
                            _.parent._time !== _._start + (_._ts >= 0 ? _._tTime / _._ts : (_.totalDuration() - _._tTime) / -_._ts) && _.totalTime(_._tTime, !0),
                            _ = _.parent;
                        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && f < this._tDur || this._ts < 0 && f > 0 || !this._tDur && !f) && L(this._dp, this, this._start - this._delay)
                    }
                    return (this._tTime !== f || !this._dur && !d || this._initted && Math.abs(this._zTime) === g || !f && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = f),
                    Kn(this, f, d)),
                    this
                }
                ,
                a.time = function(f, d) {
                    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), f + ft(this)) % (this._dur + this._rDelay) || (f ? this._dur : 0), d) : this._time
                }
                ,
                a.totalProgress = function(f, d) {
                    return arguments.length ? this.totalTime(this.totalDuration() * f, d) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0
                }
                ,
                a.progress = function(f, d) {
                    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - f : f) + ft(this), d) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
                }
                ,
                a.iteration = function(f, d) {
                    var _ = this.duration() + this._rDelay;
                    return arguments.length ? this.totalTime(this._time + (f - 1) * _, d) : this._repeat ? gt(this._tTime, _) + 1 : 1
                }
                ,
                a.timeScale = function(f, d) {
                    if (!arguments.length)
                        return this._rts === -1e-8 ? 0 : this._rts;
                    if (this._rts === f)
                        return this;
                    var _ = this.parent && this._ts ? et(this.parent._time, this) : this._tTime;
                    return this._rts = +f || 0,
                    this._ts = this._ps || f === -1e-8 ? 0 : this._rts,
                    this.totalTime(xe(-Math.abs(this._delay), this.totalDuration(), _), d !== !1),
                    Oe(this),
                    Ve(this)
                }
                ,
                a.paused = function(f) {
                    return arguments.length ? (this._ps !== f && (this._ps = f,
                    f ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
                    this._ts = this._act = 0) : (Ms(),
                    this._ts = this._rts,
                    this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== g && (this._tTime -= g)))),
                    this) : this._ps
                }
                ,
                a.startTime = function(f) {
                    if (arguments.length) {
                        this._start = f;
                        var d = this.parent || this._dp;
                        return d && (d._sort || !this.parent) && L(d, this, f - this._delay),
                        this
                    }
                    return this._start
                }
                ,
                a.endTime = function(f) {
                    return this._start + (K(f) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                }
                ,
                a.rawTime = function(f) {
                    var d = this.parent || this._dp;
                    return d ? f && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? et(d.rawTime(f), this) : this._tTime : this._tTime
                }
                ,
                a.revert = function(f) {
                    f === void 0 && (f = I);
                    var d = u;
                    return u = f,
                    Ln(this) && (this.timeline && this.timeline.revert(f),
                    this.totalTime(-.01, f.suppressEvents)),
                    this.data !== "nested" && f.kill !== !1 && this.kill(),
                    u = d,
                    this
                }
                ,
                a.globalTime = function(f) {
                    for (var d = this, _ = arguments.length ? f : d.rawTime(); d; )
                        _ = d._start + _ / (Math.abs(d._ts) || 1),
                        d = d._dp;
                    return !this.parent && this._sat ? this._sat.globalTime(f) : _
                }
                ,
                a.repeat = function(f) {
                    return arguments.length ? (this._repeat = f === 1 / 0 ? -2 : f,
                    M(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
                }
                ,
                a.repeatDelay = function(f) {
                    if (arguments.length) {
                        var d = this._time;
                        return this._rDelay = f,
                        M(this),
                        d ? this.time(d) : this
                    }
                    return this._rDelay
                }
                ,
                a.yoyo = function(f) {
                    return arguments.length ? (this._yoyo = f,
                    this) : this._yoyo
                }
                ,
                a.seek = function(f, d) {
                    return this.totalTime(G(this, f), K(d))
                }
                ,
                a.restart = function(f, d) {
                    return this.play().totalTime(f ? -this._delay : 0, K(d)),
                    this._dur || (this._zTime = -1e-8),
                    this
                }
                ,
                a.play = function(f, d) {
                    return f != null && this.seek(f, d),
                    this.reversed(!1).paused(!1)
                }
                ,
                a.reverse = function(f, d) {
                    return f != null && this.seek(f || this.totalDuration(), d),
                    this.reversed(!0).paused(!1)
                }
                ,
                a.pause = function(f, d) {
                    return f != null && this.seek(f, d),
                    this.paused(!0)
                }
                ,
                a.resume = function() {
                    return this.paused(!1)
                }
                ,
                a.reversed = function(f) {
                    return arguments.length ? (!!f !== this.reversed() && this.timeScale(-this._rts || (f ? -1e-8 : 0)),
                    this) : this._rts < 0
                }
                ,
                a.invalidate = function() {
                    return this._initted = this._act = 0,
                    this._zTime = -1e-8,
                    this
                }
                ,
                a.isActive = function() {
                    var f = this.parent || this._dp, d = this._start, _;
                    return !!(!f || this._ts && this._initted && f.isActive() && (_ = f.rawTime(!0)) >= d && _ < this.endTime(!0) - g)
                }
                ,
                a.eventCallback = function(f, d, _) {
                    var D = this.vars;
                    return arguments.length > 1 ? (d ? (D[f] = d,
                    _ && (D[f + "Params"] = _),
                    f === "onUpdate" && (this._onUpdate = d)) : delete D[f],
                    this) : D[f]
                }
                ,
                a.then = function(f) {
                    var d = this;
                    return new Promise(function(_) {
                        var D = v(f) ? f : ht
                          , C = function() {
                            var U = d.then;
                            d.then = null,
                            v(D) && (D = D(d)) && (D.then || D === d) && (d.then = U),
                            _(D),
                            d.then = U
                        };
                        d._initted && d.totalProgress() === 1 && d._ts >= 0 || !d._tTime && d._ts < 0 ? C() : d._prom = C
                    }
                    )
                }
                ,
                a.kill = function() {
                    fr(this)
                }
                ,
                j
            }();
            X(ca.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: null,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -1e-8,
                _prom: 0,
                _ps: !1,
                _rts: 1
            });
            var oi = function(j) {
                r(a, j);
                function a(f, d) {
                    var _;
                    return f === void 0 && (f = {}),
                    _ = j.call(this, f) || this,
                    _.labels = {},
                    _.smoothChildTiming = !!f.smoothChildTiming,
                    _.autoRemoveChildren = !!f.autoRemoveChildren,
                    _._sort = K(f.sortChildren),
                    ye && L(f.parent || ye, i(_), d),
                    f.reversed && _.reverse(),
                    f.paused && _.paused(!0),
                    f.scrollTrigger && ne(i(_), f.scrollTrigger),
                    _
                }
                var c = a.prototype;
                return c.to = function(d, _, D) {
                    return ce(0, arguments, this),
                    this
                }
                ,
                c.from = function(d, _, D) {
                    return ce(1, arguments, this),
                    this
                }
                ,
                c.fromTo = function(d, _, D, C) {
                    return ce(2, arguments, this),
                    this
                }
                ,
                c.set = function(d, _, D) {
                    return _.duration = 0,
                    _.parent = this,
                    Ce(_).repeatDelay || (_.repeat = 0),
                    _.immediateRender = !!_.immediateRender,
                    new jr(d,_,G(this, D),1),
                    this
                }
                ,
                c.call = function(d, _, D) {
                    return L(this, jr.delayedCall(0, d, _), D)
                }
                ,
                c.staggerTo = function(d, _, D, C, B, U, q) {
                    return D.duration = _,
                    D.stagger = D.stagger || C,
                    D.onComplete = U,
                    D.onCompleteParams = q,
                    D.parent = this,
                    new jr(d,D,G(this, B)),
                    this
                }
                ,
                c.staggerFrom = function(d, _, D, C, B, U, q) {
                    return D.runBackwards = 1,
                    Ce(D).immediateRender = K(D.immediateRender),
                    this.staggerTo(d, _, D, C, B, U, q)
                }
                ,
                c.staggerFromTo = function(d, _, D, C, B, U, q, Ee) {
                    return C.startAt = D,
                    Ce(C).immediateRender = K(C.immediateRender),
                    this.staggerTo(d, _, C, B, U, q, Ee)
                }
                ,
                c.render = function(d, _, D) {
                    var C = this._time, B = this._dirty ? this.totalDuration() : this._tDur, U = this._dur, q = d <= 0 ? 0 : Jt(d), Ee = this._zTime < 0 != d < 0 && (this._initted || !U), Le, He, it, pe, at, Et, Ct, Rt, Ot, bt, qt, Gt;
                    if (this !== ye && q > B && d >= 0 && (q = B),
                    q !== this._tTime || D || Ee) {
                        if (C !== this._time && U && (q += this._time - C,
                        d += this._time - C),
                        Le = q,
                        Ot = this._start,
                        Rt = this._ts,
                        Et = !Rt,
                        Ee && (U || (C = this._zTime),
                        (d || !_) && (this._zTime = d)),
                        this._repeat) {
                            if (qt = this._yoyo,
                            at = U + this._rDelay,
                            this._repeat < -1 && d < 0)
                                return this.totalTime(at * 100 + d, _, D);
                            if (Le = Jt(q % at),
                            q === B ? (pe = this._repeat,
                            Le = U) : (bt = Jt(q / at),
                            pe = ~~bt,
                            pe && pe === bt && (Le = U,
                            pe--),
                            Le > U && (Le = U)),
                            bt = gt(this._tTime, at),
                            !C && this._tTime && bt !== pe && this._tTime - bt * at - this._dur <= 0 && (bt = pe),
                            qt && pe & 1 && (Le = U - Le,
                            Gt = 1),
                            pe !== bt && !this._lock) {
                                var Kt = qt && bt & 1
                                  , Mt = Kt === (qt && pe & 1);
                                if (pe < bt && (Kt = !Kt),
                                C = Kt ? 0 : q % U ? U : q,
                                this._lock = 1,
                                this.render(C || (Gt ? 0 : Jt(pe * at)), _, !U)._lock = 0,
                                this._tTime = q,
                                !_ && this.parent && cr(this, "onRepeat"),
                                this.vars.repeatRefresh && !Gt && (this.invalidate()._lock = 1),
                                C && C !== this._time || Et !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                                    return this;
                                if (U = this._dur,
                                B = this._tDur,
                                Mt && (this._lock = 2,
                                C = Kt ? U : -1e-4,
                                this.render(C, !0),
                                this.vars.repeatRefresh && !Gt && this.invalidate()),
                                this._lock = 0,
                                !this._ts && !Et)
                                    return this;
                                Ii(this, Gt)
                            }
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (Ct = b(this, Jt(C), Jt(Le)),
                        Ct && (q -= Le - (Le = Ct._start))),
                        this._tTime = q,
                        this._time = Le,
                        this._act = !Rt,
                        this._initted || (this._onUpdate = this.vars.onUpdate,
                        this._initted = 1,
                        this._zTime = d,
                        C = 0),
                        !C && q && !_ && !bt && (cr(this, "onStart"),
                        this._tTime !== q))
                            return this;
                        if (Le >= C && d >= 0)
                            for (He = this._first; He; ) {
                                if (it = He._next,
                                (He._act || Le >= He._start) && He._ts && Ct !== He) {
                                    if (He.parent !== this)
                                        return this.render(d, _, D);
                                    if (He.render(He._ts > 0 ? (Le - He._start) * He._ts : (He._dirty ? He.totalDuration() : He._tDur) + (Le - He._start) * He._ts, _, D),
                                    Le !== this._time || !this._ts && !Et) {
                                        Ct = 0,
                                        it && (q += this._zTime = -1e-8);
                                        break
                                    }
                                }
                                He = it
                            }
                        else {
                            He = this._last;
                            for (var Jn = d < 0 ? d : Le; He; ) {
                                if (it = He._prev,
                                (He._act || Jn <= He._end) && He._ts && Ct !== He) {
                                    if (He.parent !== this)
                                        return this.render(d, _, D);
                                    if (He.render(He._ts > 0 ? (Jn - He._start) * He._ts : (He._dirty ? He.totalDuration() : He._tDur) + (Jn - He._start) * He._ts, _, D || u && Ln(He)),
                                    Le !== this._time || !this._ts && !Et) {
                                        Ct = 0,
                                        it && (q += this._zTime = Jn ? -1e-8 : g);
                                        break
                                    }
                                }
                                He = it
                            }
                        }
                        if (Ct && !_ && (this.pause(),
                        Ct.render(Le >= C ? 0 : -1e-8)._zTime = Le >= C ? 1 : -1,
                        this._ts))
                            return this._start = Ot,
                            Oe(this),
                            this.render(d, _, D);
                        this._onUpdate && !_ && cr(this, "onUpdate", !0),
                        (q === B && this._tTime >= this.totalDuration() || !q && C) && (Ot === this._start || Math.abs(Rt) !== Math.abs(this._ts)) && (this._lock || ((d || !U) && (q === B && this._ts > 0 || !q && this._ts < 0) && vt(this, 1),
                        !_ && !(d < 0 && !C) && (q || C || !B) && (cr(this, q === B && d >= 0 ? "onComplete" : "onReverseComplete", !0),
                        this._prom && !(q < B && this.timeScale() > 0) && this._prom())))
                    }
                    return this
                }
                ,
                c.add = function(d, _) {
                    var D = this;
                    if (k(_) || (_ = G(this, _, d)),
                    !(d instanceof ca)) {
                        if (J(d))
                            return d.forEach(function(C) {
                                return D.add(C, _)
                            }),
                            this;
                        if (x(d))
                            return this.addLabel(d, _);
                        if (v(d))
                            d = jr.delayedCall(0, d);
                        else
                            return this
                    }
                    return this !== d ? L(this, d, _) : this
                }
                ,
                c.getChildren = function(d, _, D, C) {
                    d === void 0 && (d = !0),
                    _ === void 0 && (_ = !0),
                    D === void 0 && (D = !0),
                    C === void 0 && (C = -1e8);
                    for (var B = [], U = this._first; U; )
                        U._start >= C && (U instanceof jr ? _ && B.push(U) : (D && B.push(U),
                        d && B.push.apply(B, U.getChildren(!0, _, D)))),
                        U = U._next;
                    return B
                }
                ,
                c.getById = function(d) {
                    for (var _ = this.getChildren(1, 1, 1), D = _.length; D--; )
                        if (_[D].vars.id === d)
                            return _[D]
                }
                ,
                c.remove = function(d) {
                    return x(d) ? this.removeLabel(d) : v(d) ? this.killTweensOf(d) : (d.parent === this && je(this, d),
                    d === this._recent && (this._recent = this._last),
                    ot(this))
                }
                ,
                c.totalTime = function(d, _) {
                    return arguments.length ? (this._forcing = 1,
                    !this._dp && this._ts && (this._start = Jt(Pn.time - (this._ts > 0 ? d / this._ts : (this.totalDuration() - d) / -this._ts))),
                    j.prototype.totalTime.call(this, d, _),
                    this._forcing = 0,
                    this) : this._tTime
                }
                ,
                c.addLabel = function(d, _) {
                    return this.labels[d] = G(this, _),
                    this
                }
                ,
                c.removeLabel = function(d) {
                    return delete this.labels[d],
                    this
                }
                ,
                c.addPause = function(d, _, D) {
                    var C = jr.delayedCall(0, _ || ze, D);
                    return C.data = "isPause",
                    this._hasPause = 1,
                    L(this, C, G(this, d))
                }
                ,
                c.removePause = function(d) {
                    var _ = this._first;
                    for (d = G(this, d); _; )
                        _._start === d && _.data === "isPause" && vt(_),
                        _ = _._next
                }
                ,
                c.killTweensOf = function(d, _, D) {
                    for (var C = this.getTweensOf(d, D), B = C.length; B--; )
                        is !== C[B] && C[B].kill(d, _);
                    return this
                }
                ,
                c.getTweensOf = function(d, _) {
                    for (var D = [], C = dt(d), B = this._first, U = k(_), q; B; )
                        B instanceof jr ? Fn(B._targets, C) && (U ? (!is || B._initted && B._ts) && B.globalTime(0) <= _ && B.globalTime(B.totalDuration()) > _ : !_ || B.isActive()) && D.push(B) : (q = B.getTweensOf(C, _)).length && D.push.apply(D, q),
                        B = B._next;
                    return D
                }
                ,
                c.tweenTo = function(d, _) {
                    _ = _ || {};
                    var D = this, C = G(D, d), B = _, U = B.startAt, q = B.onStart, Ee = B.onStartParams, Le = B.immediateRender, He, it = jr.to(D, X({
                        ease: _.ease || "none",
                        lazy: !1,
                        immediateRender: !1,
                        time: C,
                        overwrite: "auto",
                        duration: _.duration || Math.abs((C - (U && "time"in U ? U.time : D._time)) / D.timeScale()) || g,
                        onStart: function() {
                            if (D.pause(),
                            !He) {
                                var at = _.duration || Math.abs((C - (U && "time"in U ? U.time : D._time)) / D.timeScale());
                                it._dur !== at && T(it, at, 0, 1).render(it._time, !0, !0),
                                He = 1
                            }
                            q && q.apply(it, Ee || [])
                        }
                    }, _));
                    return Le ? it.render(0) : it
                }
                ,
                c.tweenFromTo = function(d, _, D) {
                    return this.tweenTo(_, X({
                        startAt: {
                            time: G(this, d)
                        }
                    }, D))
                }
                ,
                c.recent = function() {
                    return this._recent
                }
                ,
                c.nextLabel = function(d) {
                    return d === void 0 && (d = this._time),
                    Pr(this, G(this, d))
                }
                ,
                c.previousLabel = function(d) {
                    return d === void 0 && (d = this._time),
                    Pr(this, G(this, d), 1)
                }
                ,
                c.currentLabel = function(d) {
                    return arguments.length ? this.seek(d, !0) : this.previousLabel(this._time + g)
                }
                ,
                c.shiftChildren = function(d, _, D) {
                    D === void 0 && (D = 0);
                    for (var C = this._first, B = this.labels, U; C; )
                        C._start >= D && (C._start += d,
                        C._end += d),
                        C = C._next;
                    if (_)
                        for (U in B)
                            B[U] >= D && (B[U] += d);
                    return ot(this)
                }
                ,
                c.invalidate = function(d) {
                    var _ = this._first;
                    for (this._lock = 0; _; )
                        _.invalidate(d),
                        _ = _._next;
                    return j.prototype.invalidate.call(this, d)
                }
                ,
                c.clear = function(d) {
                    d === void 0 && (d = !0);
                    for (var _ = this._first, D; _; )
                        D = _._next,
                        this.remove(_),
                        _ = D;
                    return this._dp && (this._time = this._tTime = this._pTime = 0),
                    d && (this.labels = {}),
                    ot(this)
                }
                ,
                c.totalDuration = function(d) {
                    var _ = 0, D = this, C = D._last, B = h, U, q, Ee;
                    if (arguments.length)
                        return D.timeScale((D._repeat < 0 ? D.duration() : D.totalDuration()) / (D.reversed() ? -d : d));
                    if (D._dirty) {
                        for (Ee = D.parent; C; )
                            U = C._prev,
                            C._dirty && C.totalDuration(),
                            q = C._start,
                            q > B && D._sort && C._ts && !D._lock ? (D._lock = 1,
                            L(D, C, q - C._delay, 1)._lock = 0) : B = q,
                            q < 0 && C._ts && (_ -= q,
                            (!Ee && !D._dp || Ee && Ee.smoothChildTiming) && (D._start += q / D._ts,
                            D._time -= q,
                            D._tTime -= q),
                            D.shiftChildren(-q, !1, -1 / 0),
                            B = 0),
                            C._end > _ && C._ts && (_ = C._end),
                            C = U;
                        T(D, D === ye && D._time > _ ? D._time : _, 1, 1),
                        D._dirty = 0
                    }
                    return D._tDur
                }
                ,
                a.updateRoot = function(d) {
                    if (ye._ts && (Kn(ye, et(d, ye)),
                    Te = Pn.frame),
                    Pn.frame >= st) {
                        st += s.autoSleep || 120;
                        var _ = ye._first;
                        if ((!_ || !_._ts) && s.autoSleep && Pn._listeners.length < 2) {
                            for (; _ && !_._ts; )
                                _ = _._next;
                            _ || Pn.sleep()
                        }
                    }
                }
                ,
                a
            }(ca);
            X(oi.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });
            var $u = function(a, c, f, d, _, D, C) {
                var B = new Ni(this._pt,a,c,0,1,kn,null,_), U = 0, q = 0, Ee, Le, He, it, pe, at, Et, Ct;
                for (B.b = f,
                B.e = d,
                f += "",
                d += "",
                (Et = ~d.indexOf("random(")) && (d = ur(d)),
                D && (Ct = [f, d],
                D(Ct, a, c),
                f = Ct[0],
                d = Ct[1]),
                Le = f.match(Z) || []; Ee = Z.exec(d); )
                    it = Ee[0],
                    pe = d.substring(U, Ee.index),
                    He ? He = (He + 1) % 5 : pe.substr(-5) === "rgba(" && (He = 1),
                    it !== Le[q++] && (at = parseFloat(Le[q - 1]) || 0,
                    B._pt = {
                        _next: B._pt,
                        p: pe || q === 1 ? pe : ",",
                        s: at,
                        c: it.charAt(1) === "=" ? fn(at, it) - at : parseFloat(it) - at,
                        m: He && He < 4 ? Math.round : 0
                    },
                    U = Z.lastIndex);
                return B.c = U < d.length ? d.substring(U, d.length) : "",
                B.fp = C,
                (Q.test(d) || Et) && (B.e = 0),
                this._pt = B,
                B
            }, Is = function(a, c, f, d, _, D, C, B, U, q) {
                v(d) && (d = d(_ || 0, a, D));
                var Ee = a[c], Le = f !== "get" ? f : v(Ee) ? U ? a[c.indexOf("set") || !v(a["get" + c.substr(3)]) ? c : "get" + c.substr(3)](U) : a[c]() : Ee, He = v(Ee) ? U ? vf : Tl : $o, it;
                if (x(d) && (~d.indexOf("random(") && (d = ur(d)),
                d.charAt(1) === "=" && (it = fn(Le, d) + (oe(Le) || 0),
                (it || it === 0) && (d = it))),
                !q || Le !== d || hs)
                    return !isNaN(Le * d) && d !== "" ? (it = new Ni(this._pt,a,c,+Le || 0,d - (Le || 0),typeof Ee == "boolean" ? Hu : ga,0,He),
                    U && (it.fp = U),
                    C && it.modifier(C, this, a),
                    this._pt = it) : (!Ee && !(c in a) && he(c, d),
                    $u.call(this, a, c, Le, d, He, B || s.stringFilter, U))
            }, xl = function(a, c, f, d, _) {
                if (v(a) && (a = ha(a, _, c, f, d)),
                !W(a) || a.style && a.nodeType || J(a) || ge(a))
                    return x(a) ? ha(a, _, c, f, d) : a;
                var D = {}, C;
                for (C in a)
                    D[C] = ha(a[C], _, c, f, d);
                return D
            }, fa = function(a, c, f, d, _, D) {
                var C, B, U, q;
                if (Ne[a] && (C = new Ne[a]).init(_, C.rawVars ? c[a] : xl(c[a], d, _, D, f), f, d, D) !== !1 && (f._pt = B = new Ni(f._pt,_,a,0,1,C.render,C,0,C.priority),
                f !== qn))
                    for (U = f._ptLookup[f._targets.indexOf(_)],
                    q = C._props.length; q--; )
                        U[C._props[q]] = B;
                return C
            }, is, hs, da = function j(a, c, f) {
                var d = a.vars, _ = d.ease, D = d.startAt, C = d.immediateRender, B = d.lazy, U = d.onUpdate, q = d.runBackwards, Ee = d.yoyoEase, Le = d.keyframes, He = d.autoRevert, it = a._dur, pe = a._startAt, at = a._targets, Et = a.parent, Ct = Et && Et.data === "nested" ? Et.vars.targets : at, Rt = a._overwrite === "auto" && !l, Ot = a.timeline, bt, qt, Gt, Kt, Mt, Jn, Hr, Er, Cr, Li, Ti, fi, Pi;
                if (Ot && (!Le || !_) && (_ = "none"),
                a._ease = Ks(_, o.ease),
                a._yEase = Ee ? Ys(Ks(Ee === !0 ? _ : Ee, o.ease)) : 0,
                Ee && a._yoyo && !a._repeat && (Ee = a._yEase,
                a._yEase = a._ease,
                a._ease = Ee),
                a._from = !Ot && !!d.runBackwards,
                !Ot || Le && !d.stagger) {
                    if (Er = at[0] ? rt(at[0]).harness : 0,
                    fi = Er && d[Er.prop],
                    bt = Fe(d, $),
                    pe && (pe._zTime < 0 && pe.progress(1),
                    c < 0 && q && C && !He ? pe.render(-1, !0) : pe.revert(q && it ? Je : Se),
                    pe._lazy = 0),
                    D) {
                        if (vt(a._startAt = jr.set(at, X({
                            data: "isStart",
                            overwrite: !1,
                            parent: Et,
                            immediateRender: !0,
                            lazy: !pe && K(B),
                            startAt: null,
                            delay: 0,
                            onUpdate: U && function() {
                                return cr(a, "onUpdate")
                            }
                            ,
                            stagger: 0
                        }, D))),
                        a._startAt._dp = 0,
                        a._startAt._sat = a,
                        c < 0 && (u || !C && !He) && a._startAt.revert(Je),
                        C && it && c <= 0 && f <= 0) {
                            c && (a._zTime = c);
                            return
                        }
                    } else if (q && it && !pe) {
                        if (c && (C = !1),
                        Gt = X({
                            overwrite: !1,
                            data: "isFromStart",
                            lazy: C && !pe && K(B),
                            immediateRender: C,
                            stagger: 0,
                            parent: Et
                        }, bt),
                        fi && (Gt[Er.prop] = fi),
                        vt(a._startAt = jr.set(at, Gt)),
                        a._startAt._dp = 0,
                        a._startAt._sat = a,
                        c < 0 && (u ? a._startAt.revert(Je) : a._startAt.render(-1, !0)),
                        a._zTime = c,
                        !C)
                            j(a._startAt, g, g);
                        else if (!c)
                            return
                    }
                    for (a._pt = a._ptCache = 0,
                    B = it && K(B) || B && !it,
                    qt = 0; qt < at.length; qt++) {
                        if (Mt = at[qt],
                        Hr = Mt._gsap || wt(at)[qt]._gsap,
                        a._ptLookup[qt] = Li = {},
                        Me[Hr.id] && de.length && hn(),
                        Ti = Ct === at ? qt : Ct.indexOf(Mt),
                        Er && (Cr = new Er).init(Mt, fi || bt, a, Ti, Ct) !== !1 && (a._pt = Kt = new Ni(a._pt,Mt,Cr.name,0,1,Cr.render,Cr,0,Cr.priority),
                        Cr._props.forEach(function(Hs) {
                            Li[Hs] = Kt
                        }),
                        Cr.priority && (Jn = 1)),
                        !Er || fi)
                            for (Gt in bt)
                                Ne[Gt] && (Cr = fa(Gt, bt, a, Ti, Mt, Ct)) ? Cr.priority && (Jn = 1) : Li[Gt] = Kt = Is.call(a, Mt, Gt, "get", bt[Gt], Ti, Ct, 0, d.stringFilter);
                        a._op && a._op[qt] && a.kill(Mt, a._op[qt]),
                        Rt && a._pt && (is = a,
                        ye.killTweensOf(Mt, Li, a.globalTime(c)),
                        Pi = !a.parent,
                        is = 0),
                        a._pt && B && (Me[Hr.id] = 1)
                    }
                    Jn && kl(a),
                    a._onInit && a._onInit(a)
                }
                a._onUpdate = U,
                a._initted = (!a._op || a._pt) && !Pi,
                Le && c <= 0 && Ot.render(h, !0, !0)
            }, $a = function(a, c, f, d, _, D, C, B) {
                var U = (a._pt && a._ptCache || (a._ptCache = {}))[c], q, Ee, Le, He;
                if (!U)
                    for (U = a._ptCache[c] = [],
                    Le = a._ptLookup,
                    He = a._targets.length; He--; ) {
                        if (q = Le[He][c],
                        q && q.d && q.d._pt)
                            for (q = q.d._pt; q && q.p !== c && q.fp !== c; )
                                q = q._next;
                        if (!q)
                            return hs = 1,
                            a.vars[c] = "+=0",
                            da(a, C),
                            hs = 0,
                            B ? ve(c + " not eligible for reset") : 1;
                        U.push(q)
                    }
                for (He = U.length; He--; )
                    Ee = U[He],
                    q = Ee._pt || Ee,
                    q.s = (d || d === 0) && !_ ? d : q.s + (d || 0) + D * q.c,
                    q.c = f - q.s,
                    Ee.e && (Ee.e = Lt(f) + oe(Ee.e)),
                    Ee.b && (Ee.b = q.s + oe(Ee.b))
            }, yf = function(a, c) {
                var f = a[0] ? rt(a[0]).harness : 0, d = f && f.aliases, _, D, C, B;
                if (!d)
                    return c;
                _ = _e({}, c);
                for (D in d)
                    if (D in _)
                        for (B = d[D].split(","),
                        C = B.length; C--; )
                            _[B[C]] = _[D];
                return _
            }, Sl = function(a, c, f, d) {
                var _ = c.ease || d || "power1.inOut", D, C;
                if (J(c))
                    C = f[a] || (f[a] = []),
                    c.forEach(function(B, U) {
                        return C.push({
                            t: U / (c.length - 1) * 100,
                            v: B,
                            e: _
                        })
                    });
                else
                    for (D in c)
                        C = f[D] || (f[D] = []),
                        D === "ease" || C.push({
                            t: parseFloat(a),
                            v: c[D],
                            e: _
                        })
            }, ha = function(a, c, f, d, _) {
                return v(a) ? a.call(c, f, d, _) : x(a) && ~a.indexOf("random(") ? ur(a) : a
            }, uo = Ge + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", pa = {};
            xt(uo + ",id,stagger,delay,duration,paused,scrollTrigger", function(j) {
                return pa[j] = 1
            });
            var jr = function(j) {
                r(a, j);
                function a(f, d, _, D) {
                    var C;
                    typeof d == "number" && (_.duration = d,
                    d = _,
                    _ = null),
                    C = j.call(this, D ? d : Ce(d)) || this;
                    var B = C.vars, U = B.duration, q = B.delay, Ee = B.immediateRender, Le = B.stagger, He = B.overwrite, it = B.keyframes, pe = B.defaults, at = B.scrollTrigger, Et = B.yoyoEase, Ct = d.parent || ye, Rt = (J(f) || ge(f) ? k(f[0]) : "length"in d) ? [f] : dt(f), Ot, bt, qt, Gt, Kt, Mt, Jn, Hr;
                    if (C._targets = Rt.length ? wt(Rt) : ve("GSAP target " + f + " not found. https://gsap.com", !s.nullTargetWarn) || [],
                    C._ptLookup = [],
                    C._overwrite = He,
                    it || Le || fe(U) || fe(q)) {
                        if (d = C.vars,
                        Ot = C.timeline = new oi({
                            data: "nested",
                            defaults: pe || {},
                            targets: Ct && Ct.data === "nested" ? Ct.vars.targets : Rt
                        }),
                        Ot.kill(),
                        Ot.parent = Ot._dp = i(C),
                        Ot._start = 0,
                        Le || fe(U) || fe(q)) {
                            if (Gt = Rt.length,
                            Jn = Le && Nt(Le),
                            W(Le))
                                for (Kt in Le)
                                    ~uo.indexOf(Kt) && (Hr || (Hr = {}),
                                    Hr[Kt] = Le[Kt]);
                            for (bt = 0; bt < Gt; bt++)
                                qt = Fe(d, pa),
                                qt.stagger = 0,
                                Et && (qt.yoyoEase = Et),
                                Hr && _e(qt, Hr),
                                Mt = Rt[bt],
                                qt.duration = +ha(U, i(C), bt, Mt, Rt),
                                qt.delay = (+ha(q, i(C), bt, Mt, Rt) || 0) - C._delay,
                                !Le && Gt === 1 && qt.delay && (C._delay = q = qt.delay,
                                C._start += q,
                                qt.delay = 0),
                                Ot.to(Mt, qt, Jn ? Jn(bt, Mt, Rt) : 0),
                                Ot._ease = bn.none;
                            Ot.duration() ? U = q = 0 : C.timeline = 0
                        } else if (it) {
                            Ce(X(Ot.vars.defaults, {
                                ease: "none"
                            })),
                            Ot._ease = Ks(it.ease || d.ease || "none");
                            var Er = 0, Cr, Li, Ti;
                            if (J(it))
                                it.forEach(function(fi) {
                                    return Ot.to(Rt, fi, ">")
                                }),
                                Ot.duration();
                            else {
                                qt = {};
                                for (Kt in it)
                                    Kt === "ease" || Kt === "easeEach" || Sl(Kt, it[Kt], qt, it.easeEach);
                                for (Kt in qt)
                                    for (Cr = qt[Kt].sort(function(fi, Pi) {
                                        return fi.t - Pi.t
                                    }),
                                    Er = 0,
                                    bt = 0; bt < Cr.length; bt++)
                                        Li = Cr[bt],
                                        Ti = {
                                            ease: Li.e,
                                            duration: (Li.t - (bt ? Cr[bt - 1].t : 0)) / 100 * U
                                        },
                                        Ti[Kt] = Li.v,
                                        Ot.to(Rt, Ti, Er),
                                        Er += Ti.duration;
                                Ot.duration() < U && Ot.to({}, {
                                    duration: U - Ot.duration()
                                })
                            }
                        }
                        U || C.duration(U = Ot.duration())
                    } else
                        C.timeline = 0;
                    return He === !0 && !l && (is = i(C),
                    ye.killTweensOf(Rt),
                    is = 0),
                    L(Ct, i(C), _),
                    d.reversed && C.reverse(),
                    d.paused && C.paused(!0),
                    (Ee || !U && !it && C._start === Jt(Ct._time) && K(Ee) && Ft(i(C)) && Ct.data !== "nested") && (C._tTime = -1e-8,
                    C.render(Math.max(0, -q) || 0)),
                    at && ne(i(C), at),
                    C
                }
                var c = a.prototype;
                return c.render = function(d, _, D) {
                    var C = this._time, B = this._tDur, U = this._dur, q = d < 0, Ee = d > B - g && !q ? B : d < g ? 0 : d, Le, He, it, pe, at, Et, Ct, Rt, Ot;
                    if (!U)
                        F(this, d, _, D);
                    else if (Ee !== this._tTime || !d || D || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== q || this._lazy) {
                        if (Le = Ee,
                        Rt = this.timeline,
                        this._repeat) {
                            if (pe = U + this._rDelay,
                            this._repeat < -1 && q)
                                return this.totalTime(pe * 100 + d, _, D);
                            if (Le = Jt(Ee % pe),
                            Ee === B ? (it = this._repeat,
                            Le = U) : (at = Jt(Ee / pe),
                            it = ~~at,
                            it && it === at ? (Le = U,
                            it--) : Le > U && (Le = U)),
                            Et = this._yoyo && it & 1,
                            Et && (Ot = this._yEase,
                            Le = U - Le),
                            at = gt(this._tTime, pe),
                            Le === C && !D && this._initted && it === at)
                                return this._tTime = Ee,
                                this;
                            it !== at && (Rt && this._yEase && Ii(Rt, Et),
                            this.vars.repeatRefresh && !Et && !this._lock && Le !== pe && this._initted && (this._lock = D = 1,
                            this.render(Jt(pe * it), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (le(this, q ? d : Le, D, _, Ee))
                                return this._tTime = 0,
                                this;
                            if (C !== this._time && !(D && this.vars.repeatRefresh && it !== at))
                                return this;
                            if (U !== this._dur)
                                return this.render(d, _, D)
                        }
                        if (this._tTime = Ee,
                        this._time = Le,
                        !this._act && this._ts && (this._act = 1,
                        this._lazy = 0),
                        this.ratio = Ct = (Ot || this._ease)(Le / U),
                        this._from && (this.ratio = Ct = 1 - Ct),
                        !C && Ee && !_ && !at && (cr(this, "onStart"),
                        this._tTime !== Ee))
                            return this;
                        for (He = this._pt; He; )
                            He.r(Ct, He.d),
                            He = He._next;
                        Rt && Rt.render(d < 0 ? d : Rt._dur * Rt._ease(Le / this._dur), _, D) || this._startAt && (this._zTime = d),
                        this._onUpdate && !_ && (q && ut(this, d, _, D),
                        cr(this, "onUpdate")),
                        this._repeat && it !== at && this.vars.onRepeat && !_ && this.parent && cr(this, "onRepeat"),
                        (Ee === this._tDur || !Ee) && this._tTime === Ee && (q && !this._onUpdate && ut(this, d, !0, !0),
                        (d || !U) && (Ee === this._tDur && this._ts > 0 || !Ee && this._ts < 0) && vt(this, 1),
                        !_ && !(q && !C) && (Ee || C || Et) && (cr(this, Ee === B ? "onComplete" : "onReverseComplete", !0),
                        this._prom && !(Ee < B && this.timeScale() > 0) && this._prom()))
                    }
                    return this
                }
                ,
                c.targets = function() {
                    return this._targets
                }
                ,
                c.invalidate = function(d) {
                    return (!d || !this.vars.runBackwards) && (this._startAt = 0),
                    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
                    this._ptLookup = [],
                    this.timeline && this.timeline.invalidate(d),
                    j.prototype.invalidate.call(this, d)
                }
                ,
                c.resetTo = function(d, _, D, C, B) {
                    Jr || Pn.wake(),
                    this._ts || this.play();
                    var U = Math.min(this._dur, (this._dp._time - this._start) * this._ts), q;
                    return this._initted || da(this, U),
                    q = this._ease(U / this._dur),
                    $a(this, d, _, D, C, q, U, B) ? this.resetTo(d, _, D, C, 1) : (O(this, 0),
                    this.parent || Ye(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
                    this.render(0))
                }
                ,
                c.kill = function(d, _) {
                    if (_ === void 0 && (_ = "all"),
                    !d && (!_ || _ === "all"))
                        return this._lazy = this._pt = 0,
                        this.parent ? fr(this) : this.scrollTrigger && this.scrollTrigger.kill(!!u),
                        this;
                    if (this.timeline) {
                        var D = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(d, _, is && is.vars.overwrite !== !0)._first || fr(this),
                        this.parent && D !== this.timeline.totalDuration() && T(this, this._dur * this.timeline._tDur / D, 0, 1),
                        this
                    }
                    var C = this._targets, B = d ? dt(d) : C, U = this._ptLookup, q = this._pt, Ee, Le, He, it, pe, at, Et;
                    if ((!_ || _ === "all") && $e(C, B))
                        return _ === "all" && (this._pt = 0),
                        fr(this);
                    for (Ee = this._op = this._op || [],
                    _ !== "all" && (x(_) && (pe = {},
                    xt(_, function(Ct) {
                        return pe[Ct] = 1
                    }),
                    _ = pe),
                    _ = yf(C, _)),
                    Et = C.length; Et--; )
                        if (~B.indexOf(C[Et])) {
                            Le = U[Et],
                            _ === "all" ? (Ee[Et] = _,
                            it = Le,
                            He = {}) : (He = Ee[Et] = Ee[Et] || {},
                            it = _);
                            for (pe in it)
                                at = Le && Le[pe],
                                at && ((!("kill"in at.d) || at.d.kill(pe) === !0) && je(this, at, "_pt"),
                                delete Le[pe]),
                                He !== "all" && (He[pe] = 1)
                        }
                    return this._initted && !this._pt && q && fr(this),
                    this
                }
                ,
                a.to = function(d, _) {
                    return new a(d,_,arguments[2])
                }
                ,
                a.from = function(d, _) {
                    return ce(1, arguments)
                }
                ,
                a.delayedCall = function(d, _, D, C) {
                    return new a(_,0,{
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: d,
                        onComplete: _,
                        onReverseComplete: _,
                        onCompleteParams: D,
                        onReverseCompleteParams: D,
                        callbackScope: C
                    })
                }
                ,
                a.fromTo = function(d, _, D) {
                    return ce(2, arguments)
                }
                ,
                a.set = function(d, _) {
                    return _.duration = 0,
                    _.repeatDelay || (_.repeat = 0),
                    new a(d,_)
                }
                ,
                a.killTweensOf = function(d, _, D) {
                    return ye.killTweensOf(d, _, D)
                }
                ,
                a
            }(ca);
            X(jr.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }),
            xt("staggerTo,staggerFrom,staggerFromTo", function(j) {
                jr[j] = function() {
                    var a = new oi
                      , c = me.call(arguments, 0);
                    return c.splice(j === "staggerFromTo" ? 5 : 4, 0, 0),
                    a[j].apply(a, c)
                }
            });
            var $o = function(a, c, f) {
                return a[c] = f
            }
              , Tl = function(a, c, f) {
                return a[c](f)
            }
              , vf = function(a, c, f, d) {
                return a[c](d.fp, f)
            }
              , Bu = function(a, c, f) {
                return a.setAttribute(c, f)
            }
              , Ba = function(a, c) {
                return v(a[c]) ? Tl : S(a[c]) && a.setAttribute ? Bu : $o
            }
              , ga = function(a, c) {
                return c.set(c.t, c.p, Math.round((c.s + c.c * a) * 1e6) / 1e6, c)
            }
              , Hu = function(a, c) {
                return c.set(c.t, c.p, !!(c.s + c.c * a), c)
            }
              , kn = function(a, c) {
                var f = c._pt
                  , d = "";
                if (!a && c.b)
                    d = c.b;
                else if (a === 1 && c.e)
                    d = c.e;
                else {
                    for (; f; )
                        d = f.p + (f.m ? f.m(f.s + f.c * a) : Math.round((f.s + f.c * a) * 1e4) / 1e4) + d,
                        f = f._next;
                    d += c.c
                }
                c.set(c.t, c.p, d, c)
            }
              , Ha = function(a, c) {
                for (var f = c._pt; f; )
                    f.r(a, f.d),
                    f = f._next
            }
              , Pl = function(a, c, f, d) {
                for (var _ = this._pt, D; _; )
                    D = _._next,
                    _.p === d && _.modifier(a, c, f),
                    _ = D
            }
              , Va = function(a) {
                for (var c = this._pt, f, d; c; )
                    d = c._next,
                    c.p === a && !c.op || c.op === a ? je(this, c, "_pt") : c.dep || (f = 1),
                    c = d;
                return !f
            }
              , bf = function(a, c, f, d) {
                d.mSet(a, c, d.m.call(d.tween, f, d.mt), d)
            }
              , kl = function(a) {
                for (var c = a._pt, f, d, _, D; c; ) {
                    for (f = c._next,
                    d = _; d && d.pr > c.pr; )
                        d = d._next;
                    (c._prev = d ? d._prev : D) ? c._prev._next = c : _ = c,
                    (c._next = d) ? d._prev = c : D = c,
                    c = f
                }
                a._pt = _
            }
              , Ni = function() {
                function j(c, f, d, _, D, C, B, U, q) {
                    this.t = f,
                    this.s = _,
                    this.c = D,
                    this.p = d,
                    this.r = C || ga,
                    this.d = B || this,
                    this.set = U || $o,
                    this.pr = q || 0,
                    this._next = c,
                    c && (c._prev = this)
                }
                var a = j.prototype;
                return a.modifier = function(f, d, _) {
                    this.mSet = this.mSet || this.set,
                    this.set = bf,
                    this.m = f,
                    this.mt = _,
                    this.tween = d
                }
                ,
                j
            }();
            xt(Ge + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(j) {
                return $[j] = 1
            }),
            mt.TweenMax = mt.TweenLite = jr,
            mt.TimelineLite = mt.TimelineMax = oi,
            ye = new oi({
                sortChildren: !1,
                defaults: o,
                autoRemoveChildren: !0,
                id: "root",
                smoothChildTiming: !0
            }),
            s.stringFilter = gn;
            var Xs = []
              , _a = {}
              , wf = []
              , Pe = 0
              , A = 0
              , te = function(a) {
                return (_a[a] || wf).map(function(c) {
                    return c()
                })
            }
              , N = function() {
                var a = Date.now()
                  , c = [];
                a - Pe > 2 && (te("matchMediaInit"),
                Xs.forEach(function(f) {
                    var d = f.queries, _ = f.conditions, D, C, B, U;
                    for (C in d)
                        D = Ze.matchMedia(d[C]).matches,
                        D && (B = 1),
                        D !== _[C] && (_[C] = D,
                        U = 1);
                    U && (f.revert(),
                    B && c.push(f))
                }),
                te("matchMediaRevert"),
                c.forEach(function(f) {
                    return f.onMatch(f, function(d) {
                        return f.add(null, d)
                    })
                }),
                Pe = a,
                te("matchMedia"))
            }
              , V = function() {
                function j(c, f) {
                    this.selector = f && pt(f),
                    this.data = [],
                    this._r = [],
                    this.isReverted = !1,
                    this.id = A++,
                    c && this.add(c)
                }
                var a = j.prototype;
                return a.add = function(f, d, _) {
                    v(f) && (_ = d,
                    d = f,
                    f = v);
                    var D = this
                      , C = function() {
                        var U = p, q = D.selector, Ee;
                        return U && U !== D && U.data.push(D),
                        _ && (D.selector = pt(_)),
                        p = D,
                        Ee = d.apply(D, arguments),
                        v(Ee) && D._r.push(Ee),
                        p = U,
                        D.selector = q,
                        D.isReverted = !1,
                        Ee
                    };
                    return D.last = C,
                    f === v ? C(D, function(B) {
                        return D.add(null, B)
                    }) : f ? D[f] = C : C
                }
                ,
                a.ignore = function(f) {
                    var d = p;
                    p = null,
                    f(this),
                    p = d
                }
                ,
                a.getTweens = function() {
                    var f = [];
                    return this.data.forEach(function(d) {
                        return d instanceof j ? f.push.apply(f, d.getTweens()) : d instanceof jr && !(d.parent && d.parent.data === "nested") && f.push(d)
                    }),
                    f
                }
                ,
                a.clear = function() {
                    this._r.length = this.data.length = 0
                }
                ,
                a.kill = function(f, d) {
                    var _ = this;
                    if (f ? function() {
                        for (var C = _.getTweens(), B = _.data.length, U; B--; )
                            U = _.data[B],
                            U.data === "isFlip" && (U.revert(),
                            U.getChildren(!0, !0, !1).forEach(function(q) {
                                return C.splice(C.indexOf(q), 1)
                            }));
                        for (C.map(function(q) {
                            return {
                                g: q._dur || q._delay || q._sat && !q._sat.vars.immediateRender ? q.globalTime(0) : -1 / 0,
                                t: q
                            }
                        }).sort(function(q, Ee) {
                            return Ee.g - q.g || -1 / 0
                        }).forEach(function(q) {
                            return q.t.revert(f)
                        }),
                        B = _.data.length; B--; )
                            U = _.data[B],
                            U instanceof oi ? U.data !== "nested" && (U.scrollTrigger && U.scrollTrigger.revert(),
                            U.kill()) : !(U instanceof jr) && U.revert && U.revert(f);
                        _._r.forEach(function(q) {
                            return q(f, _)
                        }),
                        _.isReverted = !0
                    }() : this.data.forEach(function(C) {
                        return C.kill && C.kill()
                    }),
                    this.clear(),
                    d)
                        for (var D = Xs.length; D--; )
                            Xs[D].id === this.id && Xs.splice(D, 1)
                }
                ,
                a.revert = function(f) {
                    this.kill(f || {})
                }
                ,
                j
            }()
              , De = function() {
                function j(c) {
                    this.contexts = [],
                    this.scope = c,
                    p && p.data.push(this)
                }
                var a = j.prototype;
                return a.add = function(f, d, _) {
                    W(f) || (f = {
                        matches: f
                    });
                    var D = new V(0,_ || this.scope), C = D.conditions = {}, B, U, q;
                    p && !D.selector && (D.selector = p.selector),
                    this.contexts.push(D),
                    d = D.add("onMatch", d),
                    D.queries = f;
                    for (U in f)
                        U === "all" ? q = 1 : (B = Ze.matchMedia(f[U]),
                        B && (Xs.indexOf(D) < 0 && Xs.push(D),
                        (C[U] = B.matches) && (q = 1),
                        B.addListener ? B.addListener(N) : B.addEventListener("change", N)));
                    return q && d(D, function(Ee) {
                        return D.add(null, Ee)
                    }),
                    this
                }
                ,
                a.revert = function(f) {
                    this.kill(f || {})
                }
                ,
                a.kill = function(f) {
                    this.contexts.forEach(function(d) {
                        return d.kill(f, !0)
                    })
                }
                ,
                j
            }()
              , Ke = {
                registerPlugin: function() {
                    for (var a = arguments.length, c = new Array(a), f = 0; f < a; f++)
                        c[f] = arguments[f];
                    c.forEach(function(d) {
                        return Xn(d)
                    })
                },
                timeline: function(a) {
                    return new oi(a)
                },
                getTweensOf: function(a, c) {
                    return ye.getTweensOf(a, c)
                },
                getProperty: function(a, c, f, d) {
                    x(a) && (a = dt(a)[0]);
                    var _ = rt(a || {}).get
                      , D = f ? ht : lr;
                    return f === "native" && (f = ""),
                    a && (c ? D((Ne[c] && Ne[c].get || _)(a, c, f, d)) : function(C, B, U) {
                        return D((Ne[C] && Ne[C].get || _)(a, C, B, U))
                    }
                    )
                },
                quickSetter: function(a, c, f) {
                    if (a = dt(a),
                    a.length > 1) {
                        var d = a.map(function(q) {
                            return wn.quickSetter(q, c, f)
                        })
                          , _ = d.length;
                        return function(q) {
                            for (var Ee = _; Ee--; )
                                d[Ee](q)
                        }
                    }
                    a = a[0] || {};
                    var D = Ne[c]
                      , C = rt(a)
                      , B = C.harness && (C.harness.aliases || {})[c] || c
                      , U = D ? function(q) {
                        var Ee = new D;
                        qn._pt = 0,
                        Ee.init(a, f ? q + f : q, qn, 0, [a]),
                        Ee.render(1, Ee),
                        qn._pt && Ha(1, qn)
                    }
                    : C.set(a, B);
                    return D ? U : function(q) {
                        return U(a, B, f ? q + f : q, C, 1)
                    }
                },
                quickTo: function(a, c, f) {
                    var d, _ = wn.to(a, X((d = {},
                    d[c] = "+=0.1",
                    d.paused = !0,
                    d.stagger = 0,
                    d), f || {})), D = function(B, U, q) {
                        return _.resetTo(c, B, U, q)
                    };
                    return D.tween = _,
                    D
                },
                isTweening: function(a) {
                    return ye.getTweensOf(a, !0).length > 0
                },
                defaults: function(a) {
                    return a && a.ease && (a.ease = Ks(a.ease, o.ease)),
                    ke(o, a || {})
                },
                config: function(a) {
                    return ke(s, a || {})
                },
                registerEffect: function(a) {
                    var c = a.name
                      , f = a.effect
                      , d = a.plugins
                      , _ = a.defaults
                      , D = a.extendTimeline;
                    (d || "").split(",").forEach(function(C) {
                        return C && !Ne[C] && !mt[C] && ve(c + " effect requires " + C + " plugin.")
                    }),
                    lt[c] = function(C, B, U) {
                        return f(dt(C), X(B || {}, _), U)
                    }
                    ,
                    D && (oi.prototype[c] = function(C, B, U) {
                        return this.add(lt[c](C, W(B) ? B : (U = B) && {}, this), U)
                    }
                    )
                },
                registerEase: function(a, c) {
                    bn[a] = Ks(c)
                },
                parseEase: function(a, c) {
                    return arguments.length ? Ks(a, c) : bn
                },
                getById: function(a) {
                    return ye.getById(a)
                },
                exportRoot: function(a, c) {
                    a === void 0 && (a = {});
                    var f = new oi(a), d, _;
                    for (f.smoothChildTiming = K(a.smoothChildTiming),
                    ye.remove(f),
                    f._dp = 0,
                    f._time = f._tTime = ye._time,
                    d = ye._first; d; )
                        _ = d._next,
                        (c || !(!d._dur && d instanceof jr && d.vars.onComplete === d._targets[0])) && L(f, d, d._start - d._delay),
                        d = _;
                    return L(ye, f, 0),
                    f
                },
                context: function(a, c) {
                    return a ? new V(a,c) : p
                },
                matchMedia: function(a) {
                    return new De(a)
                },
                matchMediaRefresh: function() {
                    return Xs.forEach(function(a) {
                        var c = a.conditions, f, d;
                        for (d in c)
                            c[d] && (c[d] = !1,
                            f = 1);
                        f && a.revert()
                    }) || N()
                },
                addEventListener: function(a, c) {
                    var f = _a[a] || (_a[a] = []);
                    ~f.indexOf(c) || f.push(c)
                },
                removeEventListener: function(a, c) {
                    var f = _a[a]
                      , d = f && f.indexOf(c);
                    d >= 0 && f.splice(d, 1)
                },
                utils: {
                    wrap: pn,
                    wrapYoyo: Vr,
                    distribute: Nt,
                    random: $t,
                    snap: Bt,
                    normalize: Yt,
                    getUnit: oe,
                    clamp: We,
                    splitColor: _r,
                    toArray: dt,
                    selector: pt,
                    mapRange: br,
                    pipe: nn,
                    unitize: Zt,
                    interpolate: wr,
                    shuffle: jt
                },
                install: Tt,
                effects: lt,
                ticker: Pn,
                updateRoot: oi.updateRoot,
                plugins: Ne,
                globalTimeline: ye,
                core: {
                    PropTween: Ni,
                    globals: ae,
                    Tween: jr,
                    Timeline: oi,
                    Animation: ca,
                    getCache: rt,
                    _removeLinkedListItem: je,
                    reverting: function() {
                        return u
                    },
                    context: function(a) {
                        return a && p && (p.data.push(a),
                        a._ctx = p),
                        p
                    },
                    suppressOverwrites: function(a) {
                        return l = a
                    }
                }
            };
            xt("to,from,fromTo,delayedCall,set,killTweensOf", function(j) {
                return Ke[j] = jr[j]
            }),
            Pn.add(oi.updateRoot),
            qn = Ke.to({}, {
                duration: 0
            });
            var Be = function(a, c) {
                for (var f = a._pt; f && f.p !== c && f.op !== c && f.fp !== c; )
                    f = f._next;
                return f
            }
              , Wt = function(a, c) {
                var f = a._targets, d, _, D;
                for (d in c)
                    for (_ = f.length; _--; )
                        D = a._ptLookup[_][d],
                        D && (D = D.d) && (D._pt && (D = Be(D, d)),
                        D && D.modifier && D.modifier(c[d], a, f[_], d))
            }
              , cn = function(a, c) {
                return {
                    name: a,
                    headless: 1,
                    rawVars: 1,
                    init: function(d, _, D) {
                        D._onInit = function(C) {
                            var B, U;
                            if (x(_) && (B = {},
                            xt(_, function(q) {
                                return B[q] = 1
                            }),
                            _ = B),
                            c) {
                                B = {};
                                for (U in _)
                                    B[U] = c(_[U]);
                                _ = B
                            }
                            Wt(C, _)
                        }
                    }
                }
            }
              , wn = Ke.registerPlugin({
                name: "attr",
                init: function(a, c, f, d, _) {
                    var D, C, B;
                    this.tween = f;
                    for (D in c)
                        B = a.getAttribute(D) || "",
                        C = this.add(a, "setAttribute", (B || 0) + "", c[D], d, _, 0, 0, D),
                        C.op = D,
                        C.b = B,
                        this._props.push(D)
                },
                render: function(a, c) {
                    for (var f = c._pt; f; )
                        u ? f.set(f.t, f.p, f.b, f) : f.r(a, f.d),
                        f = f._next
                }
            }, {
                name: "endArray",
                headless: 1,
                init: function(a, c) {
                    for (var f = c.length; f--; )
                        this.add(a, f, a[f] || 0, c[f], 0, 0, 0, 0, 0, 1)
                }
            }, cn("roundProps", Pt), cn("modifiers"), cn("snap", Bt)) || Ke;
            jr.version = oi.version = wn.version = "3.13.0",
            At = 1,
            be() && Ms();
            var Rn = bn.Power0, on = bn.Power1, _t = bn.Power2, un = bn.Power3, Lr = bn.Power4, dr = bn.Linear, Zr = bn.Quad, kr = bn.Cubic, gi = bn.Quart, Sn = bn.Quint, ss = bn.Strong, Dr = bn.Elastic, mn = bn.Back, Ai = bn.SteppedEase, $i = bn.Bounce, rn = bn.Sine, ai = bn.Expo, _n = bn.Circ, vs, hr, Yr, _i, Bn, zr, Fr, Ae = function() {
                return typeof window < "u"
            }, or = {}, Wi = 180 / Math.PI, qi = Math.PI / 180, mi = Math.atan2, bs = 1e8, li = /([A-Z])/g, Kr = /(left|right|width|margin|padding|x)/i, Ri = /[\s,\(]\S/, mr = {
                autoAlpha: "opacity,visibility",
                scale: "scaleX,scaleY",
                alpha: "opacity"
            }, ws = function(a, c) {
                return c.set(c.t, c.p, Math.round((c.s + c.c * a) * 1e4) / 1e4 + c.u, c)
            }, Oi = function(a, c) {
                return c.set(c.t, c.p, a === 1 ? c.e : Math.round((c.s + c.c * a) * 1e4) / 1e4 + c.u, c)
            }, Bi = function(a, c) {
                return c.set(c.t, c.p, a ? Math.round((c.s + c.c * a) * 1e4) / 1e4 + c.u : c.b, c)
            }, Hn = function(a, c) {
                var f = c.s + c.c * a;
                c.set(c.t, c.p, ~~(f + (f < 0 ? -.5 : .5)) + c.u, c)
            }, Ir = function(a, c) {
                return c.set(c.t, c.p, a ? c.e : c.b, c)
            }, Mi = function(a, c) {
                return c.set(c.t, c.p, a !== 1 ? c.b : c.e, c)
            }, Gi = function(a, c, f) {
                return a.style[c] = f
            }, Xe = function(a, c, f) {
                return a.style.setProperty(c, f)
            }, Yi = function(a, c, f) {
                return a._gsap[c] = f
            }, Ns = function(a, c, f) {
                return a._gsap.scaleX = a._gsap.scaleY = f
            }, Qs = function(a, c, f, d, _) {
                var D = a._gsap;
                D.scaleX = D.scaleY = f,
                D.renderTransform(_, D)
            }, Nr = function(a, c, f, d, _) {
                var D = a._gsap;
                D[c] = f,
                D.renderTransform(_, D)
            }, Yn = "transform", Ur = Yn + "Origin", co = function j(a, c) {
                var f = this
                  , d = this.target
                  , _ = d.style
                  , D = d._gsap;
                if (a in or && _) {
                    if (this.tfm = this.tfm || {},
                    a !== "transform")
                        a = mr[a] || a,
                        ~a.indexOf(",") ? a.split(",").forEach(function(C) {
                            return f.tfm[C] = ti(d, C)
                        }) : this.tfm[a] = D.x ? D[a] : ti(d, a),
                        a === Ur && (this.tfm.zOrigin = D.zOrigin);
                    else
                        return mr.transform.split(",").forEach(function(C) {
                            return j.call(f, C, c)
                        });
                    if (this.props.indexOf(Yn) >= 0)
                        return;
                    D.svg && (this.svgo = d.getAttribute("data-svg-origin"),
                    this.props.push(Ur, c, "")),
                    a = Yn
                }
                (_ || c) && this.props.push(a, c, _[a])
            }, ei = function(a) {
                a.translate && (a.removeProperty("translate"),
                a.removeProperty("scale"),
                a.removeProperty("rotate"))
            }, Js = function() {
                var a = this.props, c = this.target, f = c.style, d = c._gsap, _, D;
                for (_ = 0; _ < a.length; _ += 3)
                    a[_ + 1] ? a[_ + 1] === 2 ? c[a[_]](a[_ + 2]) : c[a[_]] = a[_ + 2] : a[_ + 2] ? f[a[_]] = a[_ + 2] : f.removeProperty(a[_].substr(0, 2) === "--" ? a[_] : a[_].replace(li, "-$1").toLowerCase());
                if (this.tfm) {
                    for (D in this.tfm)
                        d[D] = this.tfm[D];
                    d.svg && (d.renderTransform(),
                    c.setAttribute("data-svg-origin", this.svgo || "")),
                    _ = Fr(),
                    (!_ || !_.isStart) && !f[Yn] && (ei(f),
                    d.zOrigin && f[Ur] && (f[Ur] += " " + d.zOrigin + "px",
                    d.zOrigin = 0,
                    d.renderTransform()),
                    d.uncache = 1)
                }
            }, $r = function(a, c) {
                var f = {
                    target: a,
                    props: [],
                    revert: Js,
                    save: co
                };
                return a._gsap || wn.core.getCache(a),
                c && a.style && a.nodeType && c.split(",").forEach(function(d) {
                    return f.save(d)
                }),
                f
            }, os, Hi = function(a, c) {
                var f = hr.createElementNS ? hr.createElementNS((c || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), a) : hr.createElement(a);
                return f && f.style ? f : hr.createElement(a)
            }, Xr = function j(a, c, f) {
                var d = getComputedStyle(a);
                return d[c] || d.getPropertyValue(c.replace(li, "-$1").toLowerCase()) || d.getPropertyValue(c) || !f && j(a, yr(c) || c, 1) || ""
            }, Bo = "O,Moz,ms,Ms,Webkit".split(","), yr = function(a, c, f) {
                var d = c || Bn
                  , _ = d.style
                  , D = 5;
                if (a in _ && !f)
                    return a;
                for (a = a.charAt(0).toUpperCase() + a.substr(1); D-- && !(Bo[D] + a in _); )
                    ;
                return D < 0 ? null : (D === 3 ? "ms" : D >= 0 ? Bo[D] : "") + a
            }, Ho = function() {
                Ae() && window.document && (vs = window,
                hr = vs.document,
                Yr = hr.documentElement,
                Bn = Hi("div") || {
                    style: {}
                },
                Hi("div"),
                Yn = yr(Yn),
                Ur = Yn + "Origin",
                Bn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
                os = !!yr("perspective"),
                Fr = wn.core.reverting,
                _i = 1)
            }, Ds = function(a) {
                var c = a.ownerSVGElement, f = Hi("svg", c && c.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), d = a.cloneNode(!0), _;
                d.style.display = "block",
                f.appendChild(d),
                Yr.appendChild(f);
                try {
                    _ = d.getBBox()
                } catch {}
                return f.removeChild(d),
                Yr.removeChild(f),
                _
            }, fo = function(a, c) {
                for (var f = c.length; f--; )
                    if (a.hasAttribute(c[f]))
                        return a.getAttribute(c[f])
            }, ho = function(a) {
                var c, f;
                try {
                    c = a.getBBox()
                } catch {
                    c = Ds(a),
                    f = 1
                }
                return c && (c.width || c.height) || f || (c = Ds(a)),
                c && !c.width && !c.x && !c.y ? {
                    x: +fo(a, ["x", "cx", "x1"]) || 0,
                    y: +fo(a, ["y", "cy", "y1"]) || 0,
                    width: 0,
                    height: 0
                } : c
            }, $s = function(a) {
                return !!(a.getCTM && (!a.parentNode || a.ownerSVGElement) && ho(a))
            }, Ki = function(a, c) {
                if (c) {
                    var f = a.style, d;
                    c in or && c !== Ur && (c = Yn),
                    f.removeProperty ? (d = c.substr(0, 2),
                    (d === "ms" || c.substr(0, 6) === "webkit") && (c = "-" + c),
                    f.removeProperty(d === "--" ? c : c.replace(li, "-$1").toLowerCase())) : f.removeAttribute(c)
                }
            }, Dn = function(a, c, f, d, _, D) {
                var C = new Ni(a._pt,c,f,0,1,D ? Mi : Ir);
                return a._pt = C,
                C.b = d,
                C.e = _,
                a._props.push(f),
                C
            }, Zs = {
                deg: 1,
                rad: 1,
                turn: 1
            }, ps = {
                grid: 1,
                flex: 1
            }, ui = function j(a, c, f, d) {
                var _ = parseFloat(f) || 0, D = (f + "").trim().substr((_ + "").length) || "px", C = Bn.style, B = Kr.test(c), U = a.tagName.toLowerCase() === "svg", q = (U ? "client" : "offset") + (B ? "Width" : "Height"), Ee = 100, Le = d === "px", He = d === "%", it, pe, at, Et;
                if (d === D || !_ || Zs[d] || Zs[D])
                    return _;
                if (D !== "px" && !Le && (_ = j(a, c, f, "px")),
                Et = a.getCTM && $s(a),
                (He || D === "%") && (or[c] || ~c.indexOf("adius")))
                    return it = Et ? a.getBBox()[B ? "width" : "height"] : a[q],
                    Lt(He ? _ / it * Ee : _ / 100 * it);
                if (C[B ? "width" : "height"] = Ee + (Le ? D : d),
                pe = d !== "rem" && ~c.indexOf("adius") || d === "em" && a.appendChild && !U ? a : a.parentNode,
                Et && (pe = (a.ownerSVGElement || {}).parentNode),
                (!pe || pe === hr || !pe.appendChild) && (pe = hr.body),
                at = pe._gsap,
                at && He && at.width && B && at.time === Pn.time && !at.uncache)
                    return Lt(_ / at.width * Ee);
                if (He && (c === "height" || c === "width")) {
                    var Ct = a.style[c];
                    a.style[c] = Ee + d,
                    it = a[q],
                    Ct ? a.style[c] = Ct : Ki(a, c)
                } else
                    (He || D === "%") && !ps[Xr(pe, "display")] && (C.position = Xr(a, "position")),
                    pe === a && (C.position = "static"),
                    pe.appendChild(Bn),
                    it = Bn[q],
                    pe.removeChild(Bn),
                    C.position = "absolute";
                return B && He && (at = rt(pe),
                at.time = Pn.time,
                at.width = pe[q]),
                Lt(Le ? it * _ / Ee : it && _ ? Ee / it * _ : 0)
            }, ti = function(a, c, f, d) {
                var _;
                return _i || Ho(),
                c in mr && c !== "transform" && (c = mr[c],
                ~c.indexOf(",") && (c = c.split(",")[0])),
                or[c] && c !== "transform" ? (_ = Br(a, d),
                _ = c !== "transformOrigin" ? _[c] : _.svg ? _.origin : An(Xr(a, Ur)) + " " + _.zOrigin + "px") : (_ = a.style[c],
                (!_ || _ === "auto" || d || ~(_ + "").indexOf("calc(")) && (_ = yn[c] && yn[c](a, c, f) || Xr(a, c) || Dt(a, c) || (c === "opacity" ? 1 : 0))),
                f && !~(_ + "").trim().indexOf(" ") ? ui(a, c, _, f) + f : _
            }, po = function(a, c, f, d) {
                if (!f || f === "none") {
                    var _ = yr(c, a, 1)
                      , D = _ && Xr(a, _, 1);
                    D && D !== f ? (c = _,
                    f = D) : c === "borderColor" && (f = Xr(a, "borderTopColor"))
                }
                var C = new Ni(this._pt,a.style,c,0,1,kn), B = 0, U = 0, q, Ee, Le, He, it, pe, at, Et, Ct, Rt, Ot, bt;
                if (C.b = f,
                C.e = d,
                f += "",
                d += "",
                d.substring(0, 6) === "var(--" && (d = Xr(a, d.substring(4, d.indexOf(")")))),
                d === "auto" && (pe = a.style[c],
                a.style[c] = d,
                d = Xr(a, c) || d,
                pe ? a.style[c] = pe : Ki(a, c)),
                q = [f, d],
                gn(q),
                f = q[0],
                d = q[1],
                Le = f.match(Y) || [],
                bt = d.match(Y) || [],
                bt.length) {
                    for (; Ee = Y.exec(d); )
                        at = Ee[0],
                        Ct = d.substring(B, Ee.index),
                        it ? it = (it + 1) % 5 : (Ct.substr(-5) === "rgba(" || Ct.substr(-5) === "hsla(") && (it = 1),
                        at !== (pe = Le[U++] || "") && (He = parseFloat(pe) || 0,
                        Ot = pe.substr((He + "").length),
                        at.charAt(1) === "=" && (at = fn(He, at) + Ot),
                        Et = parseFloat(at),
                        Rt = at.substr((Et + "").length),
                        B = Y.lastIndex - Rt.length,
                        Rt || (Rt = Rt || s.units[c] || Ot,
                        B === d.length && (d += Rt,
                        C.e += Rt)),
                        Ot !== Rt && (He = ui(a, c, pe, Rt) || 0),
                        C._pt = {
                            _next: C._pt,
                            p: Ct || U === 1 ? Ct : ",",
                            s: He,
                            c: Et - He,
                            m: it && it < 4 || c === "zIndex" ? Math.round : 0
                        });
                    C.c = B < d.length ? d.substring(B, d.length) : ""
                } else
                    C.r = c === "display" && d === "none" ? Mi : Ir;
                return Q.test(d) && (C.e = 0),
                this._pt = C,
                C
            }, go = {
                top: "0%",
                bottom: "100%",
                left: "0%",
                right: "100%",
                center: "50%"
            }, Bs = function(a) {
                var c = a.split(" ")
                  , f = c[0]
                  , d = c[1] || "50%";
                return (f === "top" || f === "bottom" || d === "left" || d === "right") && (a = f,
                f = d,
                d = a),
                c[0] = go[f] || f,
                c[1] = go[d] || d,
                c.join(" ")
            }, ma = function(a, c) {
                if (c.tween && c.tween._time === c.tween._dur) {
                    var f = c.t, d = f.style, _ = c.u, D = f._gsap, C, B, U;
                    if (_ === "all" || _ === !0)
                        d.cssText = "",
                        B = 1;
                    else
                        for (_ = _.split(","),
                        U = _.length; --U > -1; )
                            C = _[U],
                            or[C] && (B = 1,
                            C = C === "transformOrigin" ? Ur : Yn),
                            Ki(f, C);
                    B && (Ki(f, Yn),
                    D && (D.svg && f.removeAttribute("transform"),
                    d.scale = d.rotate = d.translate = "none",
                    Br(f, 1),
                    D.uncache = 1,
                    ei(d)))
                }
            }, yn = {
                clearProps: function(a, c, f, d, _) {
                    if (_.data !== "isFromStart") {
                        var D = a._pt = new Ni(a._pt,c,f,0,0,ma);
                        return D.u = d,
                        D.pr = -10,
                        D.tween = _,
                        a._props.push(f),
                        1
                    }
                }
            }, an = [1, 0, 0, 1, 0, 0], zn = {}, Ht = function(a) {
                return a === "matrix(1, 0, 0, 1, 0, 0)" || a === "none" || !a
            }, En = function(a) {
                var c = Xr(a, Yn);
                return Ht(c) ? an : c.substr(7).match(ee).map(Lt)
            }, sn = function(a, c) {
                var f = a._gsap || rt(a), d = a.style, _ = En(a), D, C, B, U;
                return f.svg && a.getAttribute("transform") ? (B = a.transform.baseVal.consolidate().matrix,
                _ = [B.a, B.b, B.c, B.d, B.e, B.f],
                _.join(",") === "1,0,0,1,0,0" ? an : _) : (_ === an && !a.offsetParent && a !== Yr && !f.svg && (B = d.display,
                d.display = "block",
                D = a.parentNode,
                (!D || !a.offsetParent && !a.getBoundingClientRect().width) && (U = 1,
                C = a.nextElementSibling,
                Yr.appendChild(a)),
                _ = En(a),
                B ? d.display = B : Ki(a, "display"),
                U && (C ? D.insertBefore(a, C) : D ? D.appendChild(a) : Yr.removeChild(a))),
                c && _.length > 6 ? [_[0], _[1], _[4], _[5], _[12], _[13]] : _)
            }, vn = function(a, c, f, d, _, D) {
                var C = a._gsap, B = _ || sn(a, !0), U = C.xOrigin || 0, q = C.yOrigin || 0, Ee = C.xOffset || 0, Le = C.yOffset || 0, He = B[0], it = B[1], pe = B[2], at = B[3], Et = B[4], Ct = B[5], Rt = c.split(" "), Ot = parseFloat(Rt[0]) || 0, bt = parseFloat(Rt[1]) || 0, qt, Gt, Kt, Mt;
                f ? B !== an && (Gt = He * at - it * pe) && (Kt = Ot * (at / Gt) + bt * (-pe / Gt) + (pe * Ct - at * Et) / Gt,
                Mt = Ot * (-it / Gt) + bt * (He / Gt) - (He * Ct - it * Et) / Gt,
                Ot = Kt,
                bt = Mt) : (qt = ho(a),
                Ot = qt.x + (~Rt[0].indexOf("%") ? Ot / 100 * qt.width : Ot),
                bt = qt.y + (~(Rt[1] || Rt[0]).indexOf("%") ? bt / 100 * qt.height : bt)),
                d || d !== !1 && C.smooth ? (Et = Ot - U,
                Ct = bt - q,
                C.xOffset = Ee + (Et * He + Ct * pe) - Et,
                C.yOffset = Le + (Et * it + Ct * at) - Ct) : C.xOffset = C.yOffset = 0,
                C.xOrigin = Ot,
                C.yOrigin = bt,
                C.smooth = !!d,
                C.origin = c,
                C.originIsAbsolute = !!f,
                a.style[Ur] = "0px 0px",
                D && (Dn(D, C, "xOrigin", U, Ot),
                Dn(D, C, "yOrigin", q, bt),
                Dn(D, C, "xOffset", Ee, C.xOffset),
                Dn(D, C, "yOffset", Le, C.yOffset)),
                a.setAttribute("data-svg-origin", Ot + " " + bt)
            }, Br = function(a, c) {
                var f = a._gsap || new Cl(a);
                if ("x"in f && !c && !f.uncache)
                    return f;
                var d = a.style, _ = f.scaleX < 0, D = "px", C = "deg", B = getComputedStyle(a), U = Xr(a, Ur) || "0", q, Ee, Le, He, it, pe, at, Et, Ct, Rt, Ot, bt, qt, Gt, Kt, Mt, Jn, Hr, Er, Cr, Li, Ti, fi, Pi, Hs, Vu, Al, Rl, ya, Bh, mo, va;
                return q = Ee = Le = pe = at = Et = Ct = Rt = Ot = 0,
                He = it = 1,
                f.svg = !!(a.getCTM && $s(a)),
                B.translate && ((B.translate !== "none" || B.scale !== "none" || B.rotate !== "none") && (d[Yn] = (B.translate !== "none" ? "translate3d(" + (B.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (B.rotate !== "none" ? "rotate(" + B.rotate + ") " : "") + (B.scale !== "none" ? "scale(" + B.scale.split(" ").join(",") + ") " : "") + (B[Yn] !== "none" ? B[Yn] : "")),
                d.scale = d.rotate = d.translate = "none"),
                Gt = sn(a, f.svg),
                f.svg && (f.uncache ? (Hs = a.getBBox(),
                U = f.xOrigin - Hs.x + "px " + (f.yOrigin - Hs.y) + "px",
                Pi = "") : Pi = !c && a.getAttribute("data-svg-origin"),
                vn(a, Pi || U, !!Pi || f.originIsAbsolute, f.smooth !== !1, Gt)),
                bt = f.xOrigin || 0,
                qt = f.yOrigin || 0,
                Gt !== an && (Hr = Gt[0],
                Er = Gt[1],
                Cr = Gt[2],
                Li = Gt[3],
                q = Ti = Gt[4],
                Ee = fi = Gt[5],
                Gt.length === 6 ? (He = Math.sqrt(Hr * Hr + Er * Er),
                it = Math.sqrt(Li * Li + Cr * Cr),
                pe = Hr || Er ? mi(Er, Hr) * Wi : 0,
                Ct = Cr || Li ? mi(Cr, Li) * Wi + pe : 0,
                Ct && (it *= Math.abs(Math.cos(Ct * qi))),
                f.svg && (q -= bt - (bt * Hr + qt * Cr),
                Ee -= qt - (bt * Er + qt * Li))) : (va = Gt[6],
                Bh = Gt[7],
                Al = Gt[8],
                Rl = Gt[9],
                ya = Gt[10],
                mo = Gt[11],
                q = Gt[12],
                Ee = Gt[13],
                Le = Gt[14],
                Kt = mi(va, ya),
                at = Kt * Wi,
                Kt && (Mt = Math.cos(-Kt),
                Jn = Math.sin(-Kt),
                Pi = Ti * Mt + Al * Jn,
                Hs = fi * Mt + Rl * Jn,
                Vu = va * Mt + ya * Jn,
                Al = Ti * -Jn + Al * Mt,
                Rl = fi * -Jn + Rl * Mt,
                ya = va * -Jn + ya * Mt,
                mo = Bh * -Jn + mo * Mt,
                Ti = Pi,
                fi = Hs,
                va = Vu),
                Kt = mi(-Cr, ya),
                Et = Kt * Wi,
                Kt && (Mt = Math.cos(-Kt),
                Jn = Math.sin(-Kt),
                Pi = Hr * Mt - Al * Jn,
                Hs = Er * Mt - Rl * Jn,
                Vu = Cr * Mt - ya * Jn,
                mo = Li * Jn + mo * Mt,
                Hr = Pi,
                Er = Hs,
                Cr = Vu),
                Kt = mi(Er, Hr),
                pe = Kt * Wi,
                Kt && (Mt = Math.cos(Kt),
                Jn = Math.sin(Kt),
                Pi = Hr * Mt + Er * Jn,
                Hs = Ti * Mt + fi * Jn,
                Er = Er * Mt - Hr * Jn,
                fi = fi * Mt - Ti * Jn,
                Hr = Pi,
                Ti = Hs),
                at && Math.abs(at) + Math.abs(pe) > 359.9 && (at = pe = 0,
                Et = 180 - Et),
                He = Lt(Math.sqrt(Hr * Hr + Er * Er + Cr * Cr)),
                it = Lt(Math.sqrt(fi * fi + va * va)),
                Kt = mi(Ti, fi),
                Ct = Math.abs(Kt) > 2e-4 ? Kt * Wi : 0,
                Ot = mo ? 1 / (mo < 0 ? -mo : mo) : 0),
                f.svg && (Pi = a.getAttribute("transform"),
                f.forceCSS = a.setAttribute("transform", "") || !Ht(Xr(a, Yn)),
                Pi && a.setAttribute("transform", Pi))),
                Math.abs(Ct) > 90 && Math.abs(Ct) < 270 && (_ ? (He *= -1,
                Ct += pe <= 0 ? 180 : -180,
                pe += pe <= 0 ? 180 : -180) : (it *= -1,
                Ct += Ct <= 0 ? 180 : -180)),
                c = c || f.uncache,
                f.x = q - ((f.xPercent = q && (!c && f.xPercent || (Math.round(a.offsetWidth / 2) === Math.round(-q) ? -50 : 0))) ? a.offsetWidth * f.xPercent / 100 : 0) + D,
                f.y = Ee - ((f.yPercent = Ee && (!c && f.yPercent || (Math.round(a.offsetHeight / 2) === Math.round(-Ee) ? -50 : 0))) ? a.offsetHeight * f.yPercent / 100 : 0) + D,
                f.z = Le + D,
                f.scaleX = Lt(He),
                f.scaleY = Lt(it),
                f.rotation = Lt(pe) + C,
                f.rotationX = Lt(at) + C,
                f.rotationY = Lt(Et) + C,
                f.skewX = Ct + C,
                f.skewY = Rt + C,
                f.transformPerspective = Ot + D,
                (f.zOrigin = parseFloat(U.split(" ")[2]) || !c && f.zOrigin || 0) && (d[Ur] = An(U)),
                f.xOffset = f.yOffset = 0,
                f.force3D = s.force3D,
                f.renderTransform = f.svg ? Rr : os ? as : Si,
                f.uncache = 0,
                f
            }, An = function(a) {
                return (a = a.split(" "))[0] + " " + a[1]
            }, Ar = function(a, c, f) {
                var d = oe(c);
                return Lt(parseFloat(c) + parseFloat(ui(a, "x", f + "px", d))) + d
            }, Si = function(a, c) {
                c.z = "0px",
                c.rotationY = c.rotationX = "0deg",
                c.force3D = 0,
                as(a, c)
            }, nr = "0deg", rr = "0px", Vn = ") ", as = function(a, c) {
                var f = c || this
                  , d = f.xPercent
                  , _ = f.yPercent
                  , D = f.x
                  , C = f.y
                  , B = f.z
                  , U = f.rotation
                  , q = f.rotationY
                  , Ee = f.rotationX
                  , Le = f.skewX
                  , He = f.skewY
                  , it = f.scaleX
                  , pe = f.scaleY
                  , at = f.transformPerspective
                  , Et = f.force3D
                  , Ct = f.target
                  , Rt = f.zOrigin
                  , Ot = ""
                  , bt = Et === "auto" && a && a !== 1 || Et === !0;
                if (Rt && (Ee !== nr || q !== nr)) {
                    var qt = parseFloat(q) * qi, Gt = Math.sin(qt), Kt = Math.cos(qt), Mt;
                    qt = parseFloat(Ee) * qi,
                    Mt = Math.cos(qt),
                    D = Ar(Ct, D, Gt * Mt * -Rt),
                    C = Ar(Ct, C, -Math.sin(qt) * -Rt),
                    B = Ar(Ct, B, Kt * Mt * -Rt + Rt)
                }
                at !== rr && (Ot += "perspective(" + at + Vn),
                (d || _) && (Ot += "translate(" + d + "%, " + _ + "%) "),
                (bt || D !== rr || C !== rr || B !== rr) && (Ot += B !== rr || bt ? "translate3d(" + D + ", " + C + ", " + B + ") " : "translate(" + D + ", " + C + Vn),
                U !== nr && (Ot += "rotate(" + U + Vn),
                q !== nr && (Ot += "rotateY(" + q + Vn),
                Ee !== nr && (Ot += "rotateX(" + Ee + Vn),
                (Le !== nr || He !== nr) && (Ot += "skew(" + Le + ", " + He + Vn),
                (it !== 1 || pe !== 1) && (Ot += "scale(" + it + ", " + pe + Vn),
                Ct.style[Yn] = Ot || "translate(0, 0)"
            }, Rr = function(a, c) {
                var f = c || this, d = f.xPercent, _ = f.yPercent, D = f.x, C = f.y, B = f.rotation, U = f.skewX, q = f.skewY, Ee = f.scaleX, Le = f.scaleY, He = f.target, it = f.xOrigin, pe = f.yOrigin, at = f.xOffset, Et = f.yOffset, Ct = f.forceCSS, Rt = parseFloat(D), Ot = parseFloat(C), bt, qt, Gt, Kt, Mt;
                B = parseFloat(B),
                U = parseFloat(U),
                q = parseFloat(q),
                q && (q = parseFloat(q),
                U += q,
                B += q),
                B || U ? (B *= qi,
                U *= qi,
                bt = Math.cos(B) * Ee,
                qt = Math.sin(B) * Ee,
                Gt = Math.sin(B - U) * -Le,
                Kt = Math.cos(B - U) * Le,
                U && (q *= qi,
                Mt = Math.tan(U - q),
                Mt = Math.sqrt(1 + Mt * Mt),
                Gt *= Mt,
                Kt *= Mt,
                q && (Mt = Math.tan(q),
                Mt = Math.sqrt(1 + Mt * Mt),
                bt *= Mt,
                qt *= Mt)),
                bt = Lt(bt),
                qt = Lt(qt),
                Gt = Lt(Gt),
                Kt = Lt(Kt)) : (bt = Ee,
                Kt = Le,
                qt = Gt = 0),
                (Rt && !~(D + "").indexOf("px") || Ot && !~(C + "").indexOf("px")) && (Rt = ui(He, "x", D, "px"),
                Ot = ui(He, "y", C, "px")),
                (it || pe || at || Et) && (Rt = Lt(Rt + it - (it * bt + pe * Gt) + at),
                Ot = Lt(Ot + pe - (it * qt + pe * Kt) + Et)),
                (d || _) && (Mt = He.getBBox(),
                Rt = Lt(Rt + d / 100 * Mt.width),
                Ot = Lt(Ot + _ / 100 * Mt.height)),
                Mt = "matrix(" + bt + "," + qt + "," + Gt + "," + Kt + "," + Rt + "," + Ot + ")",
                He.setAttribute("transform", Mt),
                Ct && (He.style[Yn] = Mt)
            }, Xi = function(a, c, f, d, _) {
                var D = 360, C = x(_), B = parseFloat(_) * (C && ~_.indexOf("rad") ? Wi : 1), U = B - d, q = d + U + "deg", Ee, Le;
                return C && (Ee = _.split("_")[1],
                Ee === "short" && (U %= D,
                U !== U % (D / 2) && (U += U < 0 ? D : -360)),
                Ee === "cw" && U < 0 ? U = (U + D * bs) % D - ~~(U / D) * D : Ee === "ccw" && U > 0 && (U = (U - D * bs) % D - ~~(U / D) * D)),
                a._pt = Le = new Ni(a._pt,c,f,d,U,Oi),
                Le.e = q,
                Le.u = "deg",
                a._props.push(f),
                Le
            }, gs = function(a, c) {
                for (var f in c)
                    a[f] = c[f];
                return a
            }, yi = function(a, c, f) {
                var d = gs({}, f._gsap), _ = "perspective,force3D,transformOrigin,svgOrigin", D = f.style, C, B, U, q, Ee, Le, He, it;
                d.svg ? (U = f.getAttribute("transform"),
                f.setAttribute("transform", ""),
                D[Yn] = c,
                C = Br(f, 1),
                Ki(f, Yn),
                f.setAttribute("transform", U)) : (U = getComputedStyle(f)[Yn],
                D[Yn] = c,
                C = Br(f, 1),
                D[Yn] = U);
                for (B in or)
                    U = d[B],
                    q = C[B],
                    U !== q && _.indexOf(B) < 0 && (He = oe(U),
                    it = oe(q),
                    Ee = He !== it ? ui(f, B, U, it) : parseFloat(U),
                    Le = parseFloat(q),
                    a._pt = new Ni(a._pt,C,B,Ee,Le - Ee,ws),
                    a._pt.u = it || 0,
                    a._props.push(B));
                gs(C, d)
            };
            xt("padding,margin,Width,Radius", function(j, a) {
                var c = "Top"
                  , f = "Right"
                  , d = "Bottom"
                  , _ = "Left"
                  , D = (a < 3 ? [c, f, d, _] : [c + _, c + f, d + f, d + _]).map(function(C) {
                    return a < 2 ? j + C : "border" + C + j
                });
                yn[a > 1 ? "border" + j : j] = function(C, B, U, q, Ee) {
                    var Le, He;
                    if (arguments.length < 4)
                        return Le = D.map(function(it) {
                            return ti(C, it, U)
                        }),
                        He = Le.join(" "),
                        He.split(Le[0]).length === 5 ? Le[0] : He;
                    Le = (q + "").split(" "),
                    He = {},
                    D.forEach(function(it, pe) {
                        return He[it] = Le[pe] = Le[pe] || Le[(pe - 1) / 2 | 0]
                    }),
                    C.init(B, He, Ee)
                }
            });
            var ni = {
                name: "css",
                register: Ho,
                targetTest: function(a) {
                    return a.style && a.nodeType
                },
                init: function(a, c, f, d, _) {
                    var D = this._props, C = a.style, B = f.vars.startAt, U, q, Ee, Le, He, it, pe, at, Et, Ct, Rt, Ot, bt, qt, Gt, Kt;
                    _i || Ho(),
                    this.styles = this.styles || $r(a),
                    Kt = this.styles.props,
                    this.tween = f;
                    for (pe in c)
                        if (pe !== "autoRound" && (q = c[pe],
                        !(Ne[pe] && fa(pe, c, f, d, a, _)))) {
                            if (He = typeof q,
                            it = yn[pe],
                            He === "function" && (q = q.call(f, d, a, _),
                            He = typeof q),
                            He === "string" && ~q.indexOf("random(") && (q = ur(q)),
                            it)
                                it(this, a, pe, q, f) && (Gt = 1);
                            else if (pe.substr(0, 2) === "--")
                                U = (getComputedStyle(a).getPropertyValue(pe) + "").trim(),
                                q += "",
                                Qn.lastIndex = 0,
                                Qn.test(U) || (at = oe(U),
                                Et = oe(q)),
                                Et ? at !== Et && (U = ui(a, pe, U, Et) + Et) : at && (q += at),
                                this.add(C, "setProperty", U, q, d, _, 0, 0, pe),
                                D.push(pe),
                                Kt.push(pe, 0, C[pe]);
                            else if (He !== "undefined") {
                                if (B && pe in B ? (U = typeof B[pe] == "function" ? B[pe].call(f, d, a, _) : B[pe],
                                x(U) && ~U.indexOf("random(") && (U = ur(U)),
                                oe(U + "") || U === "auto" || (U += s.units[pe] || oe(ti(a, pe)) || ""),
                                (U + "").charAt(1) === "=" && (U = ti(a, pe))) : U = ti(a, pe),
                                Le = parseFloat(U),
                                Ct = He === "string" && q.charAt(1) === "=" && q.substr(0, 2),
                                Ct && (q = q.substr(2)),
                                Ee = parseFloat(q),
                                pe in mr && (pe === "autoAlpha" && (Le === 1 && ti(a, "visibility") === "hidden" && Ee && (Le = 0),
                                Kt.push("visibility", 0, C.visibility),
                                Dn(this, C, "visibility", Le ? "inherit" : "hidden", Ee ? "inherit" : "hidden", !Ee)),
                                pe !== "scale" && pe !== "transform" && (pe = mr[pe],
                                ~pe.indexOf(",") && (pe = pe.split(",")[0]))),
                                Rt = pe in or,
                                Rt) {
                                    if (this.styles.save(pe),
                                    He === "string" && q.substring(0, 6) === "var(--" && (q = Xr(a, q.substring(4, q.indexOf(")"))),
                                    Ee = parseFloat(q)),
                                    Ot || (bt = a._gsap,
                                    bt.renderTransform && !c.parseTransform || Br(a, c.parseTransform),
                                    qt = c.smoothOrigin !== !1 && bt.smooth,
                                    Ot = this._pt = new Ni(this._pt,C,Yn,0,1,bt.renderTransform,bt,0,-1),
                                    Ot.dep = 1),
                                    pe === "scale")
                                        this._pt = new Ni(this._pt,bt,"scaleY",bt.scaleY,(Ct ? fn(bt.scaleY, Ct + Ee) : Ee) - bt.scaleY || 0,ws),
                                        this._pt.u = 0,
                                        D.push("scaleY", pe),
                                        pe += "X";
                                    else if (pe === "transformOrigin") {
                                        Kt.push(Ur, 0, C[Ur]),
                                        q = Bs(q),
                                        bt.svg ? vn(a, q, 0, qt, 0, this) : (Et = parseFloat(q.split(" ")[2]) || 0,
                                        Et !== bt.zOrigin && Dn(this, bt, "zOrigin", bt.zOrigin, Et),
                                        Dn(this, C, pe, An(U), An(q)));
                                        continue
                                    } else if (pe === "svgOrigin") {
                                        vn(a, q, 1, qt, 0, this);
                                        continue
                                    } else if (pe in zn) {
                                        Xi(this, bt, pe, Le, Ct ? fn(Le, Ct + q) : q);
                                        continue
                                    } else if (pe === "smoothOrigin") {
                                        Dn(this, bt, "smooth", bt.smooth, q);
                                        continue
                                    } else if (pe === "force3D") {
                                        bt[pe] = q;
                                        continue
                                    } else if (pe === "transform") {
                                        yi(this, q, a);
                                        continue
                                    }
                                } else
                                    pe in C || (pe = yr(pe) || pe);
                                if (Rt || (Ee || Ee === 0) && (Le || Le === 0) && !Ri.test(q) && pe in C)
                                    at = (U + "").substr((Le + "").length),
                                    Ee || (Ee = 0),
                                    Et = oe(q) || (pe in s.units ? s.units[pe] : at),
                                    at !== Et && (Le = ui(a, pe, U, Et)),
                                    this._pt = new Ni(this._pt,Rt ? bt : C,pe,Le,(Ct ? fn(Le, Ct + Ee) : Ee) - Le,!Rt && (Et === "px" || pe === "zIndex") && c.autoRound !== !1 ? Hn : ws),
                                    this._pt.u = Et || 0,
                                    at !== Et && Et !== "%" && (this._pt.b = U,
                                    this._pt.r = Bi);
                                else if (pe in C)
                                    po.call(this, a, pe, U, Ct ? Ct + q : q);
                                else if (pe in a)
                                    this.add(a, pe, U || a[pe], Ct ? Ct + q : q, d, _);
                                else if (pe !== "parseTransform") {
                                    he(pe, q);
                                    continue
                                }
                                Rt || (pe in C ? Kt.push(pe, 0, C[pe]) : typeof a[pe] == "function" ? Kt.push(pe, 2, a[pe]()) : Kt.push(pe, 1, U || a[pe])),
                                D.push(pe)
                            }
                        }
                    Gt && kl(this)
                },
                render: function(a, c) {
                    if (c.tween._time || !Fr())
                        for (var f = c._pt; f; )
                            f.r(a, f.d),
                            f = f._next;
                    else
                        c.styles.revert()
                },
                get: ti,
                aliases: mr,
                getSetter: function(a, c, f) {
                    var d = mr[c];
                    return d && d.indexOf(",") < 0 && (c = d),
                    c in or && c !== Ur && (a._gsap.x || ti(a, "x")) ? f && zr === f ? c === "scale" ? Ns : Yi : (zr = f || {}) && (c === "scale" ? Qs : Nr) : a.style && !S(a.style[c]) ? Gi : ~c.indexOf("-") ? Xe : Ba(a, c)
                },
                core: {
                    _removeProperty: Ki,
                    _getMatrix: sn
                }
            };
            wn.utils.checkPrefix = yr,
            wn.core.getStyleSaver = $r,
            function(j, a, c, f) {
                var d = xt(j + "," + a + "," + c, function(_) {
                    or[_] = 1
                });
                xt(a, function(_) {
                    s.units[_] = "deg",
                    zn[_] = 1
                }),
                mr[d[13]] = j + "," + a,
                xt(f, function(_) {
                    var D = _.split(":");
                    mr[D[1]] = d[D[0]]
                })
            }("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"),
            xt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(j) {
                s.units[j] = "px"
            }),
            wn.registerPlugin(ni);
            var ci = wn.registerPlugin(ni) || wn
              , _o = ci.core.Tween;
            n.Back = mn,
            n.Bounce = $i,
            n.CSSPlugin = ni,
            n.Circ = _n,
            n.Cubic = kr,
            n.Elastic = Dr,
            n.Expo = ai,
            n.Linear = dr,
            n.Power0 = Rn,
            n.Power1 = on,
            n.Power2 = _t,
            n.Power3 = un,
            n.Power4 = Lr,
            n.Quad = Zr,
            n.Quart = gi,
            n.Quint = Sn,
            n.Sine = rn,
            n.SteppedEase = Ai,
            n.Strong = ss,
            n.TimelineLite = oi,
            n.TimelineMax = oi,
            n.TweenLite = jr,
            n.TweenMax = _o,
            n.default = ci,
            n.gsap = ci,
            typeof window > "u" || window !== n ? Object.defineProperty(n, "__esModule", {
                value: !0
            }) : delete window.default
        })
    }(Vl, Vl.exports)),
    Vl.exports
}
var In = LT(), jl = {
    exports: {}
}, FT = jl.exports, Dg;
function IT() {
    return Dg || (Dg = 1,
    function(e, t) {
        (function(n, r) {
            r(t)
        }
        )(FT, function(n) {
            function r(Pe, A) {
                for (var te = 0; te < A.length; te++) {
                    var N = A[te];
                    N.enumerable = N.enumerable || !1,
                    N.configurable = !0,
                    "value"in N && (N.writable = !0),
                    Object.defineProperty(Pe, N.key, N)
                }
            }
            function i(Pe, A, te) {
                return A && r(Pe.prototype, A),
                Pe
            }
            /*!
 * Observer 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
            var s, o, l, u, p, h, g, m, w, E, y, R, P, x = function() {
                return s || typeof window < "u" && (s = window.gsap) && s.registerPlugin && s
            }, v = 1, k = [], S = [], W = [], K = Date.now, be = function(A, te) {
                return te
            }, fe = function() {
                var A = w.core
                  , te = A.bridge || {}
                  , N = A._scrollers
                  , V = A._proxies;
                N.push.apply(N, S),
                V.push.apply(V, W),
                S = N,
                W = V,
                be = function(Ke, Be) {
                    return te[Ke](Be)
                }
            }, ge = function(A, te) {
                return ~W.indexOf(A) && W[W.indexOf(A) + 1][te]
            }, J = function(A) {
                return !!~E.indexOf(A)
            }, re = function(A, te, N, V, De) {
                return A.addEventListener(te, N, {
                    passive: V !== !1,
                    capture: !!De
                })
            }, ee = function(A, te, N, V) {
                return A.removeEventListener(te, N, !!V)
            }, Y = "scrollLeft", Z = "scrollTop", Q = function() {
                return y && y.isPressed || S.cache++
            }, ue = function(A, te) {
                var N = function V(De) {
                    if (De || De === 0) {
                        v && (l.history.scrollRestoration = "manual");
                        var Ke = y && y.isPressed;
                        De = V.v = Math.round(De) || (y && y.iOS ? 1 : 0),
                        A(De),
                        V.cacheID = S.cache,
                        Ke && be("ss", De)
                    } else
                        (te || S.cache !== V.cacheID || be("ref")) && (V.cacheID = S.cache,
                        V.v = A());
                    return V.v + V.offset
                };
                return N.offset = 0,
                A && N
            }, se = {
                s: Y,
                p: "left",
                p2: "Left",
                os: "right",
                os2: "Right",
                d: "width",
                d2: "Width",
                a: "x",
                sc: ue(function(Pe) {
                    return arguments.length ? l.scrollTo(Pe, ye.sc()) : l.pageXOffset || u[Y] || p[Y] || h[Y] || 0
                })
            }, ye = {
                s: Z,
                p: "top",
                p2: "Top",
                os: "bottom",
                os2: "Bottom",
                d: "height",
                d2: "Height",
                a: "y",
                op: se,
                sc: ue(function(Pe) {
                    return arguments.length ? l.scrollTo(se.sc(), Pe) : l.pageYOffset || u[Z] || p[Z] || h[Z] || 0
                })
            }, Ze = function(A, te) {
                return (te && te._ctx && te._ctx.selector || s.utils.toArray)(A)[0] || (typeof A == "string" && s.config().nullTargetWarn !== !1 ? console.warn("Element not found:", A) : null)
            }, qe = function(A, te) {
                for (var N = te.length; N--; )
                    if (te[N] === A || te[N].contains(A))
                        return !0;
                return !1
            }, nt = function(A, te) {
                var N = te.s
                  , V = te.sc;
                J(A) && (A = u.scrollingElement || p);
                var De = S.indexOf(A)
                  , Ke = V === ye.sc ? 1 : 2;
                !~De && (De = S.push(A) - 1),
                S[De + Ke] || re(A, "scroll", Q);
                var Be = S[De + Ke]
                  , Wt = Be || (S[De + Ke] = ue(ge(A, N), !0) || (J(A) ? V : ue(function(cn) {
                    return arguments.length ? A[N] = cn : A[N]
                })));
                return Wt.target = A,
                Be || (Wt.smooth = s.getProperty(A, "scrollBehavior") === "smooth"),
                Wt
            }, mt = function(A, te, N) {
                var V = A
                  , De = A
                  , Ke = K()
                  , Be = Ke
                  , Wt = te || 50
                  , cn = Math.max(500, Wt * 3)
                  , wn = function(un, Lr) {
                    var dr = K();
                    Lr || dr - Ke > Wt ? (De = V,
                    V = un,
                    Be = Ke,
                    Ke = dr) : N ? V += un : V = De + (un - De) / (dr - Be) * (Ke - Be)
                }
                  , Rn = function() {
                    De = V = N ? 0 : V,
                    Be = Ke = 0
                }
                  , on = function(un) {
                    var Lr = Be
                      , dr = De
                      , Zr = K();
                    return (un || un === 0) && un !== V && wn(un),
                    Ke === Be || Zr - Be > cn ? 0 : (V + (N ? dr : -dr)) / ((N ? Zr : Ke) - Lr) * 1e3
                };
                return {
                    update: wn,
                    reset: Rn,
                    getVelocity: on
                }
            }, yt = function(A, te) {
                return te && !A._gsapAllow && A.preventDefault(),
                A.changedTouches ? A.changedTouches[0] : A
            }, At = function(A) {
                var te = Math.max.apply(Math, A)
                  , N = Math.min.apply(Math, A);
                return Math.abs(te) >= Math.abs(N) ? te : N
            }, Tt = function() {
                w = s.core.globals().ScrollTrigger,
                w && w.core && fe()
            }, he = function(A) {
                return s = A || x(),
                !o && s && typeof document < "u" && document.body && (l = window,
                u = document,
                p = u.documentElement,
                h = u.body,
                E = [l, u, p, h],
                s.utils.clamp,
                P = s.core.context || function() {}
                ,
                m = "onpointerenter"in h ? "pointer" : "mouse",
                g = ve.isTouch = l.matchMedia && l.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in l || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
                R = ve.eventTypes = ("ontouchstart"in p ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in p ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
                setTimeout(function() {
                    return v = 0
                }, 500),
                Tt(),
                o = 1),
                o
            };
            se.op = ye,
            S.cache = 0;
            var ve = function() {
                function Pe(te) {
                    this.init(te)
                }
                var A = Pe.prototype;
                return A.init = function(N) {
                    o || he(s) || console.warn("Please gsap.registerPlugin(Observer)"),
                    w || Tt();
                    var V = N.tolerance
                      , De = N.dragMinimum
                      , Ke = N.type
                      , Be = N.target
                      , Wt = N.lineHeight
                      , cn = N.debounce
                      , wn = N.preventDefault
                      , Rn = N.onStop
                      , on = N.onStopDelay
                      , _t = N.ignore
                      , un = N.wheelSpeed
                      , Lr = N.event
                      , dr = N.onDragStart
                      , Zr = N.onDragEnd
                      , kr = N.onDrag
                      , gi = N.onPress
                      , Sn = N.onRelease
                      , ss = N.onRight
                      , Dr = N.onLeft
                      , mn = N.onUp
                      , Ai = N.onDown
                      , $i = N.onChangeX
                      , rn = N.onChangeY
                      , ai = N.onChange
                      , _n = N.onToggleX
                      , vs = N.onToggleY
                      , hr = N.onHover
                      , Yr = N.onHoverEnd
                      , _i = N.onMove
                      , Bn = N.ignoreCheck
                      , zr = N.isNormalizer
                      , Fr = N.onGestureStart
                      , Ae = N.onGestureEnd
                      , or = N.onWheel
                      , Wi = N.onEnable
                      , qi = N.onDisable
                      , mi = N.onClick
                      , bs = N.scrollSpeed
                      , li = N.capture
                      , Kr = N.allowClicks
                      , Ri = N.lockAxis
                      , mr = N.onLockAxis;
                    this.target = Be = Ze(Be) || p,
                    this.vars = N,
                    _t && (_t = s.utils.toArray(_t)),
                    V = V || 1e-9,
                    De = De || 0,
                    un = un || 1,
                    bs = bs || 1,
                    Ke = Ke || "wheel,touch,pointer",
                    cn = cn !== !1,
                    Wt || (Wt = parseFloat(l.getComputedStyle(h).lineHeight) || 22);
                    var ws, Oi, Bi, Hn, Ir, Mi, Gi, Xe = this, Yi = 0, Ns = 0, Qs = N.passive || !wn && N.passive !== !1, Nr = nt(Be, se), Yn = nt(Be, ye), Ur = Nr(), co = Yn(), ei = ~Ke.indexOf("touch") && !~Ke.indexOf("pointer") && R[0] === "pointerdown", Js = J(Be), $r = Be.ownerDocument || u, os = [0, 0, 0], Hi = [0, 0, 0], Xr = 0, Bo = function() {
                        return Xr = K()
                    }, yr = function(an, zn) {
                        return (Xe.event = an) && _t && qe(an.target, _t) || zn && ei && an.pointerType !== "touch" || Bn && Bn(an, zn)
                    }, Ho = function() {
                        Xe._vx.reset(),
                        Xe._vy.reset(),
                        Oi.pause(),
                        Rn && Rn(Xe)
                    }, Ds = function() {
                        var an = Xe.deltaX = At(os)
                          , zn = Xe.deltaY = At(Hi)
                          , Ht = Math.abs(an) >= V
                          , En = Math.abs(zn) >= V;
                        ai && (Ht || En) && ai(Xe, an, zn, os, Hi),
                        Ht && (ss && Xe.deltaX > 0 && ss(Xe),
                        Dr && Xe.deltaX < 0 && Dr(Xe),
                        $i && $i(Xe),
                        _n && Xe.deltaX < 0 != Yi < 0 && _n(Xe),
                        Yi = Xe.deltaX,
                        os[0] = os[1] = os[2] = 0),
                        En && (Ai && Xe.deltaY > 0 && Ai(Xe),
                        mn && Xe.deltaY < 0 && mn(Xe),
                        rn && rn(Xe),
                        vs && Xe.deltaY < 0 != Ns < 0 && vs(Xe),
                        Ns = Xe.deltaY,
                        Hi[0] = Hi[1] = Hi[2] = 0),
                        (Hn || Bi) && (_i && _i(Xe),
                        Bi && (dr && Bi === 1 && dr(Xe),
                        kr && kr(Xe),
                        Bi = 0),
                        Hn = !1),
                        Mi && !(Mi = !1) && mr && mr(Xe),
                        Ir && (or(Xe),
                        Ir = !1),
                        ws = 0
                    }, fo = function(an, zn, Ht) {
                        os[Ht] += an,
                        Hi[Ht] += zn,
                        Xe._vx.update(an),
                        Xe._vy.update(zn),
                        cn ? ws || (ws = requestAnimationFrame(Ds)) : Ds()
                    }, ho = function(an, zn) {
                        Ri && !Gi && (Xe.axis = Gi = Math.abs(an) > Math.abs(zn) ? "x" : "y",
                        Mi = !0),
                        Gi !== "y" && (os[2] += an,
                        Xe._vx.update(an, !0)),
                        Gi !== "x" && (Hi[2] += zn,
                        Xe._vy.update(zn, !0)),
                        cn ? ws || (ws = requestAnimationFrame(Ds)) : Ds()
                    }, $s = function(an) {
                        if (!yr(an, 1)) {
                            an = yt(an, wn);
                            var zn = an.clientX
                              , Ht = an.clientY
                              , En = zn - Xe.x
                              , sn = Ht - Xe.y
                              , vn = Xe.isDragging;
                            Xe.x = zn,
                            Xe.y = Ht,
                            (vn || (En || sn) && (Math.abs(Xe.startX - zn) >= De || Math.abs(Xe.startY - Ht) >= De)) && (Bi = vn ? 2 : 1,
                            vn || (Xe.isDragging = !0),
                            ho(En, sn))
                        }
                    }, Ki = Xe.onPress = function(yn) {
                        yr(yn, 1) || yn && yn.button || (Xe.axis = Gi = null,
                        Oi.pause(),
                        Xe.isPressed = !0,
                        yn = yt(yn),
                        Yi = Ns = 0,
                        Xe.startX = Xe.x = yn.clientX,
                        Xe.startY = Xe.y = yn.clientY,
                        Xe._vx.reset(),
                        Xe._vy.reset(),
                        re(zr ? Be : $r, R[1], $s, Qs, !0),
                        Xe.deltaX = Xe.deltaY = 0,
                        gi && gi(Xe))
                    }
                    , Dn = Xe.onRelease = function(yn) {
                        if (!yr(yn, 1)) {
                            ee(zr ? Be : $r, R[1], $s, !0);
                            var an = !isNaN(Xe.y - Xe.startY)
                              , zn = Xe.isDragging
                              , Ht = zn && (Math.abs(Xe.x - Xe.startX) > 3 || Math.abs(Xe.y - Xe.startY) > 3)
                              , En = yt(yn);
                            !Ht && an && (Xe._vx.reset(),
                            Xe._vy.reset(),
                            wn && Kr && s.delayedCall(.08, function() {
                                if (K() - Xr > 300 && !yn.defaultPrevented) {
                                    if (yn.target.click)
                                        yn.target.click();
                                    else if ($r.createEvent) {
                                        var sn = $r.createEvent("MouseEvents");
                                        sn.initMouseEvent("click", !0, !0, l, 1, En.screenX, En.screenY, En.clientX, En.clientY, !1, !1, !1, !1, 0, null),
                                        yn.target.dispatchEvent(sn)
                                    }
                                }
                            })),
                            Xe.isDragging = Xe.isGesturing = Xe.isPressed = !1,
                            Rn && zn && !zr && Oi.restart(!0),
                            Bi && Ds(),
                            Zr && zn && Zr(Xe),
                            Sn && Sn(Xe, Ht)
                        }
                    }
                    , Zs = function(an) {
                        return an.touches && an.touches.length > 1 && (Xe.isGesturing = !0) && Fr(an, Xe.isDragging)
                    }, ps = function() {
                        return (Xe.isGesturing = !1) || Ae(Xe)
                    }, ui = function(an) {
                        if (!yr(an)) {
                            var zn = Nr()
                              , Ht = Yn();
                            fo((zn - Ur) * bs, (Ht - co) * bs, 1),
                            Ur = zn,
                            co = Ht,
                            Rn && Oi.restart(!0)
                        }
                    }, ti = function(an) {
                        if (!yr(an)) {
                            an = yt(an, wn),
                            or && (Ir = !0);
                            var zn = (an.deltaMode === 1 ? Wt : an.deltaMode === 2 ? l.innerHeight : 1) * un;
                            fo(an.deltaX * zn, an.deltaY * zn, 0),
                            Rn && !zr && Oi.restart(!0)
                        }
                    }, po = function(an) {
                        if (!yr(an)) {
                            var zn = an.clientX
                              , Ht = an.clientY
                              , En = zn - Xe.x
                              , sn = Ht - Xe.y;
                            Xe.x = zn,
                            Xe.y = Ht,
                            Hn = !0,
                            Rn && Oi.restart(!0),
                            (En || sn) && ho(En, sn)
                        }
                    }, go = function(an) {
                        Xe.event = an,
                        hr(Xe)
                    }, Bs = function(an) {
                        Xe.event = an,
                        Yr(Xe)
                    }, ma = function(an) {
                        return yr(an) || yt(an, wn) && mi(Xe)
                    };
                    Oi = Xe._dc = s.delayedCall(on || .25, Ho).pause(),
                    Xe.deltaX = Xe.deltaY = 0,
                    Xe._vx = mt(0, 50, !0),
                    Xe._vy = mt(0, 50, !0),
                    Xe.scrollX = Nr,
                    Xe.scrollY = Yn,
                    Xe.isDragging = Xe.isGesturing = Xe.isPressed = !1,
                    P(this),
                    Xe.enable = function(yn) {
                        return Xe.isEnabled || (re(Js ? $r : Be, "scroll", Q),
                        Ke.indexOf("scroll") >= 0 && re(Js ? $r : Be, "scroll", ui, Qs, li),
                        Ke.indexOf("wheel") >= 0 && re(Be, "wheel", ti, Qs, li),
                        (Ke.indexOf("touch") >= 0 && g || Ke.indexOf("pointer") >= 0) && (re(Be, R[0], Ki, Qs, li),
                        re($r, R[2], Dn),
                        re($r, R[3], Dn),
                        Kr && re(Be, "click", Bo, !0, !0),
                        mi && re(Be, "click", ma),
                        Fr && re($r, "gesturestart", Zs),
                        Ae && re($r, "gestureend", ps),
                        hr && re(Be, m + "enter", go),
                        Yr && re(Be, m + "leave", Bs),
                        _i && re(Be, m + "move", po)),
                        Xe.isEnabled = !0,
                        Xe.isDragging = Xe.isGesturing = Xe.isPressed = Hn = Bi = !1,
                        Xe._vx.reset(),
                        Xe._vy.reset(),
                        Ur = Nr(),
                        co = Yn(),
                        yn && yn.type && Ki(yn),
                        Wi && Wi(Xe)),
                        Xe
                    }
                    ,
                    Xe.disable = function() {
                        Xe.isEnabled && (k.filter(function(yn) {
                            return yn !== Xe && J(yn.target)
                        }).length || ee(Js ? $r : Be, "scroll", Q),
                        Xe.isPressed && (Xe._vx.reset(),
                        Xe._vy.reset(),
                        ee(zr ? Be : $r, R[1], $s, !0)),
                        ee(Js ? $r : Be, "scroll", ui, li),
                        ee(Be, "wheel", ti, li),
                        ee(Be, R[0], Ki, li),
                        ee($r, R[2], Dn),
                        ee($r, R[3], Dn),
                        ee(Be, "click", Bo, !0),
                        ee(Be, "click", ma),
                        ee($r, "gesturestart", Zs),
                        ee($r, "gestureend", ps),
                        ee(Be, m + "enter", go),
                        ee(Be, m + "leave", Bs),
                        ee(Be, m + "move", po),
                        Xe.isEnabled = Xe.isPressed = Xe.isDragging = !1,
                        qi && qi(Xe))
                    }
                    ,
                    Xe.kill = Xe.revert = function() {
                        Xe.disable();
                        var yn = k.indexOf(Xe);
                        yn >= 0 && k.splice(yn, 1),
                        y === Xe && (y = 0)
                    }
                    ,
                    k.push(Xe),
                    zr && J(Be) && (y = Xe),
                    Xe.enable(Lr)
                }
                ,
                i(Pe, [{
                    key: "velocityX",
                    get: function() {
                        return this._vx.getVelocity()
                    }
                }, {
                    key: "velocityY",
                    get: function() {
                        return this._vy.getVelocity()
                    }
                }]),
                Pe
            }();
            ve.version = "3.13.0",
            ve.create = function(Pe) {
                return new ve(Pe)
            }
            ,
            ve.register = he,
            ve.getAll = function() {
                return k.slice()
            }
            ,
            ve.getById = function(Pe) {
                return k.filter(function(A) {
                    return A.vars.id === Pe
                })[0]
            }
            ,
            x() && s.registerPlugin(ve);
            /*!
 * ScrollTrigger 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
            var ae, ze, Se, Je, I, $, de, Me, Te, Ne, lt, st, Ue, Ge, wt, rt, Dt, xt, Lt, Jt, fn, Fn, hn, Ln, Kn, lr, ht, X, ie, _e, ke, Fe, Ce, $e, Ye = 1, je = Date.now, vt = je(), ot = 0, Ve = 0, ut = function(A, te, N) {
                var V = M(A) && (A.substr(0, 6) === "clamp(" || A.indexOf("max") > -1);
                return N["_" + te + "Clamp"] = V,
                V ? A.substr(6, A.length - 7) : A
            }, Ft = function(A, te) {
                return te && (!M(A) || A.substr(0, 6) !== "clamp(") ? "clamp(" + A + ")" : A
            }, ft = function Pe() {
                return Ve && requestAnimationFrame(Pe)
            }, gt = function() {
                return Ge = 1
            }, et = function() {
                return Ge = 0
            }, Oe = function(A) {
                return A
            }, O = function(A) {
                return Math.round(A * 1e5) / 1e5 || 0
            }, z = function() {
                return typeof window < "u"
            }, L = function() {
                return ae || z() && (ae = window.gsap) && ae.registerPlugin && ae
            }, ne = function(A) {
                return !!~de.indexOf(A)
            }, le = function(A) {
                return (A === "Height" ? ke : Se["inner" + A]) || I["client" + A] || $["client" + A]
            }, Ie = function(A) {
                return ge(A, "getBoundingClientRect") || (ne(A) ? function() {
                    return $o.width = Se.innerWidth,
                    $o.height = ke,
                    $o
                }
                : function() {
                    return br(A)
                }
                )
            }, ct = function(A, te, N) {
                var V = N.d
                  , De = N.d2
                  , Ke = N.a;
                return (Ke = ge(A, "getBoundingClientRect")) ? function() {
                    return Ke()[V]
                }
                : function() {
                    return (te ? le(De) : A["client" + De]) || 0
                }
            }, F = function(A, te) {
                return !te || ~W.indexOf(A) ? Ie(A) : function() {
                    return $o
                }
            }, b = function(A, te) {
                var N = te.s
                  , V = te.d2
                  , De = te.d
                  , Ke = te.a;
                return Math.max(0, (N = "scroll" + V) && (Ke = ge(A, N)) ? Ke() - Ie(A)()[De] : ne(A) ? (I[N] || $[N]) - le(V) : A[N] - A["offset" + V])
            }, T = function(A, te) {
                for (var N = 0; N < Lt.length; N += 3)
                    (!te || ~te.indexOf(Lt[N + 1])) && A(Lt[N], Lt[N + 1], Lt[N + 2])
            }, M = function(A) {
                return typeof A == "string"
            }, H = function(A) {
                return typeof A == "function"
            }, G = function(A) {
                return typeof A == "number"
            }, ce = function(A) {
                return typeof A == "object"
            }, we = function(A, te, N) {
                return A && A.progress(te ? 0 : 1) && N && A.pause()
            }, xe = function(A, te) {
                if (A.enabled) {
                    var N = A._ctx ? A._ctx.add(function() {
                        return te(A)
                    }) : te(A);
                    N && N.totalTime && (A.callbackAnimation = N)
                }
            }, oe = Math.abs, We = "left", me = "top", Qe = "right", tt = "bottom", dt = "width", pt = "height", jt = "Right", Nt = "Left", Pt = "Top", Bt = "Bottom", $t = "padding", nn = "margin", Zt = "Width", Yt = "Height", ln = "px", pn = function(A) {
                return Se.getComputedStyle(A)
            }, Vr = function(A) {
                var te = pn(A).position;
                A.style.position = te === "absolute" || te === "fixed" ? te : "relative"
            }, ur = function(A, te) {
                for (var N in te)
                    N in A || (A[N] = te[N]);
                return A
            }, br = function(A, te) {
                var N = te && pn(A)[wt] !== "matrix(1, 0, 0, 1, 0, 0)" && ae.to(A, {
                    x: 0,
                    y: 0,
                    xPercent: 0,
                    yPercent: 0,
                    rotation: 0,
                    rotationX: 0,
                    rotationY: 0,
                    scale: 1,
                    skewX: 0,
                    skewY: 0
                }).progress(1)
                  , V = A.getBoundingClientRect();
                return N && N.progress(0).kill(),
                V
            }, wr = function(A, te) {
                var N = te.d2;
                return A["offset" + N] || A["client" + N] || 0
            }, Pr = function(A) {
                var te = [], N = A.labels, V = A.duration(), De;
                for (De in N)
                    te.push(N[De] / V);
                return te
            }, cr = function(A) {
                return function(te) {
                    return ae.utils.snap(Pr(A), te)
                }
            }, fr = function(A) {
                var te = ae.utils.snap(A)
                  , N = Array.isArray(A) && A.slice(0).sort(function(V, De) {
                    return V - De
                });
                return N ? function(V, De, Ke) {
                    Ke === void 0 && (Ke = .001);
                    var Be;
                    if (!De)
                        return te(V);
                    if (De > 0) {
                        for (V -= Ke,
                        Be = 0; Be < N.length; Be++)
                            if (N[Be] >= V)
                                return N[Be];
                        return N[Be - 1]
                    } else
                        for (Be = N.length,
                        V += Ke; Be--; )
                            if (N[Be] <= V)
                                return N[Be];
                    return N[0]
                }
                : function(V, De, Ke) {
                    Ke === void 0 && (Ke = .001);
                    var Be = te(V);
                    return !De || Math.abs(Be - V) < Ke || Be - V < 0 == De < 0 ? Be : te(De < 0 ? V - A : V + A)
                }
            }, qn = function(A) {
                return function(te, N) {
                    return fr(Pr(A))(te, N.direction)
                }
            }, $n = function(A, te, N, V) {
                return N.split(",").forEach(function(De) {
                    return A(te, De, V)
                })
            }, Xn = function(A, te, N, V, De) {
                return A.addEventListener(te, N, {
                    passive: !V,
                    capture: !!De
                })
            }, en = function(A, te, N, V) {
                return A.removeEventListener(te, N, !!V)
            }, Mr = function(A, te, N) {
                N = N && N.wheelHandler,
                N && (A(te, "wheel", N),
                A(te, "touchmove", N))
            }, hi = {
                startColor: "green",
                endColor: "red",
                indent: 0,
                fontSize: "16px",
                fontWeight: "normal"
            }, _r = {
                toggleActions: "play",
                anticipatePin: 0
            }, Fi = {
                top: 0,
                left: 0,
                center: .5,
                bottom: 1,
                right: 1
            }, Gn = function(A, te) {
                if (M(A)) {
                    var N = A.indexOf("=")
                      , V = ~N ? +(A.charAt(N - 1) + 1) * parseFloat(A.substr(N + 1)) : 0;
                    ~N && (A.indexOf("%") > N && (V *= te / 100),
                    A = A.substr(0, N - 1)),
                    A = V + (A in Fi ? Fi[A] * te : ~A.indexOf("%") ? parseFloat(A) * te / 100 : parseFloat(A) || 0)
                }
                return A
            }, Qn = function(A, te, N, V, De, Ke, Be, Wt) {
                var cn = De.startColor
                  , wn = De.endColor
                  , Rn = De.fontSize
                  , on = De.indent
                  , _t = De.fontWeight
                  , un = Je.createElement("div")
                  , Lr = ne(N) || ge(N, "pinType") === "fixed"
                  , dr = A.indexOf("scroller") !== -1
                  , Zr = Lr ? $ : N
                  , kr = A.indexOf("start") !== -1
                  , gi = kr ? cn : wn
                  , Sn = "border-color:" + gi + ";font-size:" + Rn + ";color:" + gi + ";font-weight:" + _t + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                return Sn += "position:" + ((dr || Wt) && Lr ? "fixed;" : "absolute;"),
                (dr || Wt || !Lr) && (Sn += (V === ye ? Qe : tt) + ":" + (Ke + parseFloat(on)) + "px;"),
                Be && (Sn += "box-sizing:border-box;text-align:left;width:" + Be.offsetWidth + "px;"),
                un._isStart = kr,
                un.setAttribute("class", "gsap-marker-" + A + (te ? " marker-" + te : "")),
                un.style.cssText = Sn,
                un.innerText = te || te === 0 ? A + "-" + te : A,
                Zr.children[0] ? Zr.insertBefore(un, Zr.children[0]) : Zr.appendChild(un),
                un._offset = un["offset" + V.op.d2],
                Os(un, 0, V, kr),
                un
            }, Os = function(A, te, N, V) {
                var De = {
                    display: "block"
                }
                  , Ke = N[V ? "os2" : "p2"]
                  , Be = N[V ? "p2" : "os2"];
                A._isFlipped = V,
                De[N.a + "Percent"] = V ? -100 : 0,
                De[N.a] = V ? "1px" : 0,
                De["border" + Ke + Zt] = 1,
                De["border" + Be + Zt] = 0,
                De[N.p] = te + "px",
                ae.set(A, De)
            }, gn = [], Jr = {}, Pn, Ms = function() {
                return je() - ot > 34 && (Pn || (Pn = requestAnimationFrame(hs)))
            }, bn = function() {
                (!hn || !hn.isPressed || hn.startX > $.clientWidth) && (S.cache++,
                hn ? Pn || (Pn = requestAnimationFrame(hs)) : hs(),
                ot || Ys("scrollStart"),
                ot = je())
            }, xn = function() {
                lr = Se.innerWidth,
                Kn = Se.innerHeight
            }, Gs = function(A) {
                S.cache++,
                (A === !0 || !Ue && !Fn && !Je.fullscreenElement && !Je.webkitFullscreenElement && (!Ln || lr !== Se.innerWidth || Math.abs(Se.innerHeight - Kn) > Se.innerHeight * .25)) && Me.restart(!0)
            }, lo = {}, mf = [], Nu = function Pe() {
                return en(kn, "scrollEnd", Pe) || Is(!0)
            }, Ys = function(A) {
                return lo[A] && lo[A].map(function(te) {
                    return te()
                }) || mf
            }, Ii = [], Ks = function(A) {
                for (var te = 0; te < Ii.length; te += 5)
                    (!A || Ii[te + 4] && Ii[te + 4].query === A) && (Ii[te].style.cssText = Ii[te + 1],
                    Ii[te].getBBox && Ii[te].setAttribute("transform", Ii[te + 2] || ""),
                    Ii[te + 3].uncache = 1)
            }, Ls = function(A, te) {
                var N;
                for (rt = 0; rt < gn.length; rt++)
                    N = gn[rt],
                    N && (!te || N._ctx === te) && (A ? N.kill(1) : N.revert(!0, !0));
                Fe = !0,
                te && Ks(te),
                te || Ys("revert")
            }, El = function(A, te) {
                S.cache++,
                (te || !pi) && S.forEach(function(N) {
                    return H(N) && N.cacheID++ && (N.rec = 0)
                }),
                M(A) && (Se.history.scrollRestoration = ie = A)
            }, pi, Fs = 0, Cl, ca = function() {
                if (Cl !== Fs) {
                    var A = Cl = Fs;
                    requestAnimationFrame(function() {
                        return A === Fs && Is(!0)
                    })
                }
            }, oi = function() {
                $.appendChild(_e),
                ke = !hn && _e.offsetHeight || Se.innerHeight,
                $.removeChild(_e)
            }, $u = function(A) {
                return Te(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(te) {
                    return te.style.display = A ? "none" : "block"
                })
            }, Is = function(A, te) {
                if (I = Je.documentElement,
                $ = Je.body,
                de = [Se, Je, I, $],
                ot && !A && !Fe) {
                    Xn(kn, "scrollEnd", Nu);
                    return
                }
                oi(),
                pi = kn.isRefreshing = !0,
                S.forEach(function(V) {
                    return H(V) && ++V.cacheID && (V.rec = V())
                });
                var N = Ys("refreshInit");
                Jt && kn.sort(),
                te || Ls(),
                S.forEach(function(V) {
                    H(V) && (V.smooth && (V.target.style.scrollBehavior = "auto"),
                    V(0))
                }),
                gn.slice(0).forEach(function(V) {
                    return V.refresh()
                }),
                Fe = !1,
                gn.forEach(function(V) {
                    if (V._subPinOffset && V.pin) {
                        var De = V.vars.horizontal ? "offsetWidth" : "offsetHeight"
                          , Ke = V.pin[De];
                        V.revert(!0, 1),
                        V.adjustPinSpacing(V.pin[De] - Ke),
                        V.refresh()
                    }
                }),
                Ce = 1,
                $u(!0),
                gn.forEach(function(V) {
                    var De = b(V.scroller, V._dir)
                      , Ke = V.vars.end === "max" || V._endClamp && V.end > De
                      , Be = V._startClamp && V.start >= De;
                    (Ke || Be) && V.setPositions(Be ? De - 1 : V.start, Ke ? Math.max(Be ? De : V.start + 1, De) : V.end, !0)
                }),
                $u(!1),
                Ce = 0,
                N.forEach(function(V) {
                    return V && V.render && V.render(-1)
                }),
                S.forEach(function(V) {
                    H(V) && (V.smooth && requestAnimationFrame(function() {
                        return V.target.style.scrollBehavior = "smooth"
                    }),
                    V.rec && V(V.rec))
                }),
                El(ie, 1),
                Me.pause(),
                Fs++,
                pi = 2,
                hs(2),
                gn.forEach(function(V) {
                    return H(V.vars.onRefresh) && V.vars.onRefresh(V)
                }),
                pi = kn.isRefreshing = !1,
                Ys("refresh")
            }, xl = 0, fa = 1, is, hs = function(A) {
                if (A === 2 || !pi && !Fe) {
                    kn.isUpdating = !0,
                    is && is.update(0);
                    var te = gn.length
                      , N = je()
                      , V = N - vt >= 50
                      , De = te && gn[0].scroll();
                    if (fa = xl > De ? -1 : 1,
                    pi || (xl = De),
                    V && (ot && !Ge && N - ot > 200 && (ot = 0,
                    Ys("scrollEnd")),
                    lt = vt,
                    vt = N),
                    fa < 0) {
                        for (rt = te; rt-- > 0; )
                            gn[rt] && gn[rt].update(0, V);
                        fa = 1
                    } else
                        for (rt = 0; rt < te; rt++)
                            gn[rt] && gn[rt].update(0, V);
                    kn.isUpdating = !1
                }
                Pn = 0
            }, da = [We, me, tt, Qe, nn + Bt, nn + jt, nn + Pt, nn + Nt, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], $a = da.concat([dt, pt, "boxSizing", "max" + Zt, "max" + Yt, "position", nn, $t, $t + Pt, $t + jt, $t + Bt, $t + Nt]), yf = function(A, te, N) {
                uo(N);
                var V = A._gsap;
                if (V.spacerIsNative)
                    uo(V.spacerState);
                else if (A._gsap.swappedIn) {
                    var De = te.parentNode;
                    De && (De.insertBefore(A, te),
                    De.removeChild(te))
                }
                A._gsap.swappedIn = !1
            }, Sl = function(A, te, N, V) {
                if (!A._gsap.swappedIn) {
                    for (var De = da.length, Ke = te.style, Be = A.style, Wt; De--; )
                        Wt = da[De],
                        Ke[Wt] = N[Wt];
                    Ke.position = N.position === "absolute" ? "absolute" : "relative",
                    N.display === "inline" && (Ke.display = "inline-block"),
                    Be[tt] = Be[Qe] = "auto",
                    Ke.flexBasis = N.flexBasis || "auto",
                    Ke.overflow = "visible",
                    Ke.boxSizing = "border-box",
                    Ke[dt] = wr(A, se) + ln,
                    Ke[pt] = wr(A, ye) + ln,
                    Ke[$t] = Be[nn] = Be[me] = Be[We] = "0",
                    uo(V),
                    Be[dt] = Be["max" + Zt] = N[dt],
                    Be[pt] = Be["max" + Yt] = N[pt],
                    Be[$t] = N[$t],
                    A.parentNode !== te && (A.parentNode.insertBefore(te, A),
                    te.appendChild(A)),
                    A._gsap.swappedIn = !0
                }
            }, ha = /([A-Z])/g, uo = function(A) {
                if (A) {
                    var te = A.t.style, N = A.length, V = 0, De, Ke;
                    for ((A.t._gsap || ae.core.getCache(A.t)).uncache = 1; V < N; V += 2)
                        Ke = A[V + 1],
                        De = A[V],
                        Ke ? te[De] = Ke : te[De] && te.removeProperty(De.replace(ha, "-$1").toLowerCase())
                }
            }, pa = function(A) {
                for (var te = $a.length, N = A.style, V = [], De = 0; De < te; De++)
                    V.push($a[De], N[$a[De]]);
                return V.t = A,
                V
            }, jr = function(A, te, N) {
                for (var V = [], De = A.length, Ke = N ? 8 : 0, Be; Ke < De; Ke += 2)
                    Be = A[Ke],
                    V.push(Be, Be in te ? te[Be] : A[Ke + 1]);
                return V.t = A.t,
                V
            }, $o = {
                left: 0,
                top: 0
            }, Tl = function(A, te, N, V, De, Ke, Be, Wt, cn, wn, Rn, on, _t, un) {
                H(A) && (A = A(Wt)),
                M(A) && A.substr(0, 3) === "max" && (A = on + (A.charAt(4) === "=" ? Gn("0" + A.substr(3), N) : 0));
                var Lr = _t ? _t.time() : 0, dr, Zr, kr;
                if (_t && _t.seek(0),
                isNaN(A) || (A = +A),
                G(A))
                    _t && (A = ae.utils.mapRange(_t.scrollTrigger.start, _t.scrollTrigger.end, 0, on, A)),
                    Be && Os(Be, N, V, !0);
                else {
                    H(te) && (te = te(Wt));
                    var gi = (A || "0").split(" "), Sn, ss, Dr, mn;
                    kr = Ze(te, Wt) || $,
                    Sn = br(kr) || {},
                    (!Sn || !Sn.left && !Sn.top) && pn(kr).display === "none" && (mn = kr.style.display,
                    kr.style.display = "block",
                    Sn = br(kr),
                    mn ? kr.style.display = mn : kr.style.removeProperty("display")),
                    ss = Gn(gi[0], Sn[V.d]),
                    Dr = Gn(gi[1] || "0", N),
                    A = Sn[V.p] - cn[V.p] - wn + ss + De - Dr,
                    Be && Os(Be, Dr, V, N - Dr < 20 || Be._isStart && Dr > 20),
                    N -= N - Dr
                }
                if (un && (Wt[un] = A || -.001,
                A < 0 && (A = 0)),
                Ke) {
                    var Ai = A + N
                      , $i = Ke._isStart;
                    dr = "scroll" + V.d2,
                    Os(Ke, Ai, V, $i && Ai > 20 || !$i && (Rn ? Math.max($[dr], I[dr]) : Ke.parentNode[dr]) <= Ai + 1),
                    Rn && (cn = br(Be),
                    Rn && (Ke.style[V.op.p] = cn[V.op.p] - V.op.m - Ke._offset + ln))
                }
                return _t && kr && (dr = br(kr),
                _t.seek(on),
                Zr = br(kr),
                _t._caScrollDist = dr[V.p] - Zr[V.p],
                A = A / _t._caScrollDist * on),
                _t && _t.seek(Lr),
                _t ? A : Math.round(A)
            }, vf = /(webkit|moz|length|cssText|inset)/i, Bu = function(A, te, N, V) {
                if (A.parentNode !== te) {
                    var De = A.style, Ke, Be;
                    if (te === $) {
                        A._stOrig = De.cssText,
                        Be = pn(A);
                        for (Ke in Be)
                            !+Ke && !vf.test(Ke) && Be[Ke] && typeof De[Ke] == "string" && Ke !== "0" && (De[Ke] = Be[Ke]);
                        De.top = N,
                        De.left = V
                    } else
                        De.cssText = A._stOrig;
                    ae.core.getCache(A).uncache = 1,
                    te.appendChild(A)
                }
            }, Ba = function(A, te, N) {
                var V = te
                  , De = V;
                return function(Ke) {
                    var Be = Math.round(A());
                    return Be !== V && Be !== De && Math.abs(Be - V) > 3 && Math.abs(Be - De) > 3 && (Ke = Be,
                    N && N()),
                    De = V,
                    V = Math.round(Ke),
                    V
                }
            }, ga = function(A, te, N) {
                var V = {};
                V[te.p] = "+=" + N,
                ae.set(A, V)
            }, Hu = function(A, te) {
                var N = nt(A, te)
                  , V = "_scroll" + te.p2
                  , De = function Ke(Be, Wt, cn, wn, Rn) {
                    var on = Ke.tween
                      , _t = Wt.onComplete
                      , un = {};
                    cn = cn || N();
                    var Lr = Ba(N, cn, function() {
                        on.kill(),
                        Ke.tween = 0
                    });
                    return Rn = wn && Rn || 0,
                    wn = wn || Be - cn,
                    on && on.kill(),
                    Wt[V] = Be,
                    Wt.inherit = !1,
                    Wt.modifiers = un,
                    un[V] = function() {
                        return Lr(cn + wn * on.ratio + Rn * on.ratio * on.ratio)
                    }
                    ,
                    Wt.onUpdate = function() {
                        S.cache++,
                        Ke.tween && hs()
                    }
                    ,
                    Wt.onComplete = function() {
                        Ke.tween = 0,
                        _t && _t.call(on)
                    }
                    ,
                    on = Ke.tween = ae.to(A, Wt),
                    on
                };
                return A[V] = N,
                N.wheelHandler = function() {
                    return De.tween && De.tween.kill() && (De.tween = 0)
                }
                ,
                Xn(A, "wheel", N.wheelHandler),
                kn.isTouch && Xn(A, "touchmove", N.wheelHandler),
                De
            }, kn = function() {
                function Pe(te, N) {
                    ze || Pe.register(ae) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
                    X(this),
                    this.init(te, N)
                }
                var A = Pe.prototype;
                return A.init = function(N, V) {
                    if (this.progress = this.start = 0,
                    this.vars && this.kill(!0, !0),
                    !Ve) {
                        this.update = this.refresh = this.kill = Oe;
                        return
                    }
                    N = ur(M(N) || G(N) || N.nodeType ? {
                        trigger: N
                    } : N, _r);
                    var De = N, Ke = De.onUpdate, Be = De.toggleClass, Wt = De.id, cn = De.onToggle, wn = De.onRefresh, Rn = De.scrub, on = De.trigger, _t = De.pin, un = De.pinSpacing, Lr = De.invalidateOnRefresh, dr = De.anticipatePin, Zr = De.onScrubComplete, kr = De.onSnapComplete, gi = De.once, Sn = De.snap, ss = De.pinReparent, Dr = De.pinSpacer, mn = De.containerAnimation, Ai = De.fastScrollEnd, $i = De.preventOverlaps, rn = N.horizontal || N.containerAnimation && N.horizontal !== !1 ? se : ye, ai = !Rn && Rn !== 0, _n = Ze(N.scroller || Se), vs = ae.core.getCache(_n), hr = ne(_n), Yr = ("pinType"in N ? N.pinType : ge(_n, "pinType") || hr && "fixed") === "fixed", _i = [N.onEnter, N.onLeave, N.onEnterBack, N.onLeaveBack], Bn = ai && N.toggleActions.split(" "), zr = "markers"in N ? N.markers : _r.markers, Fr = hr ? 0 : parseFloat(pn(_n)["border" + rn.p2 + Zt]) || 0, Ae = this, or = N.onRefreshInit && function() {
                        return N.onRefreshInit(Ae)
                    }
                    , Wi = ct(_n, hr, rn), qi = F(_n, hr), mi = 0, bs = 0, li = 0, Kr = nt(_n, rn), Ri, mr, ws, Oi, Bi, Hn, Ir, Mi, Gi, Xe, Yi, Ns, Qs, Nr, Yn, Ur, co, ei, Js, $r, os, Hi, Xr, Bo, yr, Ho, Ds, fo, ho, $s, Ki, Dn, Zs, ps, ui, ti, po, go, Bs;
                    if (Ae._startClamp = Ae._endClamp = !1,
                    Ae._dir = rn,
                    dr *= 45,
                    Ae.scroller = _n,
                    Ae.scroll = mn ? mn.time.bind(mn) : Kr,
                    Oi = Kr(),
                    Ae.vars = N,
                    V = V || N.animation,
                    "refreshPriority"in N && (Jt = 1,
                    N.refreshPriority === -9999 && (is = Ae)),
                    vs.tweenScroll = vs.tweenScroll || {
                        top: Hu(_n, ye),
                        left: Hu(_n, se)
                    },
                    Ae.tweenTo = Ri = vs.tweenScroll[rn.p],
                    Ae.scrubDuration = function(Ht) {
                        Zs = G(Ht) && Ht,
                        Zs ? Dn ? Dn.duration(Ht) : Dn = ae.to(V, {
                            ease: "expo",
                            totalProgress: "+=0",
                            inherit: !1,
                            duration: Zs,
                            paused: !0,
                            onComplete: function() {
                                return Zr && Zr(Ae)
                            }
                        }) : (Dn && Dn.progress(1).kill(),
                        Dn = 0)
                    }
                    ,
                    V && (V.vars.lazy = !1,
                    V._initted && !Ae.isReverted || V.vars.immediateRender !== !1 && N.immediateRender !== !1 && V.duration() && V.render(0, !0, !0),
                    Ae.animation = V.pause(),
                    V.scrollTrigger = Ae,
                    Ae.scrubDuration(Rn),
                    $s = 0,
                    Wt || (Wt = V.vars.id)),
                    Sn && ((!ce(Sn) || Sn.push) && (Sn = {
                        snapTo: Sn
                    }),
                    "scrollBehavior"in $.style && ae.set(hr ? [$, I] : _n, {
                        scrollBehavior: "auto"
                    }),
                    S.forEach(function(Ht) {
                        return H(Ht) && Ht.target === (hr ? Je.scrollingElement || I : _n) && (Ht.smooth = !1)
                    }),
                    ws = H(Sn.snapTo) ? Sn.snapTo : Sn.snapTo === "labels" ? cr(V) : Sn.snapTo === "labelsDirectional" ? qn(V) : Sn.directional !== !1 ? function(Ht, En) {
                        return fr(Sn.snapTo)(Ht, je() - bs < 500 ? 0 : En.direction)
                    }
                    : ae.utils.snap(Sn.snapTo),
                    ps = Sn.duration || {
                        min: .1,
                        max: 2
                    },
                    ps = ce(ps) ? Ne(ps.min, ps.max) : Ne(ps, ps),
                    ui = ae.delayedCall(Sn.delay || Zs / 2 || .1, function() {
                        var Ht = Kr()
                          , En = je() - bs < 500
                          , sn = Ri.tween;
                        if ((En || Math.abs(Ae.getVelocity()) < 10) && !sn && !Ge && mi !== Ht) {
                            var vn = (Ht - Hn) / Nr, Br = V && !ai ? V.totalProgress() : vn, An = En ? 0 : (Br - Ki) / (je() - lt) * 1e3 || 0, Ar = ae.utils.clamp(-vn, 1 - vn, oe(An / 2) * An / .185), Si = vn + (Sn.inertia === !1 ? 0 : Ar), nr, rr, Vn = Sn, as = Vn.onStart, Rr = Vn.onInterrupt, Xi = Vn.onComplete;
                            if (nr = ws(Si, Ae),
                            G(nr) || (nr = Si),
                            rr = Math.max(0, Math.round(Hn + nr * Nr)),
                            Ht <= Ir && Ht >= Hn && rr !== Ht) {
                                if (sn && !sn._initted && sn.data <= oe(rr - Ht))
                                    return;
                                Sn.inertia === !1 && (Ar = nr - vn),
                                Ri(rr, {
                                    duration: ps(oe(Math.max(oe(Si - Br), oe(nr - Br)) * .185 / An / .05 || 0)),
                                    ease: Sn.ease || "power3",
                                    data: oe(rr - Ht),
                                    onInterrupt: function() {
                                        return ui.restart(!0) && Rr && Rr(Ae)
                                    },
                                    onComplete: function() {
                                        Ae.update(),
                                        mi = Kr(),
                                        V && !ai && (Dn ? Dn.resetTo("totalProgress", nr, V._tTime / V._tDur) : V.progress(nr)),
                                        $s = Ki = V && !ai ? V.totalProgress() : Ae.progress,
                                        kr && kr(Ae),
                                        Xi && Xi(Ae)
                                    }
                                }, Ht, Ar * Nr, rr - Ht - Ar * Nr),
                                as && as(Ae, Ri.tween)
                            }
                        } else
                            Ae.isActive && mi !== Ht && ui.restart(!0)
                    }).pause()),
                    Wt && (Jr[Wt] = Ae),
                    on = Ae.trigger = Ze(on || _t !== !0 && _t),
                    Bs = on && on._gsap && on._gsap.stRevert,
                    Bs && (Bs = Bs(Ae)),
                    _t = _t === !0 ? on : Ze(_t),
                    M(Be) && (Be = {
                        targets: on,
                        className: Be
                    }),
                    _t && (un === !1 || un === nn || (un = !un && _t.parentNode && _t.parentNode.style && pn(_t.parentNode).display === "flex" ? !1 : $t),
                    Ae.pin = _t,
                    mr = ae.core.getCache(_t),
                    mr.spacer ? Yn = mr.pinState : (Dr && (Dr = Ze(Dr),
                    Dr && !Dr.nodeType && (Dr = Dr.current || Dr.nativeElement),
                    mr.spacerIsNative = !!Dr,
                    Dr && (mr.spacerState = pa(Dr))),
                    mr.spacer = ei = Dr || Je.createElement("div"),
                    ei.classList.add("pin-spacer"),
                    Wt && ei.classList.add("pin-spacer-" + Wt),
                    mr.pinState = Yn = pa(_t)),
                    N.force3D !== !1 && ae.set(_t, {
                        force3D: !0
                    }),
                    Ae.spacer = ei = mr.spacer,
                    ho = pn(_t),
                    Bo = ho[un + rn.os2],
                    $r = ae.getProperty(_t),
                    os = ae.quickSetter(_t, rn.a, ln),
                    Sl(_t, ei, ho),
                    co = pa(_t)),
                    zr) {
                        Ns = ce(zr) ? ur(zr, hi) : hi,
                        Xe = Qn("scroller-start", Wt, _n, rn, Ns, 0),
                        Yi = Qn("scroller-end", Wt, _n, rn, Ns, 0, Xe),
                        Js = Xe["offset" + rn.op.d2];
                        var ma = Ze(ge(_n, "content") || _n);
                        Mi = this.markerStart = Qn("start", Wt, ma, rn, Ns, Js, 0, mn),
                        Gi = this.markerEnd = Qn("end", Wt, ma, rn, Ns, Js, 0, mn),
                        mn && (go = ae.quickSetter([Mi, Gi], rn.a, ln)),
                        !Yr && !(W.length && ge(_n, "fixedMarkers") === !0) && (Vr(hr ? $ : _n),
                        ae.set([Xe, Yi], {
                            force3D: !0
                        }),
                        Ho = ae.quickSetter(Xe, rn.a, ln),
                        fo = ae.quickSetter(Yi, rn.a, ln))
                    }
                    if (mn) {
                        var yn = mn.vars.onUpdate
                          , an = mn.vars.onUpdateParams;
                        mn.eventCallback("onUpdate", function() {
                            Ae.update(0, 0, 1),
                            yn && yn.apply(mn, an || [])
                        })
                    }
                    if (Ae.previous = function() {
                        return gn[gn.indexOf(Ae) - 1]
                    }
                    ,
                    Ae.next = function() {
                        return gn[gn.indexOf(Ae) + 1]
                    }
                    ,
                    Ae.revert = function(Ht, En) {
                        if (!En)
                            return Ae.kill(!0);
                        var sn = Ht !== !1 || !Ae.enabled
                          , vn = Ue;
                        sn !== Ae.isReverted && (sn && (ti = Math.max(Kr(), Ae.scroll.rec || 0),
                        li = Ae.progress,
                        po = V && V.progress()),
                        Mi && [Mi, Gi, Xe, Yi].forEach(function(Br) {
                            return Br.style.display = sn ? "none" : "block"
                        }),
                        sn && (Ue = Ae,
                        Ae.update(sn)),
                        _t && (!ss || !Ae.isActive) && (sn ? yf(_t, ei, Yn) : Sl(_t, ei, pn(_t), yr)),
                        sn || Ae.update(sn),
                        Ue = vn,
                        Ae.isReverted = sn)
                    }
                    ,
                    Ae.refresh = function(Ht, En, sn, vn) {
                        if (!((Ue || !Ae.enabled) && !En)) {
                            if (_t && Ht && ot) {
                                Xn(Pe, "scrollEnd", Nu);
                                return
                            }
                            !pi && or && or(Ae),
                            Ue = Ae,
                            Ri.tween && !sn && (Ri.tween.kill(),
                            Ri.tween = 0),
                            Dn && Dn.pause(),
                            Lr && V && (V.revert({
                                kill: !1
                            }).invalidate(),
                            V.getChildren && V.getChildren(!0, !0, !1).forEach(function(q) {
                                return q.vars.immediateRender && q.render(0, !0, !0)
                            })),
                            Ae.isReverted || Ae.revert(!0, !0),
                            Ae._subPinOffset = !1;
                            var Br = Wi(), An = qi(), Ar = mn ? mn.duration() : b(_n, rn), Si = Nr <= .01 || !Nr, nr = 0, rr = vn || 0, Vn = ce(sn) ? sn.end : N.end, as = N.endTrigger || on, Rr = ce(sn) ? sn.start : N.start || (N.start === 0 || !on ? 0 : _t ? "0 0" : "0 100%"), Xi = Ae.pinnedContainer = N.pinnedContainer && Ze(N.pinnedContainer, Ae), gs = on && Math.max(0, gn.indexOf(Ae)) || 0, yi = gs, ni, ci, _o, j, a, c, f, d, _, D, C, B, U;
                            for (zr && ce(sn) && (B = ae.getProperty(Xe, rn.p),
                            U = ae.getProperty(Yi, rn.p)); yi-- > 0; )
                                c = gn[yi],
                                c.end || c.refresh(0, 1) || (Ue = Ae),
                                f = c.pin,
                                f && (f === on || f === _t || f === Xi) && !c.isReverted && (D || (D = []),
                                D.unshift(c),
                                c.revert(!0, !0)),
                                c !== gn[yi] && (gs--,
                                yi--);
                            for (H(Rr) && (Rr = Rr(Ae)),
                            Rr = ut(Rr, "start", Ae),
                            Hn = Tl(Rr, on, Br, rn, Kr(), Mi, Xe, Ae, An, Fr, Yr, Ar, mn, Ae._startClamp && "_startClamp") || (_t ? -.001 : 0),
                            H(Vn) && (Vn = Vn(Ae)),
                            M(Vn) && !Vn.indexOf("+=") && (~Vn.indexOf(" ") ? Vn = (M(Rr) ? Rr.split(" ")[0] : "") + Vn : (nr = Gn(Vn.substr(2), Br),
                            Vn = M(Rr) ? Rr : (mn ? ae.utils.mapRange(0, mn.duration(), mn.scrollTrigger.start, mn.scrollTrigger.end, Hn) : Hn) + nr,
                            as = on)),
                            Vn = ut(Vn, "end", Ae),
                            Ir = Math.max(Hn, Tl(Vn || (as ? "100% 0" : Ar), as, Br, rn, Kr() + nr, Gi, Yi, Ae, An, Fr, Yr, Ar, mn, Ae._endClamp && "_endClamp")) || -.001,
                            nr = 0,
                            yi = gs; yi--; )
                                c = gn[yi],
                                f = c.pin,
                                f && c.start - c._pinPush <= Hn && !mn && c.end > 0 && (ni = c.end - (Ae._startClamp ? Math.max(0, c.start) : c.start),
                                (f === on && c.start - c._pinPush < Hn || f === Xi) && isNaN(Rr) && (nr += ni * (1 - c.progress)),
                                f === _t && (rr += ni));
                            if (Hn += nr,
                            Ir += nr,
                            Ae._startClamp && (Ae._startClamp += nr),
                            Ae._endClamp && !pi && (Ae._endClamp = Ir || -.001,
                            Ir = Math.min(Ir, b(_n, rn))),
                            Nr = Ir - Hn || (Hn -= .01) && .001,
                            Si && (li = ae.utils.clamp(0, 1, ae.utils.normalize(Hn, Ir, ti))),
                            Ae._pinPush = rr,
                            Mi && nr && (ni = {},
                            ni[rn.a] = "+=" + nr,
                            Xi && (ni[rn.p] = "-=" + Kr()),
                            ae.set([Mi, Gi], ni)),
                            _t && !(Ce && Ae.end >= b(_n, rn)))
                                ni = pn(_t),
                                j = rn === ye,
                                _o = Kr(),
                                Hi = parseFloat($r(rn.a)) + rr,
                                !Ar && Ir > 1 && (C = (hr ? Je.scrollingElement || I : _n).style,
                                C = {
                                    style: C,
                                    value: C["overflow" + rn.a.toUpperCase()]
                                },
                                hr && pn($)["overflow" + rn.a.toUpperCase()] !== "scroll" && (C.style["overflow" + rn.a.toUpperCase()] = "scroll")),
                                Sl(_t, ei, ni),
                                co = pa(_t),
                                ci = br(_t, !0),
                                d = Yr && nt(_n, j ? se : ye)(),
                                un ? (yr = [un + rn.os2, Nr + rr + ln],
                                yr.t = ei,
                                yi = un === $t ? wr(_t, rn) + Nr + rr : 0,
                                yi && (yr.push(rn.d, yi + ln),
                                ei.style.flexBasis !== "auto" && (ei.style.flexBasis = yi + ln)),
                                uo(yr),
                                Xi && gn.forEach(function(q) {
                                    q.pin === Xi && q.vars.pinSpacing !== !1 && (q._subPinOffset = !0)
                                }),
                                Yr && Kr(ti)) : (yi = wr(_t, rn),
                                yi && ei.style.flexBasis !== "auto" && (ei.style.flexBasis = yi + ln)),
                                Yr && (a = {
                                    top: ci.top + (j ? _o - Hn : d) + ln,
                                    left: ci.left + (j ? d : _o - Hn) + ln,
                                    boxSizing: "border-box",
                                    position: "fixed"
                                },
                                a[dt] = a["max" + Zt] = Math.ceil(ci.width) + ln,
                                a[pt] = a["max" + Yt] = Math.ceil(ci.height) + ln,
                                a[nn] = a[nn + Pt] = a[nn + jt] = a[nn + Bt] = a[nn + Nt] = "0",
                                a[$t] = ni[$t],
                                a[$t + Pt] = ni[$t + Pt],
                                a[$t + jt] = ni[$t + jt],
                                a[$t + Bt] = ni[$t + Bt],
                                a[$t + Nt] = ni[$t + Nt],
                                Ur = jr(Yn, a, ss),
                                pi && Kr(0)),
                                V ? (_ = V._initted,
                                fn(1),
                                V.render(V.duration(), !0, !0),
                                Xr = $r(rn.a) - Hi + Nr + rr,
                                Ds = Math.abs(Nr - Xr) > 1,
                                Yr && Ds && Ur.splice(Ur.length - 2, 2),
                                V.render(0, !0, !0),
                                _ || V.invalidate(!0),
                                V.parent || V.totalTime(V.totalTime()),
                                fn(0)) : Xr = Nr,
                                C && (C.value ? C.style["overflow" + rn.a.toUpperCase()] = C.value : C.style.removeProperty("overflow-" + rn.a));
                            else if (on && Kr() && !mn)
                                for (ci = on.parentNode; ci && ci !== $; )
                                    ci._pinOffset && (Hn -= ci._pinOffset,
                                    Ir -= ci._pinOffset),
                                    ci = ci.parentNode;
                            D && D.forEach(function(q) {
                                return q.revert(!1, !0)
                            }),
                            Ae.start = Hn,
                            Ae.end = Ir,
                            Oi = Bi = pi ? ti : Kr(),
                            !mn && !pi && (Oi < ti && Kr(ti),
                            Ae.scroll.rec = 0),
                            Ae.revert(!1, !0),
                            bs = je(),
                            ui && (mi = -1,
                            ui.restart(!0)),
                            Ue = 0,
                            V && ai && (V._initted || po) && V.progress() !== po && V.progress(po || 0, !0).render(V.time(), !0, !0),
                            (Si || li !== Ae.progress || mn || Lr || V && !V._initted) && (V && !ai && (V._initted || li || V.vars.immediateRender !== !1) && V.totalProgress(mn && Hn < -.001 && !li ? ae.utils.normalize(Hn, Ir, 0) : li, !0),
                            Ae.progress = Si || (Oi - Hn) / Nr === li ? 0 : li),
                            _t && un && (ei._pinOffset = Math.round(Ae.progress * Xr)),
                            Dn && Dn.invalidate(),
                            isNaN(B) || (B -= ae.getProperty(Xe, rn.p),
                            U -= ae.getProperty(Yi, rn.p),
                            ga(Xe, rn, B),
                            ga(Mi, rn, B - (vn || 0)),
                            ga(Yi, rn, U),
                            ga(Gi, rn, U - (vn || 0))),
                            Si && !pi && Ae.update(),
                            wn && !pi && !Qs && (Qs = !0,
                            wn(Ae),
                            Qs = !1)
                        }
                    }
                    ,
                    Ae.getVelocity = function() {
                        return (Kr() - Bi) / (je() - lt) * 1e3 || 0
                    }
                    ,
                    Ae.endAnimation = function() {
                        we(Ae.callbackAnimation),
                        V && (Dn ? Dn.progress(1) : V.paused() ? ai || we(V, Ae.direction < 0, 1) : we(V, V.reversed()))
                    }
                    ,
                    Ae.labelToScroll = function(Ht) {
                        return V && V.labels && (Hn || Ae.refresh() || Hn) + V.labels[Ht] / V.duration() * Nr || 0
                    }
                    ,
                    Ae.getTrailing = function(Ht) {
                        var En = gn.indexOf(Ae)
                          , sn = Ae.direction > 0 ? gn.slice(0, En).reverse() : gn.slice(En + 1);
                        return (M(Ht) ? sn.filter(function(vn) {
                            return vn.vars.preventOverlaps === Ht
                        }) : sn).filter(function(vn) {
                            return Ae.direction > 0 ? vn.end <= Hn : vn.start >= Ir
                        })
                    }
                    ,
                    Ae.update = function(Ht, En, sn) {
                        if (!(mn && !sn && !Ht)) {
                            var vn = pi === !0 ? ti : Ae.scroll(), Br = Ht ? 0 : (vn - Hn) / Nr, An = Br < 0 ? 0 : Br > 1 ? 1 : Br || 0, Ar = Ae.progress, Si, nr, rr, Vn, as, Rr, Xi, gs;
                            if (En && (Bi = Oi,
                            Oi = mn ? Kr() : vn,
                            Sn && (Ki = $s,
                            $s = V && !ai ? V.totalProgress() : An)),
                            dr && _t && !Ue && !Ye && ot && (!An && Hn < vn + (vn - Bi) / (je() - lt) * dr ? An = 1e-4 : An === 1 && Ir > vn + (vn - Bi) / (je() - lt) * dr && (An = .9999)),
                            An !== Ar && Ae.enabled) {
                                if (Si = Ae.isActive = !!An && An < 1,
                                nr = !!Ar && Ar < 1,
                                Rr = Si !== nr,
                                as = Rr || !!An != !!Ar,
                                Ae.direction = An > Ar ? 1 : -1,
                                Ae.progress = An,
                                as && !Ue && (rr = An && !Ar ? 0 : An === 1 ? 1 : Ar === 1 ? 2 : 3,
                                ai && (Vn = !Rr && Bn[rr + 1] !== "none" && Bn[rr + 1] || Bn[rr],
                                gs = V && (Vn === "complete" || Vn === "reset" || Vn in V))),
                                $i && (Rr || gs) && (gs || Rn || !V) && (H($i) ? $i(Ae) : Ae.getTrailing($i).forEach(function(_o) {
                                    return _o.endAnimation()
                                })),
                                ai || (Dn && !Ue && !Ye ? (Dn._dp._time - Dn._start !== Dn._time && Dn.render(Dn._dp._time - Dn._start),
                                Dn.resetTo ? Dn.resetTo("totalProgress", An, V._tTime / V._tDur) : (Dn.vars.totalProgress = An,
                                Dn.invalidate().restart())) : V && V.totalProgress(An, !!(Ue && (bs || Ht)))),
                                _t) {
                                    if (Ht && un && (ei.style[un + rn.os2] = Bo),
                                    !Yr)
                                        os(O(Hi + Xr * An));
                                    else if (as) {
                                        if (Xi = !Ht && An > Ar && Ir + 1 > vn && vn + 1 >= b(_n, rn),
                                        ss)
                                            if (!Ht && (Si || Xi)) {
                                                var yi = br(_t, !0)
                                                  , ni = vn - Hn;
                                                Bu(_t, $, yi.top + (rn === ye ? ni : 0) + ln, yi.left + (rn === ye ? 0 : ni) + ln)
                                            } else
                                                Bu(_t, ei);
                                        uo(Si || Xi ? Ur : co),
                                        Ds && An < 1 && Si || os(Hi + (An === 1 && !Xi ? Xr : 0))
                                    }
                                }
                                Sn && !Ri.tween && !Ue && !Ye && ui.restart(!0),
                                Be && (Rr || gi && An && (An < 1 || !$e)) && Te(Be.targets).forEach(function(_o) {
                                    return _o.classList[Si || gi ? "add" : "remove"](Be.className)
                                }),
                                Ke && !ai && !Ht && Ke(Ae),
                                as && !Ue ? (ai && (gs && (Vn === "complete" ? V.pause().totalProgress(1) : Vn === "reset" ? V.restart(!0).pause() : Vn === "restart" ? V.restart(!0) : V[Vn]()),
                                Ke && Ke(Ae)),
                                (Rr || !$e) && (cn && Rr && xe(Ae, cn),
                                _i[rr] && xe(Ae, _i[rr]),
                                gi && (An === 1 ? Ae.kill(!1, 1) : _i[rr] = 0),
                                Rr || (rr = An === 1 ? 1 : 3,
                                _i[rr] && xe(Ae, _i[rr]))),
                                Ai && !Si && Math.abs(Ae.getVelocity()) > (G(Ai) ? Ai : 2500) && (we(Ae.callbackAnimation),
                                Dn ? Dn.progress(1) : we(V, Vn === "reverse" ? 1 : !An, 1))) : ai && Ke && !Ue && Ke(Ae)
                            }
                            if (fo) {
                                var ci = mn ? vn / mn.duration() * (mn._caScrollDist || 0) : vn;
                                Ho(ci + (Xe._isFlipped ? 1 : 0)),
                                fo(ci)
                            }
                            go && go(-vn / mn.duration() * (mn._caScrollDist || 0))
                        }
                    }
                    ,
                    Ae.enable = function(Ht, En) {
                        Ae.enabled || (Ae.enabled = !0,
                        Xn(_n, "resize", Gs),
                        hr || Xn(_n, "scroll", bn),
                        or && Xn(Pe, "refreshInit", or),
                        Ht !== !1 && (Ae.progress = li = 0,
                        Oi = Bi = mi = Kr()),
                        En !== !1 && Ae.refresh())
                    }
                    ,
                    Ae.getTween = function(Ht) {
                        return Ht && Ri ? Ri.tween : Dn
                    }
                    ,
                    Ae.setPositions = function(Ht, En, sn, vn) {
                        if (mn) {
                            var Br = mn.scrollTrigger
                              , An = mn.duration()
                              , Ar = Br.end - Br.start;
                            Ht = Br.start + Ar * Ht / An,
                            En = Br.start + Ar * En / An
                        }
                        Ae.refresh(!1, !1, {
                            start: Ft(Ht, sn && !!Ae._startClamp),
                            end: Ft(En, sn && !!Ae._endClamp)
                        }, vn),
                        Ae.update()
                    }
                    ,
                    Ae.adjustPinSpacing = function(Ht) {
                        if (yr && Ht) {
                            var En = yr.indexOf(rn.d) + 1;
                            yr[En] = parseFloat(yr[En]) + Ht + ln,
                            yr[1] = parseFloat(yr[1]) + Ht + ln,
                            uo(yr)
                        }
                    }
                    ,
                    Ae.disable = function(Ht, En) {
                        if (Ae.enabled && (Ht !== !1 && Ae.revert(!0, !0),
                        Ae.enabled = Ae.isActive = !1,
                        En || Dn && Dn.pause(),
                        ti = 0,
                        mr && (mr.uncache = 1),
                        or && en(Pe, "refreshInit", or),
                        ui && (ui.pause(),
                        Ri.tween && Ri.tween.kill() && (Ri.tween = 0)),
                        !hr)) {
                            for (var sn = gn.length; sn--; )
                                if (gn[sn].scroller === _n && gn[sn] !== Ae)
                                    return;
                            en(_n, "resize", Gs),
                            hr || en(_n, "scroll", bn)
                        }
                    }
                    ,
                    Ae.kill = function(Ht, En) {
                        Ae.disable(Ht, En),
                        Dn && !En && Dn.kill(),
                        Wt && delete Jr[Wt];
                        var sn = gn.indexOf(Ae);
                        sn >= 0 && gn.splice(sn, 1),
                        sn === rt && fa > 0 && rt--,
                        sn = 0,
                        gn.forEach(function(vn) {
                            return vn.scroller === Ae.scroller && (sn = 1)
                        }),
                        sn || pi || (Ae.scroll.rec = 0),
                        V && (V.scrollTrigger = null,
                        Ht && V.revert({
                            kill: !1
                        }),
                        En || V.kill()),
                        Mi && [Mi, Gi, Xe, Yi].forEach(function(vn) {
                            return vn.parentNode && vn.parentNode.removeChild(vn)
                        }),
                        is === Ae && (is = 0),
                        _t && (mr && (mr.uncache = 1),
                        sn = 0,
                        gn.forEach(function(vn) {
                            return vn.pin === _t && sn++
                        }),
                        sn || (mr.spacer = 0)),
                        N.onKill && N.onKill(Ae)
                    }
                    ,
                    gn.push(Ae),
                    Ae.enable(!1, !1),
                    Bs && Bs(Ae),
                    V && V.add && !Nr) {
                        var zn = Ae.update;
                        Ae.update = function() {
                            Ae.update = zn,
                            S.cache++,
                            Hn || Ir || Ae.refresh()
                        }
                        ,
                        ae.delayedCall(.01, Ae.update),
                        Nr = .01,
                        Hn = Ir = 0
                    } else
                        Ae.refresh();
                    _t && ca()
                }
                ,
                Pe.register = function(N) {
                    return ze || (ae = N || L(),
                    z() && window.document && Pe.enable(),
                    ze = Ve),
                    ze
                }
                ,
                Pe.defaults = function(N) {
                    if (N)
                        for (var V in N)
                            _r[V] = N[V];
                    return _r
                }
                ,
                Pe.disable = function(N, V) {
                    Ve = 0,
                    gn.forEach(function(Ke) {
                        return Ke[V ? "kill" : "disable"](N)
                    }),
                    en(Se, "wheel", bn),
                    en(Je, "scroll", bn),
                    clearInterval(st),
                    en(Je, "touchcancel", Oe),
                    en($, "touchstart", Oe),
                    $n(en, Je, "pointerdown,touchstart,mousedown", gt),
                    $n(en, Je, "pointerup,touchend,mouseup", et),
                    Me.kill(),
                    T(en);
                    for (var De = 0; De < S.length; De += 3)
                        Mr(en, S[De], S[De + 1]),
                        Mr(en, S[De], S[De + 2])
                }
                ,
                Pe.enable = function() {
                    if (Se = window,
                    Je = document,
                    I = Je.documentElement,
                    $ = Je.body,
                    ae && (Te = ae.utils.toArray,
                    Ne = ae.utils.clamp,
                    X = ae.core.context || Oe,
                    fn = ae.core.suppressOverwrites || Oe,
                    ie = Se.history.scrollRestoration || "auto",
                    xl = Se.pageYOffset || 0,
                    ae.core.globals("ScrollTrigger", Pe),
                    $)) {
                        Ve = 1,
                        _e = document.createElement("div"),
                        _e.style.height = "100vh",
                        _e.style.position = "absolute",
                        oi(),
                        ft(),
                        ve.register(ae),
                        Pe.isTouch = ve.isTouch,
                        ht = ve.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
                        Ln = ve.isTouch === 1,
                        Xn(Se, "wheel", bn),
                        de = [Se, Je, I, $],
                        ae.matchMedia ? (Pe.matchMedia = function(cn) {
                            var wn = ae.matchMedia(), Rn;
                            for (Rn in cn)
                                wn.add(Rn, cn[Rn]);
                            return wn
                        }
                        ,
                        ae.addEventListener("matchMediaInit", function() {
                            return Ls()
                        }),
                        ae.addEventListener("matchMediaRevert", function() {
                            return Ks()
                        }),
                        ae.addEventListener("matchMedia", function() {
                            Is(0, 1),
                            Ys("matchMedia")
                        }),
                        ae.matchMedia().add("(orientation: portrait)", function() {
                            return xn(),
                            xn
                        })) : console.warn("Requires GSAP 3.11.0 or later"),
                        xn(),
                        Xn(Je, "scroll", bn);
                        var N = $.hasAttribute("style"), V = $.style, De = V.borderTopStyle, Ke = ae.core.Animation.prototype, Be, Wt;
                        for (Ke.revert || Object.defineProperty(Ke, "revert", {
                            value: function() {
                                return this.time(-.01, !0)
                            }
                        }),
                        V.borderTopStyle = "solid",
                        Be = br($),
                        ye.m = Math.round(Be.top + ye.sc()) || 0,
                        se.m = Math.round(Be.left + se.sc()) || 0,
                        De ? V.borderTopStyle = De : V.removeProperty("border-top-style"),
                        N || ($.setAttribute("style", ""),
                        $.removeAttribute("style")),
                        st = setInterval(Ms, 250),
                        ae.delayedCall(.5, function() {
                            return Ye = 0
                        }),
                        Xn(Je, "touchcancel", Oe),
                        Xn($, "touchstart", Oe),
                        $n(Xn, Je, "pointerdown,touchstart,mousedown", gt),
                        $n(Xn, Je, "pointerup,touchend,mouseup", et),
                        wt = ae.utils.checkPrefix("transform"),
                        $a.push(wt),
                        ze = je(),
                        Me = ae.delayedCall(.2, Is).pause(),
                        Lt = [Je, "visibilitychange", function() {
                            var cn = Se.innerWidth
                              , wn = Se.innerHeight;
                            Je.hidden ? (Dt = cn,
                            xt = wn) : (Dt !== cn || xt !== wn) && Gs()
                        }
                        , Je, "DOMContentLoaded", Is, Se, "load", Is, Se, "resize", Gs],
                        T(Xn),
                        gn.forEach(function(cn) {
                            return cn.enable(0, 1)
                        }),
                        Wt = 0; Wt < S.length; Wt += 3)
                            Mr(en, S[Wt], S[Wt + 1]),
                            Mr(en, S[Wt], S[Wt + 2])
                    }
                }
                ,
                Pe.config = function(N) {
                    "limitCallbacks"in N && ($e = !!N.limitCallbacks);
                    var V = N.syncInterval;
                    V && clearInterval(st) || (st = V) && setInterval(Ms, V),
                    "ignoreMobileResize"in N && (Ln = Pe.isTouch === 1 && N.ignoreMobileResize),
                    "autoRefreshEvents"in N && (T(en) || T(Xn, N.autoRefreshEvents || "none"),
                    Fn = (N.autoRefreshEvents + "").indexOf("resize") === -1)
                }
                ,
                Pe.scrollerProxy = function(N, V) {
                    var De = Ze(N)
                      , Ke = S.indexOf(De)
                      , Be = ne(De);
                    ~Ke && S.splice(Ke, Be ? 6 : 2),
                    V && (Be ? W.unshift(Se, V, $, V, I, V) : W.unshift(De, V))
                }
                ,
                Pe.clearMatchMedia = function(N) {
                    gn.forEach(function(V) {
                        return V._ctx && V._ctx.query === N && V._ctx.kill(!0, !0)
                    })
                }
                ,
                Pe.isInViewport = function(N, V, De) {
                    var Ke = (M(N) ? Ze(N) : N).getBoundingClientRect()
                      , Be = Ke[De ? dt : pt] * V || 0;
                    return De ? Ke.right - Be > 0 && Ke.left + Be < Se.innerWidth : Ke.bottom - Be > 0 && Ke.top + Be < Se.innerHeight
                }
                ,
                Pe.positionInViewport = function(N, V, De) {
                    M(N) && (N = Ze(N));
                    var Ke = N.getBoundingClientRect()
                      , Be = Ke[De ? dt : pt]
                      , Wt = V == null ? Be / 2 : V in Fi ? Fi[V] * Be : ~V.indexOf("%") ? parseFloat(V) * Be / 100 : parseFloat(V) || 0;
                    return De ? (Ke.left + Wt) / Se.innerWidth : (Ke.top + Wt) / Se.innerHeight
                }
                ,
                Pe.killAll = function(N) {
                    if (gn.slice(0).forEach(function(De) {
                        return De.vars.id !== "ScrollSmoother" && De.kill()
                    }),
                    N !== !0) {
                        var V = lo.killAll || [];
                        lo = {},
                        V.forEach(function(De) {
                            return De()
                        })
                    }
                }
                ,
                Pe
            }();
            kn.version = "3.13.0",
            kn.saveStyles = function(Pe) {
                return Pe ? Te(Pe).forEach(function(A) {
                    if (A && A.style) {
                        var te = Ii.indexOf(A);
                        te >= 0 && Ii.splice(te, 5),
                        Ii.push(A, A.style.cssText, A.getBBox && A.getAttribute("transform"), ae.core.getCache(A), X())
                    }
                }) : Ii
            }
            ,
            kn.revert = function(Pe, A) {
                return Ls(!Pe, A)
            }
            ,
            kn.create = function(Pe, A) {
                return new kn(Pe,A)
            }
            ,
            kn.refresh = function(Pe) {
                return Pe ? Gs(!0) : (ze || kn.register()) && Is(!0)
            }
            ,
            kn.update = function(Pe) {
                return ++S.cache && hs(Pe === !0 ? 2 : 0)
            }
            ,
            kn.clearScrollMemory = El,
            kn.maxScroll = function(Pe, A) {
                return b(Pe, A ? se : ye)
            }
            ,
            kn.getScrollFunc = function(Pe, A) {
                return nt(Ze(Pe), A ? se : ye)
            }
            ,
            kn.getById = function(Pe) {
                return Jr[Pe]
            }
            ,
            kn.getAll = function() {
                return gn.filter(function(Pe) {
                    return Pe.vars.id !== "ScrollSmoother"
                })
            }
            ,
            kn.isScrolling = function() {
                return !!ot
            }
            ,
            kn.snapDirectional = fr,
            kn.addEventListener = function(Pe, A) {
                var te = lo[Pe] || (lo[Pe] = []);
                ~te.indexOf(A) || te.push(A)
            }
            ,
            kn.removeEventListener = function(Pe, A) {
                var te = lo[Pe]
                  , N = te && te.indexOf(A);
                N >= 0 && te.splice(N, 1)
            }
            ,
            kn.batch = function(Pe, A) {
                var te = [], N = {}, V = A.interval || .016, De = A.batchMax || 1e9, Ke = function(cn, wn) {
                    var Rn = []
                      , on = []
                      , _t = ae.delayedCall(V, function() {
                        wn(Rn, on),
                        Rn = [],
                        on = []
                    }).pause();
                    return function(un) {
                        Rn.length || _t.restart(!0),
                        Rn.push(un.trigger),
                        on.push(un),
                        De <= Rn.length && _t.progress(1)
                    }
                }, Be;
                for (Be in A)
                    N[Be] = Be.substr(0, 2) === "on" && H(A[Be]) && Be !== "onRefreshInit" ? Ke(Be, A[Be]) : A[Be];
                return H(De) && (De = De(),
                Xn(kn, "refresh", function() {
                    return De = A.batchMax()
                })),
                Te(Pe).forEach(function(Wt) {
                    var cn = {};
                    for (Be in N)
                        cn[Be] = N[Be];
                    cn.trigger = Wt,
                    te.push(kn.create(cn))
                }),
                te
            }
            ;
            var Ha = function(A, te, N, V) {
                return te > V ? A(V) : te < 0 && A(0),
                N > V ? (V - te) / (N - te) : N < 0 ? te / (te - N) : 1
            }, Pl = function Pe(A, te) {
                te === !0 ? A.style.removeProperty("touch-action") : A.style.touchAction = te === !0 ? "auto" : te ? "pan-" + te + (ve.isTouch ? " pinch-zoom" : "") : "none",
                A === I && Pe($, te)
            }, Va = {
                auto: 1,
                scroll: 1
            }, bf = function(A) {
                var te = A.event, N = A.target, V = A.axis, De = (te.changedTouches ? te.changedTouches[0] : te).target, Ke = De._gsap || ae.core.getCache(De), Be = je(), Wt;
                if (!Ke._isScrollT || Be - Ke._isScrollT > 2e3) {
                    for (; De && De !== $ && (De.scrollHeight <= De.clientHeight && De.scrollWidth <= De.clientWidth || !(Va[(Wt = pn(De)).overflowY] || Va[Wt.overflowX])); )
                        De = De.parentNode;
                    Ke._isScroll = De && De !== N && !ne(De) && (Va[(Wt = pn(De)).overflowY] || Va[Wt.overflowX]),
                    Ke._isScrollT = Be
                }
                (Ke._isScroll || V === "x") && (te.stopPropagation(),
                te._gsapAllow = !0)
            }, kl = function(A, te, N, V) {
                return ve.create({
                    target: A,
                    capture: !0,
                    debounce: !1,
                    lockAxis: !0,
                    type: te,
                    onWheel: V = V && bf,
                    onPress: V,
                    onDrag: V,
                    onScroll: V,
                    onEnable: function() {
                        return N && Xn(Je, ve.eventTypes[0], _a, !1, !0)
                    },
                    onDisable: function() {
                        return en(Je, ve.eventTypes[0], _a, !0)
                    }
                })
            }, Ni = /(input|label|select|textarea)/i, Xs, _a = function(A) {
                var te = Ni.test(A.target.tagName);
                (te || Xs) && (A._gsapAllow = !0,
                Xs = te)
            }, wf = function(A) {
                ce(A) || (A = {}),
                A.preventDefault = A.isNormalizer = A.allowClicks = !0,
                A.type || (A.type = "wheel,touch"),
                A.debounce = !!A.debounce,
                A.id = A.id || "normalizer";
                var te = A, N = te.normalizeScrollX, V = te.momentum, De = te.allowNestedScroll, Ke = te.onRelease, Be, Wt, cn = Ze(A.target) || I, wn = ae.core.globals().ScrollSmoother, Rn = wn && wn.get(), on = ht && (A.content && Ze(A.content) || Rn && A.content !== !1 && !Rn.smooth() && Rn.content()), _t = nt(cn, ye), un = nt(cn, se), Lr = 1, dr = (ve.isTouch && Se.visualViewport ? Se.visualViewport.scale * Se.visualViewport.width : Se.outerWidth) / Se.innerWidth, Zr = 0, kr = H(V) ? function() {
                    return V(Be)
                }
                : function() {
                    return V || 2.8
                }
                , gi, Sn, ss = kl(cn, A.type, !0, De), Dr = function() {
                    return Sn = !1
                }, mn = Oe, Ai = Oe, $i = function() {
                    Wt = b(cn, ye),
                    Ai = Ne(ht ? 1 : 0, Wt),
                    N && (mn = Ne(0, b(cn, se))),
                    gi = Fs
                }, rn = function() {
                    on._gsap.y = O(parseFloat(on._gsap.y) + _t.offset) + "px",
                    on.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(on._gsap.y) + ", 0, 1)",
                    _t.offset = _t.cacheID = 0
                }, ai = function() {
                    if (Sn) {
                        requestAnimationFrame(Dr);
                        var zr = O(Be.deltaY / 2)
                          , Fr = Ai(_t.v - zr);
                        if (on && Fr !== _t.v + _t.offset) {
                            _t.offset = Fr - _t.v;
                            var Ae = O((parseFloat(on && on._gsap.y) || 0) - _t.offset);
                            on.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + Ae + ", 0, 1)",
                            on._gsap.y = Ae + "px",
                            _t.cacheID = S.cache,
                            hs()
                        }
                        return !0
                    }
                    _t.offset && rn(),
                    Sn = !0
                }, _n, vs, hr, Yr, _i = function() {
                    $i(),
                    _n.isActive() && _n.vars.scrollY > Wt && (_t() > Wt ? _n.progress(1) && _t(Wt) : _n.resetTo("scrollY", Wt))
                };
                return on && ae.set(on, {
                    y: "+=0"
                }),
                A.ignoreCheck = function(Bn) {
                    return ht && Bn.type === "touchmove" && ai() || Lr > 1.05 && Bn.type !== "touchstart" || Be.isGesturing || Bn.touches && Bn.touches.length > 1
                }
                ,
                A.onPress = function() {
                    Sn = !1;
                    var Bn = Lr;
                    Lr = O((Se.visualViewport && Se.visualViewport.scale || 1) / dr),
                    _n.pause(),
                    Bn !== Lr && Pl(cn, Lr > 1.01 ? !0 : N ? !1 : "x"),
                    vs = un(),
                    hr = _t(),
                    $i(),
                    gi = Fs
                }
                ,
                A.onRelease = A.onGestureStart = function(Bn, zr) {
                    if (_t.offset && rn(),
                    !zr)
                        Yr.restart(!0);
                    else {
                        S.cache++;
                        var Fr = kr(), Ae, or;
                        N && (Ae = un(),
                        or = Ae + Fr * .05 * -Bn.velocityX / .227,
                        Fr *= Ha(un, Ae, or, b(cn, se)),
                        _n.vars.scrollX = mn(or)),
                        Ae = _t(),
                        or = Ae + Fr * .05 * -Bn.velocityY / .227,
                        Fr *= Ha(_t, Ae, or, b(cn, ye)),
                        _n.vars.scrollY = Ai(or),
                        _n.invalidate().duration(Fr).play(.01),
                        (ht && _n.vars.scrollY >= Wt || Ae >= Wt - 1) && ae.to({}, {
                            onUpdate: _i,
                            duration: Fr
                        })
                    }
                    Ke && Ke(Bn)
                }
                ,
                A.onWheel = function() {
                    _n._ts && _n.pause(),
                    je() - Zr > 1e3 && (gi = 0,
                    Zr = je())
                }
                ,
                A.onChange = function(Bn, zr, Fr, Ae, or) {
                    if (Fs !== gi && $i(),
                    zr && N && un(mn(Ae[2] === zr ? vs + (Bn.startX - Bn.x) : un() + zr - Ae[1])),
                    Fr) {
                        _t.offset && rn();
                        var Wi = or[2] === Fr
                          , qi = Wi ? hr + Bn.startY - Bn.y : _t() + Fr - or[1]
                          , mi = Ai(qi);
                        Wi && qi !== mi && (hr += mi - qi),
                        _t(mi)
                    }
                    (Fr || zr) && hs()
                }
                ,
                A.onEnable = function() {
                    Pl(cn, N ? !1 : "x"),
                    kn.addEventListener("refresh", _i),
                    Xn(Se, "resize", _i),
                    _t.smooth && (_t.target.style.scrollBehavior = "auto",
                    _t.smooth = un.smooth = !1),
                    ss.enable()
                }
                ,
                A.onDisable = function() {
                    Pl(cn, !0),
                    en(Se, "resize", _i),
                    kn.removeEventListener("refresh", _i),
                    ss.kill()
                }
                ,
                A.lockAxis = A.lockAxis !== !1,
                Be = new ve(A),
                Be.iOS = ht,
                ht && !_t() && _t(1),
                ht && ae.ticker.add(Oe),
                Yr = Be._dc,
                _n = ae.to(Be, {
                    ease: "power4",
                    paused: !0,
                    inherit: !1,
                    scrollX: N ? "+=0.1" : "+=0",
                    scrollY: "+=0.1",
                    modifiers: {
                        scrollY: Ba(_t, _t(), function() {
                            return _n.pause()
                        })
                    },
                    onUpdate: hs,
                    onComplete: Yr.vars.onComplete
                }),
                Be
            };
            kn.sort = function(Pe) {
                if (H(Pe))
                    return gn.sort(Pe);
                var A = Se.pageYOffset || 0;
                return kn.getAll().forEach(function(te) {
                    return te._sortY = te.trigger ? A + te.trigger.getBoundingClientRect().top : te.start + Se.innerHeight
                }),
                gn.sort(Pe || function(te, N) {
                    return (te.vars.refreshPriority || 0) * -1e6 + (te.vars.containerAnimation ? 1e6 : te._sortY) - ((N.vars.containerAnimation ? 1e6 : N._sortY) + (N.vars.refreshPriority || 0) * -1e6)
                }
                )
            }
            ,
            kn.observe = function(Pe) {
                return new ve(Pe)
            }
            ,
            kn.normalizeScroll = function(Pe) {
                if (typeof Pe > "u")
                    return hn;
                if (Pe === !0 && hn)
                    return hn.enable();
                if (Pe === !1) {
                    hn && hn.kill(),
                    hn = Pe;
                    return
                }
                var A = Pe instanceof ve ? Pe : wf(Pe);
                return hn && hn.target === A.target && hn.kill(),
                ne(A.target) && (hn = A),
                A
            }
            ,
            kn.core = {
                _getVelocityProp: mt,
                _inputObserver: kl,
                _scrollers: S,
                _proxies: W,
                bridge: {
                    ss: function() {
                        ot || Ys("scrollStart"),
                        ot = je()
                    },
                    ref: function() {
                        return Ue
                    }
                }
            },
            L() && ae.registerPlugin(kn),
            n.ScrollTrigger = kn,
            n.default = kn,
            typeof window > "u" || window !== n ? Object.defineProperty(n, "__esModule", {
                value: !0
            }) : delete window.default
        })
    }(jl, jl.exports)),
    jl.exports
}
var NT = IT();
const ka = la(NT);
var zl = {
    exports: {}
}, $T = zl.exports, Eg;
function BT() {
    return Eg || (Eg = 1,
    function(e, t) {
        (function(n, r) {
            r(t)
        }
        )($T, function(n) {
            var r = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig
              , i = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig
              , s = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig
              , o = /(^[#\.][a-z]|[a-y][a-z])/i
              , l = Math.PI / 180
              , u = 180 / Math.PI
              , p = Math.sin
              , h = Math.cos
              , g = Math.abs
              , m = Math.sqrt
              , w = Math.atan2
              , E = 1e8
              , y = function(b) {
                return typeof b == "string"
            }
              , R = function(b) {
                return typeof b == "number"
            }
              , P = function(b) {
                return typeof b > "u"
            }
              , x = {}
              , v = {}
              , k = 1e5
              , S = function(b) {
                return Math.round((b + E) % 1 * k) / k || (b < 0 ? 0 : 1)
            }
              , W = function(b) {
                return Math.round(b * k) / k || 0
            }
              , K = function(b) {
                return Math.round(b * 1e10) / 1e10 || 0
            }
              , be = function(b, T, M, H) {
                var G = b[T]
                  , ce = H === 1 ? 6 : yt(G, M, H);
                if ((ce || !H) && ce + M + 2 < G.length)
                    return b.splice(T, 0, G.slice(0, M + ce + 2)),
                    G.splice(0, M + ce),
                    1
            }
              , fe = function(b, T, M) {
                var H = b.length
                  , G = ~~(M * H);
                if (b[G] > T) {
                    for (; --G && b[G] > T; )
                        ;
                    G < 0 && (G = 0)
                } else
                    for (; b[++G] < T && G < H; )
                        ;
                return G < H ? G : H - 1
            }
              , ge = function(b, T) {
                var M = b.length;
                for (b.reverse(); M--; )
                    b[M].reversed || Z(b[M])
            }
              , J = function(b, T) {
                return T.totalLength = b.totalLength,
                b.samples ? (T.samples = b.samples.slice(0),
                T.lookup = b.lookup.slice(0),
                T.minLength = b.minLength,
                T.resolution = b.resolution) : b.totalPoints && (T.totalPoints = b.totalPoints),
                T
            }
              , re = function(b, T) {
                var M = b.length
                  , H = b[M - 1] || []
                  , G = H.length;
                M && T[0] === H[G - 2] && T[1] === H[G - 1] && (T = H.concat(T.slice(2)),
                M--),
                b[M] = T
            };
            function ee(F) {
                F = y(F) && o.test(F) && document.querySelector(F) || F;
                var b = F.getAttribute ? F : 0, T;
                return b && (F = F.getAttribute("d")) ? (b._gsPath || (b._gsPath = {}),
                T = b._gsPath[F],
                T && !T._dirty ? T : b._gsPath[F] = ae(F)) : F ? y(F) ? ae(F) : R(F[0]) ? [F] : F : console.warn("Expecting a <path> element or an SVG path data string")
            }
            function Y(F) {
                for (var b = [], T = 0; T < F.length; T++)
                    b[T] = J(F[T], F[T].slice(0));
                return J(F, b)
            }
            function Z(F) {
                var b = 0, T;
                for (F.reverse(); b < F.length; b += 2)
                    T = F[b],
                    F[b] = F[b + 1],
                    F[b + 1] = T;
                F.reversed = !F.reversed
            }
            var Q = function(b, T) {
                var M = document.createElementNS("http://www.w3.org/2000/svg", "path"), H = [].slice.call(b.attributes), G = H.length, ce;
                for (T = "," + T + ","; --G > -1; )
                    ce = H[G].nodeName.toLowerCase(),
                    T.indexOf("," + ce + ",") < 0 && M.setAttributeNS(null, ce, H[G].nodeValue);
                return M
            }
              , ue = {
                rect: "rx,ry,x,y,width,height",
                circle: "r,cx,cy",
                ellipse: "rx,ry,cx,cy",
                line: "x1,x2,y1,y2"
            }
              , se = function(b, T) {
                for (var M = T ? T.split(",") : [], H = {}, G = M.length; --G > -1; )
                    H[M[G]] = +b.getAttribute(M[G]) || 0;
                return H
            };
            function ye(F, b) {
                var T = F.tagName.toLowerCase(), M = .552284749831, H, G, ce, we, xe, oe, We, me, Qe, tt, dt, pt, jt, Nt, Pt, Bt, $t, nn, Zt, Yt, ln, pn;
                return T === "path" || !F.getBBox ? F : (oe = Q(F, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"),
                pn = se(F, ue[T]),
                T === "rect" ? (we = pn.rx,
                xe = pn.ry || we,
                G = pn.x,
                ce = pn.y,
                tt = pn.width - we * 2,
                dt = pn.height - xe * 2,
                we || xe ? (pt = G + we * (1 - M),
                jt = G + we,
                Nt = jt + tt,
                Pt = Nt + we * M,
                Bt = Nt + we,
                $t = ce + xe * (1 - M),
                nn = ce + xe,
                Zt = nn + dt,
                Yt = Zt + xe * M,
                ln = Zt + xe,
                H = "M" + Bt + "," + nn + " V" + Zt + " C" + [Bt, Yt, Pt, ln, Nt, ln, Nt - (Nt - jt) / 3, ln, jt + (Nt - jt) / 3, ln, jt, ln, pt, ln, G, Yt, G, Zt, G, Zt - (Zt - nn) / 3, G, nn + (Zt - nn) / 3, G, nn, G, $t, pt, ce, jt, ce, jt + (Nt - jt) / 3, ce, Nt - (Nt - jt) / 3, ce, Nt, ce, Pt, ce, Bt, $t, Bt, nn].join(",") + "z") : H = "M" + (G + tt) + "," + ce + " v" + dt + " h" + -tt + " v" + -dt + " h" + tt + "z") : T === "circle" || T === "ellipse" ? (T === "circle" ? (we = xe = pn.r,
                me = we * M) : (we = pn.rx,
                xe = pn.ry,
                me = xe * M),
                G = pn.cx,
                ce = pn.cy,
                We = we * M,
                H = "M" + (G + we) + "," + ce + " C" + [G + we, ce + me, G + We, ce + xe, G, ce + xe, G - We, ce + xe, G - we, ce + me, G - we, ce, G - we, ce - me, G - We, ce - xe, G, ce - xe, G + We, ce - xe, G + we, ce - me, G + we, ce].join(",") + "z") : T === "line" ? H = "M" + pn.x1 + "," + pn.y1 + " L" + pn.x2 + "," + pn.y2 : (T === "polyline" || T === "polygon") && (Qe = (F.getAttribute("points") + "").match(i) || [],
                G = Qe.shift(),
                ce = Qe.shift(),
                H = "M" + G + "," + ce + " L" + Qe.join(","),
                T === "polygon" && (H += "," + G + "," + ce + "z")),
                oe.setAttribute("d", Je(oe._gsRawPath = ae(H))),
                b && F.parentNode && (F.parentNode.insertBefore(oe, F),
                F.parentNode.removeChild(F)),
                oe)
            }
            function Ze(F, b, T) {
                var M = F[b], H = F[b + 2], G = F[b + 4], ce;
                return M += (H - M) * T,
                H += (G - H) * T,
                M += (H - M) * T,
                ce = H + (G + (F[b + 6] - G) * T - H) * T - M,
                M = F[b + 1],
                H = F[b + 3],
                G = F[b + 5],
                M += (H - M) * T,
                H += (G - H) * T,
                M += (H - M) * T,
                W(w(H + (G + (F[b + 7] - G) * T - H) * T - M, ce) * u)
            }
            function qe(F, b, T) {
                T = P(T) ? 1 : K(T) || 0,
                b = K(b) || 0;
                var M = Math.max(0, ~~(g(T - b) - 1e-8))
                  , H = Y(F);
                if (b > T && (b = 1 - b,
                T = 1 - T,
                ge(H),
                H.totalLength = 0),
                b < 0 || T < 0) {
                    var G = Math.abs(~~Math.min(b, T)) + 1;
                    b += G,
                    T += G
                }
                H.totalLength || mt(H);
                var ce = T > 1, we = At(H, b, x, !0), xe = At(H, T, v), oe = xe.segment, We = we.segment, me = xe.segIndex, Qe = we.segIndex, tt = xe.i, dt = we.i, pt = Qe === me, jt = tt === dt && pt, Nt, Pt, Bt, $t, nn, Zt, Yt, ln;
                if (ce || M) {
                    for (Nt = me < Qe || pt && tt < dt || jt && xe.t < we.t,
                    be(H, Qe, dt, we.t) && (Qe++,
                    Nt || (me++,
                    jt ? (xe.t = (xe.t - we.t) / (1 - we.t),
                    tt = 0) : pt && (tt -= dt))),
                    Math.abs(1 - (T - b)) < 1e-5 ? me = Qe - 1 : !xe.t && me ? me-- : be(H, me, tt, xe.t) && Nt && Qe++,
                    we.t === 1 && (Qe = (Qe + 1) % H.length),
                    nn = [],
                    Zt = H.length,
                    Yt = 1 + Zt * M,
                    ln = Qe,
                    Yt += (Zt - Qe + me) % Zt,
                    $t = 0; $t < Yt; $t++)
                        re(nn, H[ln++ % Zt]);
                    H = nn
                } else if (Bt = xe.t === 1 ? 6 : yt(oe, tt, xe.t),
                b !== T)
                    for (Pt = yt(We, dt, jt ? we.t / xe.t : we.t),
                    pt && (Bt += Pt),
                    oe.splice(tt + Bt + 2),
                    (Pt || dt) && We.splice(0, dt + Pt),
                    $t = H.length; $t--; )
                        ($t < Qe || $t > me) && H.splice($t, 1);
                else
                    oe.angle = Ze(oe, tt + Bt, 0),
                    tt += Bt,
                    we = oe[tt],
                    xe = oe[tt + 1],
                    oe.length = oe.totalLength = 0,
                    oe.totalPoints = H.totalPoints = 8,
                    oe.push(we, xe, we, xe, we, xe, we, xe);
                return H.totalLength = 0,
                H
            }
            function nt(F, b, T) {
                b = b || 0,
                F.samples || (F.samples = [],
                F.lookup = []);
                var M = ~~F.resolution || 12, H = 1 / M, G = F.length, ce = F[b], we = F[b + 1], xe = b ? b / 6 * M : 0, oe = F.samples, We = F.lookup, me = (b ? F.minLength : E) || E, Qe = oe[xe + T * M - 1], tt = b ? oe[xe - 1] : 0, dt, pt, jt, Nt, Pt, Bt, $t, nn, Zt, Yt, ln, pn, Vr, ur, br, wr, Pr;
                for (oe.length = We.length = 0,
                pt = b + 2; pt < G; pt += 6) {
                    if (jt = F[pt + 4] - ce,
                    Nt = F[pt + 2] - ce,
                    Pt = F[pt] - ce,
                    nn = F[pt + 5] - we,
                    Zt = F[pt + 3] - we,
                    Yt = F[pt + 1] - we,
                    Bt = $t = ln = pn = 0,
                    g(jt) < .01 && g(nn) < .01 && g(Pt) + g(Yt) < .01)
                        F.length > 8 && (F.splice(pt, 6),
                        pt -= 6,
                        G -= 6);
                    else
                        for (dt = 1; dt <= M; dt++)
                            ur = H * dt,
                            Vr = 1 - ur,
                            Bt = $t - ($t = (ur * ur * jt + 3 * Vr * (ur * Nt + Vr * Pt)) * ur),
                            ln = pn - (pn = (ur * ur * nn + 3 * Vr * (ur * Zt + Vr * Yt)) * ur),
                            wr = m(ln * ln + Bt * Bt),
                            wr < me && (me = wr),
                            tt += wr,
                            oe[xe++] = tt;
                    ce += jt,
                    we += nn
                }
                if (Qe)
                    for (Qe -= tt; xe < oe.length; xe++)
                        oe[xe] += Qe;
                if (oe.length && me) {
                    if (F.totalLength = Pr = oe[oe.length - 1] || 0,
                    F.minLength = me,
                    Pr / me < 9999)
                        for (wr = br = 0,
                        dt = 0; dt < Pr; dt += me)
                            We[wr++] = oe[br] < dt ? ++br : br
                } else
                    F.totalLength = oe[0] = 0;
                return b ? tt - oe[b / 2 - 1] : tt
            }
            function mt(F, b) {
                var T, M, H;
                for (H = T = M = 0; H < F.length; H++)
                    F[H].resolution = ~~b || 12,
                    M += F[H].length,
                    T += nt(F[H]);
                return F.totalPoints = M,
                F.totalLength = T,
                F
            }
            function yt(F, b, T) {
                if (T <= 0 || T >= 1)
                    return 0;
                var M = F[b]
                  , H = F[b + 1]
                  , G = F[b + 2]
                  , ce = F[b + 3]
                  , we = F[b + 4]
                  , xe = F[b + 5]
                  , oe = F[b + 6]
                  , We = F[b + 7]
                  , me = M + (G - M) * T
                  , Qe = G + (we - G) * T
                  , tt = H + (ce - H) * T
                  , dt = ce + (xe - ce) * T
                  , pt = me + (Qe - me) * T
                  , jt = tt + (dt - tt) * T
                  , Nt = we + (oe - we) * T
                  , Pt = xe + (We - xe) * T;
                return Qe += (Nt - Qe) * T,
                dt += (Pt - dt) * T,
                F.splice(b + 2, 4, W(me), W(tt), W(pt), W(jt), W(pt + (Qe - pt) * T), W(jt + (dt - jt) * T), W(Qe), W(dt), W(Nt), W(Pt)),
                F.samples && F.samples.splice(b / 6 * F.resolution | 0, 0, 0, 0, 0, 0, 0, 0),
                6
            }
            function At(F, b, T, M) {
                T = T || {},
                F.totalLength || mt(F),
                (b < 0 || b > 1) && (b = S(b));
                var H = 0, G = F[0], ce, we, xe, oe, We, me, Qe;
                if (!b)
                    Qe = me = H = 0,
                    G = F[0];
                else if (b === 1)
                    Qe = 1,
                    H = F.length - 1,
                    G = F[H],
                    me = G.length - 8;
                else {
                    if (F.length > 1) {
                        for (xe = F.totalLength * b,
                        We = me = 0; (We += F[me++].totalLength) < xe; )
                            H = me;
                        G = F[H],
                        oe = We - G.totalLength,
                        b = (xe - oe) / (We - oe) || 0
                    }
                    ce = G.samples,
                    we = G.resolution,
                    xe = G.totalLength * b,
                    me = G.lookup.length ? G.lookup[~~(xe / G.minLength)] || 0 : fe(ce, xe, b),
                    oe = me ? ce[me - 1] : 0,
                    We = ce[me],
                    We < xe && (oe = We,
                    We = ce[++me]),
                    Qe = 1 / we * ((xe - oe) / (We - oe) + me % we),
                    me = ~~(me / we) * 6,
                    M && Qe === 1 && (me + 6 < G.length ? (me += 6,
                    Qe = 0) : H + 1 < F.length && (me = Qe = 0,
                    G = F[++H]))
                }
                return T.t = Qe,
                T.i = me,
                T.path = F,
                T.segment = G,
                T.segIndex = H,
                T
            }
            function Tt(F, b, T, M) {
                var H = F[0], G = M || {}, ce, we, xe, oe, We, me, Qe, tt, dt;
                if ((b < 0 || b > 1) && (b = S(b)),
                H.lookup || mt(F),
                F.length > 1) {
                    for (xe = F.totalLength * b,
                    We = me = 0; (We += F[me++].totalLength) < xe; )
                        H = F[me];
                    oe = We - H.totalLength,
                    b = (xe - oe) / (We - oe) || 0
                }
                return ce = H.samples,
                we = H.resolution,
                xe = H.totalLength * b,
                me = H.lookup.length ? H.lookup[b < 1 ? ~~(xe / H.minLength) : H.lookup.length - 1] || 0 : fe(ce, xe, b),
                oe = me ? ce[me - 1] : 0,
                We = ce[me],
                We < xe && (oe = We,
                We = ce[++me]),
                Qe = 1 / we * ((xe - oe) / (We - oe) + me % we) || 0,
                dt = 1 - Qe,
                me = ~~(me / we) * 6,
                tt = H[me],
                G.x = W((Qe * Qe * (H[me + 6] - tt) + 3 * dt * (Qe * (H[me + 4] - tt) + dt * (H[me + 2] - tt))) * Qe + tt),
                G.y = W((Qe * Qe * (H[me + 7] - (tt = H[me + 1])) + 3 * dt * (Qe * (H[me + 5] - tt) + dt * (H[me + 3] - tt))) * Qe + tt),
                T && (G.angle = H.totalLength ? Ze(H, me, Qe >= 1 ? 1 - 1e-9 : Qe || 1e-9) : H.angle || 0),
                G
            }
            function he(F, b, T, M, H, G, ce) {
                for (var we = F.length, xe, oe, We, me, Qe; --we > -1; )
                    for (xe = F[we],
                    oe = xe.length,
                    We = 0; We < oe; We += 2)
                        me = xe[We],
                        Qe = xe[We + 1],
                        xe[We] = me * b + Qe * M + G,
                        xe[We + 1] = me * T + Qe * H + ce;
                return F._dirty = 1,
                F
            }
            function ve(F, b, T, M, H, G, ce, we, xe) {
                if (!(F === we && b === xe)) {
                    T = g(T),
                    M = g(M);
                    var oe = H % 360 * l
                      , We = h(oe)
                      , me = p(oe)
                      , Qe = Math.PI
                      , tt = Qe * 2
                      , dt = (F - we) / 2
                      , pt = (b - xe) / 2
                      , jt = We * dt + me * pt
                      , Nt = -me * dt + We * pt
                      , Pt = jt * jt
                      , Bt = Nt * Nt
                      , $t = Pt / (T * T) + Bt / (M * M);
                    $t > 1 && (T = m($t) * T,
                    M = m($t) * M);
                    var nn = T * T
                      , Zt = M * M
                      , Yt = (nn * Zt - nn * Bt - Zt * Pt) / (nn * Bt + Zt * Pt);
                    Yt < 0 && (Yt = 0);
                    var ln = (G === ce ? -1 : 1) * m(Yt)
                      , pn = ln * (T * Nt / M)
                      , Vr = ln * -(M * jt / T)
                      , ur = (F + we) / 2
                      , br = (b + xe) / 2
                      , wr = ur + (We * pn - me * Vr)
                      , Pr = br + (me * pn + We * Vr)
                      , cr = (jt - pn) / T
                      , fr = (Nt - Vr) / M
                      , qn = (-jt - pn) / T
                      , $n = (-Nt - Vr) / M
                      , Xn = cr * cr + fr * fr
                      , en = (fr < 0 ? -1 : 1) * Math.acos(cr / m(Xn))
                      , Mr = (cr * $n - fr * qn < 0 ? -1 : 1) * Math.acos((cr * qn + fr * $n) / m(Xn * (qn * qn + $n * $n)));
                    isNaN(Mr) && (Mr = Qe),
                    !ce && Mr > 0 ? Mr -= tt : ce && Mr < 0 && (Mr += tt),
                    en %= tt,
                    Mr %= tt;
                    var hi = Math.ceil(g(Mr) / (tt / 4)), _r = [], Fi = Mr / hi, Gn = 4 / 3 * p(Fi / 2) / (1 + h(Fi / 2)), Qn = We * T, Os = me * T, gn = me * -M, Jr = We * M, Pn;
                    for (Pn = 0; Pn < hi; Pn++)
                        H = en + Pn * Fi,
                        jt = h(H),
                        Nt = p(H),
                        cr = h(H += Fi),
                        fr = p(H),
                        _r.push(jt - Gn * Nt, Nt + Gn * jt, cr + Gn * fr, fr - Gn * cr, cr, fr);
                    for (Pn = 0; Pn < _r.length; Pn += 2)
                        jt = _r[Pn],
                        Nt = _r[Pn + 1],
                        _r[Pn] = jt * Qn + Nt * gn + wr,
                        _r[Pn + 1] = jt * Os + Nt * Jr + Pr;
                    return _r[Pn - 2] = we,
                    _r[Pn - 1] = xe,
                    _r
                }
            }
            function ae(F) {
                var b = (F + "").replace(s, function(pn) {
                    var Vr = +pn;
                    return Vr < 1e-4 && Vr > -1e-4 ? 0 : Vr
                }).match(r) || [], T = [], M = 0, H = 0, G = 2 / 3, ce = b.length, we = 0, xe = "ERROR: malformed path: " + F, oe, We, me, Qe, tt, dt, pt, jt, Nt, Pt, Bt, $t, nn, Zt, Yt, ln = function(Vr, ur, br, wr) {
                    Pt = (br - Vr) / 3,
                    Bt = (wr - ur) / 3,
                    pt.push(Vr + Pt, ur + Bt, br - Pt, wr - Bt, br, wr)
                };
                if (!F || !isNaN(b[0]) || isNaN(b[1]))
                    return console.log(xe),
                    T;
                for (oe = 0; oe < ce; oe++)
                    if (nn = tt,
                    isNaN(b[oe]) ? (tt = b[oe].toUpperCase(),
                    dt = tt !== b[oe]) : oe--,
                    me = +b[oe + 1],
                    Qe = +b[oe + 2],
                    dt && (me += M,
                    Qe += H),
                    oe || (jt = me,
                    Nt = Qe),
                    tt === "M")
                        pt && (pt.length < 8 ? T.length -= 1 : we += pt.length),
                        M = jt = me,
                        H = Nt = Qe,
                        pt = [me, Qe],
                        T.push(pt),
                        oe += 2,
                        tt = "L";
                    else if (tt === "C")
                        pt || (pt = [0, 0]),
                        dt || (M = H = 0),
                        pt.push(me, Qe, M + b[oe + 3] * 1, H + b[oe + 4] * 1, M += b[oe + 5] * 1, H += b[oe + 6] * 1),
                        oe += 6;
                    else if (tt === "S")
                        Pt = M,
                        Bt = H,
                        (nn === "C" || nn === "S") && (Pt += M - pt[pt.length - 4],
                        Bt += H - pt[pt.length - 3]),
                        dt || (M = H = 0),
                        pt.push(Pt, Bt, me, Qe, M += b[oe + 3] * 1, H += b[oe + 4] * 1),
                        oe += 4;
                    else if (tt === "Q")
                        Pt = M + (me - M) * G,
                        Bt = H + (Qe - H) * G,
                        dt || (M = H = 0),
                        M += b[oe + 3] * 1,
                        H += b[oe + 4] * 1,
                        pt.push(Pt, Bt, M + (me - M) * G, H + (Qe - H) * G, M, H),
                        oe += 4;
                    else if (tt === "T")
                        Pt = M - pt[pt.length - 4],
                        Bt = H - pt[pt.length - 3],
                        pt.push(M + Pt, H + Bt, me + (M + Pt * 1.5 - me) * G, Qe + (H + Bt * 1.5 - Qe) * G, M = me, H = Qe),
                        oe += 2;
                    else if (tt === "H")
                        ln(M, H, M = me, H),
                        oe += 1;
                    else if (tt === "V")
                        ln(M, H, M, H = me + (dt ? H - M : 0)),
                        oe += 1;
                    else if (tt === "L" || tt === "Z")
                        tt === "Z" && (me = jt,
                        Qe = Nt,
                        pt.closed = !0),
                        (tt === "L" || g(M - me) > .5 || g(H - Qe) > .5) && (ln(M, H, me, Qe),
                        tt === "L" && (oe += 2)),
                        M = me,
                        H = Qe;
                    else if (tt === "A") {
                        if (Zt = b[oe + 4],
                        Yt = b[oe + 5],
                        Pt = b[oe + 6],
                        Bt = b[oe + 7],
                        We = 7,
                        Zt.length > 1 && (Zt.length < 3 ? (Bt = Pt,
                        Pt = Yt,
                        We--) : (Bt = Yt,
                        Pt = Zt.substr(2),
                        We -= 2),
                        Yt = Zt.charAt(1),
                        Zt = Zt.charAt(0)),
                        $t = ve(M, H, +b[oe + 1], +b[oe + 2], +b[oe + 3], +Zt, +Yt, (dt ? M : 0) + Pt * 1, (dt ? H : 0) + Bt * 1),
                        oe += We,
                        $t)
                            for (We = 0; We < $t.length; We++)
                                pt.push($t[We]);
                        M = pt[pt.length - 2],
                        H = pt[pt.length - 1]
                    } else
                        console.log(xe);
                return oe = pt.length,
                oe < 6 ? (T.pop(),
                oe = 0) : pt[0] === pt[oe - 2] && pt[1] === pt[oe - 1] && (pt.closed = !0),
                T.totalPoints = we + oe,
                T
            }
            function ze(F, b) {
                b === void 0 && (b = 1);
                for (var T = F[0], M = 0, H = [T, M], G = 2; G < F.length; G += 2)
                    H.push(T, M, F[G], M = (F[G] - T) * b / 2, T = F[G], -M);
                return H
            }
            function Se(F, b) {
                g(F[0] - F[2]) < 1e-4 && g(F[1] - F[3]) < 1e-4 && (F = F.slice(2));
                var T = F.length - 2, M = +F[0], H = +F[1], G = +F[2], ce = +F[3], we = [M, H, M, H], xe = G - M, oe = ce - H, We = Math.abs(F[T] - M) < .001 && Math.abs(F[T + 1] - H) < .001, me, Qe, tt, dt, pt, jt, Nt, Pt, Bt, $t, nn, Zt, Yt, ln, pn;
                for (We && (F.push(G, ce),
                G = M,
                ce = H,
                M = F[T - 2],
                H = F[T - 1],
                F.unshift(M, H),
                T += 4),
                b = b || b === 0 ? +b : 1,
                tt = 2; tt < T; tt += 2)
                    me = M,
                    Qe = H,
                    M = G,
                    H = ce,
                    G = +F[tt + 2],
                    ce = +F[tt + 3],
                    !(M === G && H === ce) && (dt = xe,
                    pt = oe,
                    xe = G - M,
                    oe = ce - H,
                    jt = m(dt * dt + pt * pt),
                    Nt = m(xe * xe + oe * oe),
                    Pt = m(Math.pow(xe / Nt + dt / jt, 2) + Math.pow(oe / Nt + pt / jt, 2)),
                    Bt = (jt + Nt) * b * .25 / Pt,
                    $t = M - (M - me) * (jt ? Bt / jt : 0),
                    nn = M + (G - M) * (Nt ? Bt / Nt : 0),
                    Zt = M - ($t + ((nn - $t) * (jt * 3 / (jt + Nt) + .5) / 4 || 0)),
                    Yt = H - (H - Qe) * (jt ? Bt / jt : 0),
                    ln = H + (ce - H) * (Nt ? Bt / Nt : 0),
                    pn = H - (Yt + ((ln - Yt) * (jt * 3 / (jt + Nt) + .5) / 4 || 0)),
                    (M !== me || H !== Qe) && we.push(W($t + Zt), W(Yt + pn), W(M), W(H), W(nn + Zt), W(ln + pn)));
                return M !== G || H !== ce || we.length < 4 ? we.push(W(G), W(ce), W(G), W(ce)) : we.length -= 2,
                we.length === 2 ? we.push(M, H, M, H, M, H) : We && (we.splice(0, 6),
                we.length = we.length - 6),
                we
            }
            function Je(F) {
                R(F[0]) && (F = [F]);
                var b = "", T = F.length, M, H, G, ce;
                for (H = 0; H < T; H++) {
                    for (ce = F[H],
                    b += "M" + W(ce[0]) + "," + W(ce[1]) + " C",
                    M = ce.length,
                    G = 2; G < M; G++)
                        b += W(ce[G++]) + "," + W(ce[G++]) + " " + W(ce[G++]) + "," + W(ce[G++]) + " " + W(ce[G++]) + "," + W(ce[G]) + " ";
                    ce.closed && (b += "z")
                }
                return b
            }
            var I, $, de, Me, Te, Ne, lt, st, Ue = "transform", Ge = Ue + "Origin", wt, rt = function(b) {
                var T = b.ownerDocument || b;
                for (!(Ue in b.style) && ("msTransform"in b.style) && (Ue = "msTransform",
                Ge = Ue + "Origin"); T.parentNode && (T = T.parentNode); )
                    ;
                if ($ = window,
                lt = new ie,
                T) {
                    I = T,
                    de = T.documentElement,
                    Me = T.body,
                    st = I.createElementNS("http://www.w3.org/2000/svg", "g"),
                    st.style.transform = "none";
                    var M = T.createElement("div")
                      , H = T.createElement("div")
                      , G = T && (T.body || T.firstElementChild);
                    G && G.appendChild && (G.appendChild(M),
                    M.appendChild(H),
                    M.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"),
                    wt = H.offsetParent !== M,
                    G.removeChild(M))
                }
                return T
            }, Dt = function(b) {
                for (var T, M; b && b !== Me; )
                    M = b._gsap,
                    M && M.uncache && M.get(b, "x"),
                    M && !M.scaleX && !M.scaleY && M.renderTransform && (M.scaleX = M.scaleY = 1e-4,
                    M.renderTransform(1, M),
                    T ? T.push(M) : T = [M]),
                    b = b.parentNode;
                return T
            }, xt = [], Lt = [], Jt = function() {
                return $.pageYOffset || I.scrollTop || de.scrollTop || Me.scrollTop || 0
            }, fn = function() {
                return $.pageXOffset || I.scrollLeft || de.scrollLeft || Me.scrollLeft || 0
            }, Fn = function(b) {
                return b.ownerSVGElement || ((b.tagName + "").toLowerCase() === "svg" ? b : null)
            }, hn = function F(b) {
                if ($.getComputedStyle(b).position === "fixed")
                    return !0;
                if (b = b.parentNode,
                b && b.nodeType === 1)
                    return F(b)
            }, Ln = function F(b, T) {
                if (b.parentNode && (I || rt(b))) {
                    var M = Fn(b)
                      , H = M ? M.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml"
                      , G = M ? T ? "rect" : "g" : "div"
                      , ce = T !== 2 ? 0 : 100
                      , we = T === 3 ? 100 : 0
                      , xe = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;"
                      , oe = I.createElementNS ? I.createElementNS(H.replace(/^https/, "http"), G) : I.createElement(G);
                    return T && (M ? (Ne || (Ne = F(b)),
                    oe.setAttribute("width", .01),
                    oe.setAttribute("height", .01),
                    oe.setAttribute("transform", "translate(" + ce + "," + we + ")"),
                    Ne.appendChild(oe)) : (Te || (Te = F(b),
                    Te.style.cssText = xe),
                    oe.style.cssText = xe + "width:0.1px;height:0.1px;top:" + we + "px;left:" + ce + "px",
                    Te.appendChild(oe))),
                    oe
                }
                throw "Need document and parent."
            }, Kn = function(b) {
                for (var T = new ie, M = 0; M < b.numberOfItems; M++)
                    T.multiply(b.getItem(M).matrix);
                return T
            }, lr = function(b) {
                var T = b.getCTM(), M;
                return T || (M = b.style[Ue],
                b.style[Ue] = "none",
                b.appendChild(st),
                T = st.getCTM(),
                b.removeChild(st),
                M ? b.style[Ue] = M : b.style.removeProperty(Ue.replace(/([A-Z])/g, "-$1").toLowerCase())),
                T || lt.clone()
            }, ht = function(b, T) {
                var M = Fn(b), H = b === M, G = M ? xt : Lt, ce = b.parentNode, we = ce && !M && ce.shadowRoot && ce.shadowRoot.appendChild ? ce.shadowRoot : ce, xe, oe, We, me, Qe, tt;
                if (b === $)
                    return b;
                if (G.length || G.push(Ln(b, 1), Ln(b, 2), Ln(b, 3)),
                xe = M ? Ne : Te,
                M)
                    H ? (We = lr(b),
                    me = -We.e / We.a,
                    Qe = -We.f / We.d,
                    oe = lt) : b.getBBox ? (We = b.getBBox(),
                    oe = b.transform ? b.transform.baseVal : {},
                    oe = oe.numberOfItems ? oe.numberOfItems > 1 ? Kn(oe) : oe.getItem(0).matrix : lt,
                    me = oe.a * We.x + oe.c * We.y,
                    Qe = oe.b * We.x + oe.d * We.y) : (oe = new ie,
                    me = Qe = 0),
                    T && b.tagName.toLowerCase() === "g" && (me = Qe = 0),
                    (H ? M : ce).appendChild(xe),
                    xe.setAttribute("transform", "matrix(" + oe.a + "," + oe.b + "," + oe.c + "," + oe.d + "," + (oe.e + me) + "," + (oe.f + Qe) + ")");
                else {
                    if (me = Qe = 0,
                    wt)
                        for (oe = b.offsetParent,
                        We = b; We && (We = We.parentNode) && We !== oe && We.parentNode; )
                            ($.getComputedStyle(We)[Ue] + "").length > 4 && (me = We.offsetLeft,
                            Qe = We.offsetTop,
                            We = 0);
                    if (tt = $.getComputedStyle(b),
                    tt.position !== "absolute" && tt.position !== "fixed")
                        for (oe = b.offsetParent; ce && ce !== oe; )
                            me += ce.scrollLeft || 0,
                            Qe += ce.scrollTop || 0,
                            ce = ce.parentNode;
                    We = xe.style,
                    We.top = b.offsetTop - Qe + "px",
                    We.left = b.offsetLeft - me + "px",
                    We[Ue] = tt[Ue],
                    We[Ge] = tt[Ge],
                    We.position = tt.position === "fixed" ? "fixed" : "absolute",
                    we.appendChild(xe)
                }
                return xe
            }, X = function(b, T, M, H, G, ce, we) {
                return b.a = T,
                b.b = M,
                b.c = H,
                b.d = G,
                b.e = ce,
                b.f = we,
                b
            }, ie = function() {
                function F(T, M, H, G, ce, we) {
                    T === void 0 && (T = 1),
                    M === void 0 && (M = 0),
                    H === void 0 && (H = 0),
                    G === void 0 && (G = 1),
                    ce === void 0 && (ce = 0),
                    we === void 0 && (we = 0),
                    X(this, T, M, H, G, ce, we)
                }
                var b = F.prototype;
                return b.inverse = function() {
                    var M = this.a
                      , H = this.b
                      , G = this.c
                      , ce = this.d
                      , we = this.e
                      , xe = this.f
                      , oe = M * ce - H * G || 1e-10;
                    return X(this, ce / oe, -H / oe, -G / oe, M / oe, (G * xe - ce * we) / oe, -(M * xe - H * we) / oe)
                }
                ,
                b.multiply = function(M) {
                    var H = this.a
                      , G = this.b
                      , ce = this.c
                      , we = this.d
                      , xe = this.e
                      , oe = this.f
                      , We = M.a
                      , me = M.c
                      , Qe = M.b
                      , tt = M.d
                      , dt = M.e
                      , pt = M.f;
                    return X(this, We * H + Qe * ce, We * G + Qe * we, me * H + tt * ce, me * G + tt * we, xe + dt * H + pt * ce, oe + dt * G + pt * we)
                }
                ,
                b.clone = function() {
                    return new F(this.a,this.b,this.c,this.d,this.e,this.f)
                }
                ,
                b.equals = function(M) {
                    var H = this.a
                      , G = this.b
                      , ce = this.c
                      , we = this.d
                      , xe = this.e
                      , oe = this.f;
                    return H === M.a && G === M.b && ce === M.c && we === M.d && xe === M.e && oe === M.f
                }
                ,
                b.apply = function(M, H) {
                    H === void 0 && (H = {});
                    var G = M.x
                      , ce = M.y
                      , we = this.a
                      , xe = this.b
                      , oe = this.c
                      , We = this.d
                      , me = this.e
                      , Qe = this.f;
                    return H.x = G * we + ce * oe + me || 0,
                    H.y = G * xe + ce * We + Qe || 0,
                    H
                }
                ,
                F
            }();
            function _e(F, b, T, M) {
                if (!F || !F.parentNode || (I || rt(F)).documentElement === F)
                    return new ie;
                var H = Dt(F)
                  , G = Fn(F)
                  , ce = G ? xt : Lt
                  , we = ht(F, T)
                  , xe = ce[0].getBoundingClientRect()
                  , oe = ce[1].getBoundingClientRect()
                  , We = ce[2].getBoundingClientRect()
                  , me = we.parentNode
                  , Qe = !M && hn(F)
                  , tt = new ie((oe.left - xe.left) / 100,(oe.top - xe.top) / 100,(We.left - xe.left) / 100,(We.top - xe.top) / 100,xe.left + (Qe ? 0 : fn()),xe.top + (Qe ? 0 : Jt()));
                if (me.removeChild(we),
                H)
                    for (xe = H.length; xe--; )
                        oe = H[xe],
                        oe.scaleX = oe.scaleY = 0,
                        oe.renderTransform(1, oe);
                return b ? tt.inverse() : tt
            }
            /*!
 * MotionPathPlugin 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
            var ke = "x,translateX,left,marginLeft,xPercent".split(","), Fe = "y,translateY,top,marginTop,yPercent".split(","), Ce = Math.PI / 180, $e, Ye, je, vt, ot, Ve, ut = function() {
                return $e || typeof window < "u" && ($e = window.gsap) && $e.registerPlugin && $e
            }, Ft = function(b, T, M, H) {
                for (var G = T.length, ce = H === 2 ? 0 : H, we = 0; we < G; we++)
                    b[ce] = parseFloat(T[we][M]),
                    H === 2 && (b[ce + 1] = 0),
                    ce += 2;
                return b
            }, ft = function(b, T, M) {
                return parseFloat(b._gsap.get(b, T, M || "px")) || 0
            }, gt = function(b) {
                var T = b[0], M = b[1], H;
                for (H = 2; H < b.length; H += 2)
                    T = b[H] += T,
                    M = b[H + 1] += M
            }, et = function(b, T, M, H, G, ce, we, xe, oe) {
                if (we.type === "cubic")
                    T = [T];
                else {
                    we.fromCurrent !== !1 && T.unshift(ft(M, H, xe), G ? ft(M, G, oe) : 0),
                    we.relative && gt(T);
                    var We = G ? Se : ze;
                    T = [We(T, we.curviness)]
                }
                return T = ce(ne(T, M, we)),
                le(b, M, H, T, "x", xe),
                G && le(b, M, G, T, "y", oe),
                mt(T, we.resolution || (we.curviness === 0 ? 20 : 12))
            }, Oe = function(b) {
                return b
            }, O = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g, z = function(b, T, M) {
                var H = _e(b), G = 0, ce = 0, we;
                return (b.tagName + "").toLowerCase() === "svg" ? (we = b.viewBox.baseVal,
                we.width || (we = {
                    width: +b.getAttribute("width"),
                    height: +b.getAttribute("height")
                })) : we = T && b.getBBox && b.getBBox(),
                T && T !== "auto" && (G = T.push ? T[0] * (we ? we.width : b.offsetWidth || 0) : T.x,
                ce = T.push ? T[1] * (we ? we.height : b.offsetHeight || 0) : T.y),
                M.apply(G || ce ? H.apply({
                    x: G,
                    y: ce
                }) : {
                    x: H.e,
                    y: H.f
                })
            }, L = function(b, T, M, H) {
                var G = _e(b.parentNode, !0, !0), ce = G.clone().multiply(_e(T)), we = z(b, M, G), xe = z(T, H, G), oe = xe.x, We = xe.y, me;
                return ce.e = ce.f = 0,
                H === "auto" && T.getTotalLength && T.tagName.toLowerCase() === "path" && (me = T.getAttribute("d").match(O) || [],
                me = ce.apply({
                    x: +me[0],
                    y: +me[1]
                }),
                oe += me.x,
                We += me.y),
                me && (me = ce.apply(T.getBBox()),
                oe -= me.x,
                We -= me.y),
                ce.e = oe - we.x,
                ce.f = We - we.y,
                ce
            }, ne = function(b, T, M) {
                var H = M.align, G = M.matrix, ce = M.offsetX, we = M.offsetY, xe = M.alignOrigin, oe = b[0][0], We = b[0][1], me = ft(T, "x"), Qe = ft(T, "y"), tt, dt, pt;
                return !b || !b.length ? ee("M0,0L0,0") : (H && (H === "self" || (tt = vt(H)[0] || T) === T ? he(b, 1, 0, 0, 1, me - oe, Qe - We) : (xe && xe[2] !== !1 ? $e.set(T, {
                    transformOrigin: xe[0] * 100 + "% " + xe[1] * 100 + "%"
                }) : xe = [ft(T, "xPercent") / -100, ft(T, "yPercent") / -100],
                dt = L(T, tt, xe, "auto"),
                pt = dt.apply({
                    x: oe,
                    y: We
                }),
                he(b, dt.a, dt.b, dt.c, dt.d, me + dt.e - (pt.x - dt.e), Qe + dt.f - (pt.y - dt.f)))),
                G ? he(b, G.a, G.b, G.c, G.d, G.e, G.f) : (ce || we) && he(b, 1, 0, 0, 1, ce || 0, we || 0),
                b)
            }, le = function(b, T, M, H, G, ce) {
                var we = T._gsap
                  , xe = we.harness
                  , oe = xe && xe.aliases && xe.aliases[M]
                  , We = oe && oe.indexOf(",") < 0 ? oe : M
                  , me = b._pt = new Ye(b._pt,T,We,0,0,Oe,0,we.set(T, We, b));
                me.u = je(we.get(T, We, ce)) || 0,
                me.path = H,
                me.pp = G,
                b._props.push(We)
            }, Ie = function(b, T) {
                return function(M) {
                    return b || T !== 1 ? qe(M, b, T) : M
                }
            }, ct = {
                version: "3.13.0",
                name: "motionPath",
                register: function(b, T, M) {
                    $e = b,
                    je = $e.utils.getUnit,
                    vt = $e.utils.toArray,
                    ot = $e.core.getStyleSaver,
                    Ve = $e.core.reverting || function() {}
                    ,
                    Ye = M
                },
                init: function(b, T, M) {
                    if (!$e)
                        return console.warn("Please gsap.registerPlugin(MotionPathPlugin)"),
                        !1;
                    (!(typeof T == "object" && !T.style) || !T.path) && (T = {
                        path: T
                    });
                    var H = [], G = T, ce = G.path, we = G.autoRotate, xe = G.unitX, oe = G.unitY, We = G.x, me = G.y, Qe = ce[0], tt = Ie(T.start, "end"in T ? T.end : 1), dt, pt;
                    if (this.rawPaths = H,
                    this.target = b,
                    this.tween = M,
                    this.styles = ot && ot(b, "transform"),
                    (this.rotate = we || we === 0) && (this.rOffset = parseFloat(we) || 0,
                    this.radians = !!T.useRadians,
                    this.rProp = T.rotation || "rotation",
                    this.rSet = b._gsap.set(b, this.rProp, this),
                    this.ru = je(b._gsap.get(b, this.rProp)) || 0),
                    Array.isArray(ce) && !("closed"in ce) && typeof Qe != "number") {
                        for (pt in Qe)
                            !We && ~ke.indexOf(pt) ? We = pt : !me && ~Fe.indexOf(pt) && (me = pt);
                        We && me ? H.push(et(this, Ft(Ft([], ce, We, 0), ce, me, 1), b, We, me, tt, T, xe || je(ce[0][We]), oe || je(ce[0][me]))) : We = me = 0;
                        for (pt in Qe)
                            pt !== We && pt !== me && H.push(et(this, Ft([], ce, pt, 2), b, pt, 0, tt, T, je(ce[0][pt])))
                    } else
                        dt = tt(ne(ee(T.path), b, T)),
                        mt(dt, T.resolution),
                        H.push(dt),
                        le(this, b, T.x || "x", dt, "x", T.unitX || "px"),
                        le(this, b, T.y || "y", dt, "y", T.unitY || "px");
                    M.vars.immediateRender && this.render(M.progress(), this)
                },
                render: function(b, T) {
                    var M = T.rawPaths
                      , H = M.length
                      , G = T._pt;
                    if (T.tween._time || !Ve()) {
                        for (b > 1 ? b = 1 : b < 0 && (b = 0); H--; )
                            Tt(M[H], b, !H && T.rotate, M[H]);
                        for (; G; )
                            G.set(G.t, G.p, G.path[G.pp] + G.u, G.d, b),
                            G = G._next;
                        T.rotate && T.rSet(T.target, T.rProp, M[0].angle * (T.radians ? Ce : 1) + T.rOffset + T.ru, T, b)
                    } else
                        T.styles.revert()
                },
                getLength: function(b) {
                    return mt(ee(b)).totalLength
                },
                sliceRawPath: qe,
                getRawPath: ee,
                pointsToSegment: Se,
                stringToRawPath: ae,
                rawPathToString: Je,
                transformRawPath: he,
                getGlobalMatrix: _e,
                getPositionOnPath: Tt,
                cacheRawPathMeasurements: mt,
                convertToPath: function(b, T) {
                    return vt(b).map(function(M) {
                        return ye(M, T !== !1)
                    })
                },
                convertCoordinates: function(b, T, M) {
                    var H = _e(T, !0, !0).multiply(_e(b));
                    return M ? H.apply(M) : H
                },
                getAlignMatrix: L,
                getRelativePosition: function(b, T, M, H) {
                    var G = L(b, T, M, H);
                    return {
                        x: G.e,
                        y: G.f
                    }
                },
                arrayToRawPath: function(b, T) {
                    T = T || {};
                    var M = Ft(Ft([], b, T.x || "x", 0), b, T.y || "y", 1);
                    return T.relative && gt(M),
                    [T.type === "cubic" ? M : Se(M, T.curviness)]
                }
            };
            ut() && $e.registerPlugin(ct),
            n.MotionPathPlugin = ct,
            n.default = ct,
            Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(zl, zl.exports)),
    zl.exports
}
var HT = BT();
const VT = la(HT);
var Ul = {
    exports: {}
}, jT = Ul.exports, Cg;
function zT() {
    return Cg || (Cg = 1,
    function(e, t) {
        (function(n, r) {
            r(t)
        }
        )(jT, function(n) {
            var r, i, s, o, l, u, p, h, g = "transform", m = g + "Origin", w, E = function(O) {
                var z = O.ownerDocument || O;
                for (!(g in O.style) && ("msTransform"in O.style) && (g = "msTransform",
                m = g + "Origin"); z.parentNode && (z = z.parentNode); )
                    ;
                if (i = window,
                p = new J,
                z) {
                    r = z,
                    s = z.documentElement,
                    o = z.body,
                    h = r.createElementNS("http://www.w3.org/2000/svg", "g"),
                    h.style.transform = "none";
                    var L = z.createElement("div")
                      , ne = z.createElement("div")
                      , le = z && (z.body || z.firstElementChild);
                    le && le.appendChild && (le.appendChild(L),
                    L.appendChild(ne),
                    L.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"),
                    w = ne.offsetParent !== L,
                    le.removeChild(L))
                }
                return z
            }, y = function(O) {
                for (var z, L; O && O !== o; )
                    L = O._gsap,
                    L && L.uncache && L.get(O, "x"),
                    L && !L.scaleX && !L.scaleY && L.renderTransform && (L.scaleX = L.scaleY = 1e-4,
                    L.renderTransform(1, L),
                    z ? z.push(L) : z = [L]),
                    O = O.parentNode;
                return z
            }, R = [], P = [], x = function() {
                return i.pageYOffset || r.scrollTop || s.scrollTop || o.scrollTop || 0
            }, v = function() {
                return i.pageXOffset || r.scrollLeft || s.scrollLeft || o.scrollLeft || 0
            }, k = function(O) {
                return O.ownerSVGElement || ((O.tagName + "").toLowerCase() === "svg" ? O : null)
            }, S = function Oe(O) {
                if (i.getComputedStyle(O).position === "fixed")
                    return !0;
                if (O = O.parentNode,
                O && O.nodeType === 1)
                    return Oe(O)
            }, W = function Oe(O, z) {
                if (O.parentNode && (r || E(O))) {
                    var L = k(O)
                      , ne = L ? L.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml"
                      , le = L ? z ? "rect" : "g" : "div"
                      , Ie = z !== 2 ? 0 : 100
                      , ct = z === 3 ? 100 : 0
                      , F = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;"
                      , b = r.createElementNS ? r.createElementNS(ne.replace(/^https/, "http"), le) : r.createElement(le);
                    return z && (L ? (u || (u = Oe(O)),
                    b.setAttribute("width", .01),
                    b.setAttribute("height", .01),
                    b.setAttribute("transform", "translate(" + Ie + "," + ct + ")"),
                    u.appendChild(b)) : (l || (l = Oe(O),
                    l.style.cssText = F),
                    b.style.cssText = F + "width:0.1px;height:0.1px;top:" + ct + "px;left:" + Ie + "px",
                    l.appendChild(b))),
                    b
                }
                throw "Need document and parent."
            }, K = function(O) {
                for (var z = new J, L = 0; L < O.numberOfItems; L++)
                    z.multiply(O.getItem(L).matrix);
                return z
            }, be = function(O) {
                var z = O.getCTM(), L;
                return z || (L = O.style[g],
                O.style[g] = "none",
                O.appendChild(h),
                z = h.getCTM(),
                O.removeChild(h),
                L ? O.style[g] = L : O.style.removeProperty(g.replace(/([A-Z])/g, "-$1").toLowerCase())),
                z || p.clone()
            }, fe = function(O, z) {
                var L = k(O), ne = O === L, le = L ? R : P, Ie = O.parentNode, ct = Ie && !L && Ie.shadowRoot && Ie.shadowRoot.appendChild ? Ie.shadowRoot : Ie, F, b, T, M, H, G;
                if (O === i)
                    return O;
                if (le.length || le.push(W(O, 1), W(O, 2), W(O, 3)),
                F = L ? u : l,
                L)
                    ne ? (T = be(O),
                    M = -T.e / T.a,
                    H = -T.f / T.d,
                    b = p) : O.getBBox ? (T = O.getBBox(),
                    b = O.transform ? O.transform.baseVal : {},
                    b = b.numberOfItems ? b.numberOfItems > 1 ? K(b) : b.getItem(0).matrix : p,
                    M = b.a * T.x + b.c * T.y,
                    H = b.b * T.x + b.d * T.y) : (b = new J,
                    M = H = 0),
                    z && O.tagName.toLowerCase() === "g" && (M = H = 0),
                    (ne ? L : Ie).appendChild(F),
                    F.setAttribute("transform", "matrix(" + b.a + "," + b.b + "," + b.c + "," + b.d + "," + (b.e + M) + "," + (b.f + H) + ")");
                else {
                    if (M = H = 0,
                    w)
                        for (b = O.offsetParent,
                        T = O; T && (T = T.parentNode) && T !== b && T.parentNode; )
                            (i.getComputedStyle(T)[g] + "").length > 4 && (M = T.offsetLeft,
                            H = T.offsetTop,
                            T = 0);
                    if (G = i.getComputedStyle(O),
                    G.position !== "absolute" && G.position !== "fixed")
                        for (b = O.offsetParent; Ie && Ie !== b; )
                            M += Ie.scrollLeft || 0,
                            H += Ie.scrollTop || 0,
                            Ie = Ie.parentNode;
                    T = F.style,
                    T.top = O.offsetTop - H + "px",
                    T.left = O.offsetLeft - M + "px",
                    T[g] = G[g],
                    T[m] = G[m],
                    T.position = G.position === "fixed" ? "fixed" : "absolute",
                    ct.appendChild(F)
                }
                return F
            }, ge = function(O, z, L, ne, le, Ie, ct) {
                return O.a = z,
                O.b = L,
                O.c = ne,
                O.d = le,
                O.e = Ie,
                O.f = ct,
                O
            }, J = function() {
                function Oe(z, L, ne, le, Ie, ct) {
                    z === void 0 && (z = 1),
                    L === void 0 && (L = 0),
                    ne === void 0 && (ne = 0),
                    le === void 0 && (le = 1),
                    Ie === void 0 && (Ie = 0),
                    ct === void 0 && (ct = 0),
                    ge(this, z, L, ne, le, Ie, ct)
                }
                var O = Oe.prototype;
                return O.inverse = function() {
                    var L = this.a
                      , ne = this.b
                      , le = this.c
                      , Ie = this.d
                      , ct = this.e
                      , F = this.f
                      , b = L * Ie - ne * le || 1e-10;
                    return ge(this, Ie / b, -ne / b, -le / b, L / b, (le * F - Ie * ct) / b, -(L * F - ne * ct) / b)
                }
                ,
                O.multiply = function(L) {
                    var ne = this.a
                      , le = this.b
                      , Ie = this.c
                      , ct = this.d
                      , F = this.e
                      , b = this.f
                      , T = L.a
                      , M = L.c
                      , H = L.b
                      , G = L.d
                      , ce = L.e
                      , we = L.f;
                    return ge(this, T * ne + H * Ie, T * le + H * ct, M * ne + G * Ie, M * le + G * ct, F + ce * ne + we * Ie, b + ce * le + we * ct)
                }
                ,
                O.clone = function() {
                    return new Oe(this.a,this.b,this.c,this.d,this.e,this.f)
                }
                ,
                O.equals = function(L) {
                    var ne = this.a
                      , le = this.b
                      , Ie = this.c
                      , ct = this.d
                      , F = this.e
                      , b = this.f;
                    return ne === L.a && le === L.b && Ie === L.c && ct === L.d && F === L.e && b === L.f
                }
                ,
                O.apply = function(L, ne) {
                    ne === void 0 && (ne = {});
                    var le = L.x
                      , Ie = L.y
                      , ct = this.a
                      , F = this.b
                      , b = this.c
                      , T = this.d
                      , M = this.e
                      , H = this.f;
                    return ne.x = le * ct + Ie * b + M || 0,
                    ne.y = le * F + Ie * T + H || 0,
                    ne
                }
                ,
                Oe
            }();
            function re(Oe, O, z, L) {
                if (!Oe || !Oe.parentNode || (r || E(Oe)).documentElement === Oe)
                    return new J;
                var ne = y(Oe)
                  , le = k(Oe)
                  , Ie = le ? R : P
                  , ct = fe(Oe, z)
                  , F = Ie[0].getBoundingClientRect()
                  , b = Ie[1].getBoundingClientRect()
                  , T = Ie[2].getBoundingClientRect()
                  , M = ct.parentNode
                  , H = !L && S(Oe)
                  , G = new J((b.left - F.left) / 100,(b.top - F.top) / 100,(T.left - F.left) / 100,(T.top - F.top) / 100,F.left + (H ? 0 : v()),F.top + (H ? 0 : x()));
                if (M.removeChild(ct),
                ne)
                    for (F = ne.length; F--; )
                        b = ne[F],
                        b.scaleX = b.scaleY = 0,
                        b.renderTransform(1, b);
                return O ? G.inverse() : G
            }
            /*!
 * Flip 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
            var ee = 1, Y, Z, Q, ue, se, ye, Ze, qe = function(O, z) {
                return O.actions.forEach(function(L) {
                    return L.vars[z] && L.vars[z](L)
                })
            }, nt = {}, mt = 180 / Math.PI, yt = Math.PI / 180, At = {}, Tt = {}, he = {}, ve = function(O) {
                return typeof O == "string" ? O.split(" ").join("").split(",") : O
            }, ae = ve("onStart,onUpdate,onComplete,onReverseComplete,onInterrupt"), ze = ve("transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight"), Se = function(O) {
                return Y(O)[0] || console.warn("Element not found:", O)
            }, Je = function(O) {
                return Math.round(O * 1e4) / 1e4 || 0
            }, I = function(O, z, L) {
                return O.forEach(function(ne) {
                    return ne.classList[L](z)
                })
            }, $ = {
                zIndex: 1,
                kill: 1,
                simple: 1,
                spin: 1,
                clearProps: 1,
                targets: 1,
                toggleClass: 1,
                onComplete: 1,
                onUpdate: 1,
                onInterrupt: 1,
                onStart: 1,
                delay: 1,
                repeat: 1,
                repeatDelay: 1,
                yoyo: 1,
                scale: 1,
                fade: 1,
                absolute: 1,
                props: 1,
                onEnter: 1,
                onLeave: 1,
                custom: 1,
                paused: 1,
                nested: 1,
                prune: 1,
                absoluteOnLeave: 1
            }, de = {
                zIndex: 1,
                simple: 1,
                clearProps: 1,
                scale: 1,
                absolute: 1,
                fitChild: 1,
                getVars: 1,
                props: 1
            }, Me = function(O) {
                return O.replace(/([A-Z])/g, "-$1").toLowerCase()
            }, Te = function(O, z) {
                var L = {}, ne;
                for (ne in O)
                    z[ne] || (L[ne] = O[ne]);
                return L
            }, Ne = {}, lt = function(O) {
                var z = Ne[O] = ve(O);
                return he[O] = z.concat(ze),
                z
            }, st = function(O) {
                var z = O._gsap || Z.core.getCache(O);
                return z.gmCache === Z.ticker.frame ? z.gMatrix : (z.gmCache = Z.ticker.frame,
                z.gMatrix = re(O, !0, !1, !0))
            }, Ue = function Oe(O, z, L) {
                L === void 0 && (L = 0);
                for (var ne = O.parentNode, le = 1e3 * Math.pow(10, L) * (z ? -1 : 1), Ie = z ? -le * 900 : 0; O; )
                    Ie += le,
                    O = O.previousSibling;
                return ne ? Ie + Oe(ne, z, L + 1) : Ie
            }, Ge = function(O, z, L) {
                return O.forEach(function(ne) {
                    return ne.d = Ue(L ? ne.element : ne.t, z)
                }),
                O.sort(function(ne, le) {
                    return ne.d - le.d
                }),
                O
            }, wt = function(O, z) {
                for (var L = O.element.style, ne = O.css = O.css || [], le = z.length, Ie, ct; le--; )
                    Ie = z[le],
                    ct = L[Ie] || L.getPropertyValue(Ie),
                    ne.push(ct ? Ie : Tt[Ie] || (Tt[Ie] = Me(Ie)), ct);
                return L
            }, rt = function(O) {
                var z = O.css
                  , L = O.element.style
                  , ne = 0;
                for (O.cache.uncache = 1; ne < z.length; ne += 2)
                    z[ne + 1] ? L[z[ne]] = z[ne + 1] : L.removeProperty(z[ne]);
                !z[z.indexOf("transform") + 1] && L.translate && (L.removeProperty("translate"),
                L.removeProperty("scale"),
                L.removeProperty("rotate"))
            }, Dt = function(O, z) {
                O.forEach(function(L) {
                    return L.a.cache.uncache = 1
                }),
                z || O.finalStates.forEach(rt)
            }, xt = "paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition".split(","), Lt = function(O, z, L) {
                var ne = O.element, le = O.width, Ie = O.height, ct = O.uncache, F = O.getProp, b = ne.style, T = 4, M, H, G;
                if (typeof z != "object" && (z = O),
                Q && L !== 1)
                    return Q._abs.push({
                        t: ne,
                        b: O,
                        a: O,
                        sd: 0
                    }),
                    Q._final.push(function() {
                        return (O.cache.uncache = 1) && rt(O)
                    }),
                    ne;
                for (H = F("display") === "none",
                (!O.isVisible || H) && (H && (wt(O, ["display"]).display = z.display),
                O.matrix = z.matrix,
                O.width = le = O.width || z.width,
                O.height = Ie = O.height || z.height),
                wt(O, xt),
                G = window.getComputedStyle(ne); T--; )
                    b[xt[T]] = G[xt[T]];
                if (b.gridArea = "1 / 1 / 1 / 1",
                b.transition = "none",
                b.position = "absolute",
                b.width = le + "px",
                b.height = Ie + "px",
                b.top || (b.top = "0px"),
                b.left || (b.left = "0px"),
                ct)
                    M = new Ft(ne);
                else if (M = Te(O, At),
                M.position = "absolute",
                O.simple) {
                    var ce = ne.getBoundingClientRect();
                    M.matrix = new J(1,0,0,1,ce.left + v(),ce.top + x())
                } else
                    M.matrix = re(ne, !1, !1, !0);
                return M = ie(M, O, !0),
                O.x = ye(M.x, .01),
                O.y = ye(M.y, .01),
                ne
            }, Jt = function(O, z) {
                return z !== !0 && (z = Y(z),
                O = O.filter(function(L) {
                    if (z.indexOf((L.sd < 0 ? L.b : L.a).element) !== -1)
                        return !0;
                    L.t._gsap.renderTransform(1),
                    L.b.isVisible && (L.t.style.width = L.b.width + "px",
                    L.t.style.height = L.b.height + "px")
                })),
                O
            }, fn = function(O) {
                return Ge(O, !0).forEach(function(z) {
                    return (z.a.isVisible || z.b.isVisible) && Lt(z.sd < 0 ? z.b : z.a, z.b, 1)
                })
            }, Fn = function(O, z) {
                return z && O.idLookup[hn(z).id] || O.elementStates[0]
            }, hn = function(O, z, L, ne) {
                return O instanceof Ft ? O : O instanceof ut ? Fn(O, ne) : new Ft(typeof O == "string" ? Se(O) || console.warn(O + " not found") : O,z,L)
            }, Ln = function(O, z) {
                for (var L = Z.getProperty(O.element, null, "native"), ne = O.props = {}, le = z.length; le--; )
                    ne[z[le]] = (L(z[le]) + "").trim();
                return ne.zIndex && (ne.zIndex = parseFloat(ne.zIndex) || 0),
                O
            }, Kn = function(O, z) {
                var L = O.style || O, ne;
                for (ne in z)
                    L[ne] = z[ne]
            }, lr = function(O) {
                var z = O.getAttribute("data-flip-id");
                return z || O.setAttribute("data-flip-id", z = "auto-" + ee++),
                z
            }, ht = function(O) {
                return O.map(function(z) {
                    return z.element
                })
            }, X = function(O, z, L) {
                return O && z.length && L.add(O(ht(z), L, new ut(z,0,!0)), 0)
            }, ie = function(O, z, L, ne, le, Ie) {
                var ct = O.element, F = O.cache, b = O.parent, T = O.x, M = O.y, H = z.width, G = z.height, ce = z.scaleX, we = z.scaleY, xe = z.rotation, oe = z.bounds, We = Ie && Ze && Ze(ct, "transform,width,height"), me = O, Qe = z.matrix, tt = Qe.e, dt = Qe.f, pt = O.bounds.width !== oe.width || O.bounds.height !== oe.height || O.scaleX !== ce || O.scaleY !== we || O.rotation !== xe, jt = !pt && O.simple && z.simple && !le, Nt, Pt, Bt, $t, nn, Zt, Yt;
                return jt || !b ? (ce = we = 1,
                xe = Nt = 0) : (nn = st(b),
                Zt = nn.clone().multiply(z.ctm ? z.matrix.clone().multiply(z.ctm) : z.matrix),
                xe = Je(Math.atan2(Zt.b, Zt.a) * mt),
                Nt = Je(Math.atan2(Zt.c, Zt.d) * mt + xe) % 360,
                ce = Math.sqrt(Math.pow(Zt.a, 2) + Math.pow(Zt.b, 2)),
                we = Math.sqrt(Math.pow(Zt.c, 2) + Math.pow(Zt.d, 2)) * Math.cos(Nt * yt),
                le && (le = Y(le)[0],
                $t = Z.getProperty(le),
                Yt = le.getBBox && typeof le.getBBox == "function" && le.getBBox(),
                me = {
                    scaleX: $t("scaleX"),
                    scaleY: $t("scaleY"),
                    width: Yt ? Yt.width : Math.ceil(parseFloat($t("width", "px"))),
                    height: Yt ? Yt.height : parseFloat($t("height", "px"))
                }),
                F.rotation = xe + "deg",
                F.skewX = Nt + "deg"),
                L ? (ce *= H === me.width || !me.width ? 1 : H / me.width,
                we *= G === me.height || !me.height ? 1 : G / me.height,
                F.scaleX = ce,
                F.scaleY = we) : (H = ye(H * ce / me.scaleX, 0),
                G = ye(G * we / me.scaleY, 0),
                ct.style.width = H + "px",
                ct.style.height = G + "px"),
                ne && Kn(ct, z.props),
                jt || !b ? (T += tt - O.matrix.e,
                M += dt - O.matrix.f) : pt || b !== z.parent ? (F.renderTransform(1, F),
                Zt = re(le || ct, !1, !1, !0),
                Pt = nn.apply({
                    x: Zt.e,
                    y: Zt.f
                }),
                Bt = nn.apply({
                    x: tt,
                    y: dt
                }),
                T += Bt.x - Pt.x,
                M += Bt.y - Pt.y) : (nn.e = nn.f = 0,
                Bt = nn.apply({
                    x: tt - O.matrix.e,
                    y: dt - O.matrix.f
                }),
                T += Bt.x,
                M += Bt.y),
                T = ye(T, .02),
                M = ye(M, .02),
                Ie && !(Ie instanceof Ft) ? We && We.revert() : (F.x = T + "px",
                F.y = M + "px",
                F.renderTransform(1, F)),
                Ie && (Ie.x = T,
                Ie.y = M,
                Ie.rotation = xe,
                Ie.skewX = Nt,
                L ? (Ie.scaleX = ce,
                Ie.scaleY = we) : (Ie.width = H,
                Ie.height = G)),
                Ie || F
            }, _e = function(O, z) {
                return O instanceof ut ? O : new ut(O,z)
            }, ke = function(O, z, L) {
                var ne = O.idLookup[L]
                  , le = O.alt[L];
                return le.isVisible && (!(z.getElementState(le.element) || le).isVisible || !ne.isVisible) ? le : ne
            }, Fe = [], Ce = "width,height,overflowX,overflowY".split(","), $e, Ye = function(O) {
                if (O !== $e) {
                    var z = se.style
                      , L = se.clientWidth === window.outerWidth
                      , ne = se.clientHeight === window.outerHeight
                      , le = 4;
                    if (O && (L || ne)) {
                        for (; le--; )
                            Fe[le] = z[Ce[le]];
                        L && (z.width = se.clientWidth + "px",
                        z.overflowY = "hidden"),
                        ne && (z.height = se.clientHeight + "px",
                        z.overflowX = "hidden"),
                        $e = O
                    } else if ($e) {
                        for (; le--; )
                            Fe[le] ? z[Ce[le]] = Fe[le] : z.removeProperty(Me(Ce[le]));
                        $e = O
                    }
                }
            }, je = function(O, z, L, ne) {
                O instanceof ut && z instanceof ut || console.warn("Not a valid state object."),
                L = L || {};
                var le = L, Ie = le.clearProps, ct = le.onEnter, F = le.onLeave, b = le.absolute, T = le.absoluteOnLeave, M = le.custom, H = le.delay, G = le.paused, ce = le.repeat, we = le.repeatDelay, xe = le.yoyo, oe = le.toggleClass, We = le.nested, me = le.zIndex, Qe = le.scale, tt = le.fade, dt = le.stagger, pt = le.spin, jt = le.prune, Nt = ("props"in L ? L : O).props, Pt = Te(L, $), Bt = Z.timeline({
                    delay: H,
                    paused: G,
                    repeat: ce,
                    repeatDelay: we,
                    yoyo: xe,
                    data: "isFlip"
                }), $t = Pt, nn = [], Zt = [], Yt = [], ln = [], pn = pt === !0 ? 1 : pt || 0, Vr = typeof pt == "function" ? pt : function() {
                    return pn
                }
                , ur = O.interrupted || z.interrupted, br = Bt[ne !== 1 ? "to" : "from"], wr, Pr, cr, fr, qn, $n, Xn, en, Mr, hi, _r, Fi, Gn, Qn;
                for (Pr in z.idLookup)
                    _r = z.alt[Pr] ? ke(z, O, Pr) : z.idLookup[Pr],
                    qn = _r.element,
                    hi = O.idLookup[Pr],
                    O.alt[Pr] && qn === hi.element && (O.alt[Pr].isVisible || !_r.isVisible) && (hi = O.alt[Pr]),
                    hi ? ($n = {
                        t: qn,
                        b: hi,
                        a: _r,
                        sd: hi.element === qn ? 0 : _r.isVisible ? 1 : -1
                    },
                    Yt.push($n),
                    $n.sd && ($n.sd < 0 && ($n.b = _r,
                    $n.a = hi),
                    ur && wt($n.b, Nt ? he[Nt] : ze),
                    tt && Yt.push($n.swap = {
                        t: hi.element,
                        b: $n.b,
                        a: $n.a,
                        sd: -$n.sd,
                        swap: $n
                    })),
                    qn._flip = hi.element._flip = Q ? Q.timeline : Bt) : _r.isVisible && (Yt.push({
                        t: qn,
                        b: Te(_r, {
                            isVisible: 1
                        }),
                        a: _r,
                        sd: 0,
                        entering: 1
                    }),
                    qn._flip = Q ? Q.timeline : Bt);
                if (Nt && (Ne[Nt] || lt(Nt)).forEach(function(Jr) {
                    return Pt[Jr] = function(Pn) {
                        return Yt[Pn].a.props[Jr]
                    }
                }),
                Yt.finalStates = Mr = [],
                Fi = function() {
                    for (Ge(Yt),
                    Ye(!0),
                    fr = 0; fr < Yt.length; fr++)
                        $n = Yt[fr],
                        Gn = $n.a,
                        Qn = $n.b,
                        jt && !Gn.isDifferent(Qn) && !$n.entering ? Yt.splice(fr--, 1) : (qn = $n.t,
                        We && !($n.sd < 0) && fr && (Gn.matrix = re(qn, !1, !1, !0)),
                        Qn.isVisible && Gn.isVisible ? ($n.sd < 0 ? (Xn = new Ft(qn,Nt,O.simple),
                        ie(Xn, Gn, Qe, 0, 0, Xn),
                        Xn.matrix = re(qn, !1, !1, !0),
                        Xn.css = $n.b.css,
                        $n.a = Gn = Xn,
                        tt && (qn.style.opacity = ur ? Qn.opacity : Gn.opacity),
                        dt && ln.push(qn)) : $n.sd > 0 && tt && (qn.style.opacity = ur ? Gn.opacity - Qn.opacity : "0"),
                        ie(Gn, Qn, Qe, Nt)) : Qn.isVisible !== Gn.isVisible && (Qn.isVisible ? Gn.isVisible || (Qn.css = Gn.css,
                        Zt.push(Qn),
                        Yt.splice(fr--, 1),
                        b && We && ie(Gn, Qn, Qe, Nt)) : (Gn.isVisible && nn.push(Gn),
                        Yt.splice(fr--, 1))),
                        Qe || (qn.style.maxWidth = Math.max(Gn.width, Qn.width) + "px",
                        qn.style.maxHeight = Math.max(Gn.height, Qn.height) + "px",
                        qn.style.minWidth = Math.min(Gn.width, Qn.width) + "px",
                        qn.style.minHeight = Math.min(Gn.height, Qn.height) + "px"),
                        We && oe && qn.classList.add(oe)),
                        Mr.push(Gn);
                    var Pn;
                    if (oe && (Pn = Mr.map(function(xn) {
                        return xn.element
                    }),
                    We && Pn.forEach(function(xn) {
                        return xn.classList.remove(oe)
                    })),
                    Ye(!1),
                    Qe ? (Pt.scaleX = function(xn) {
                        return Yt[xn].a.scaleX
                    }
                    ,
                    Pt.scaleY = function(xn) {
                        return Yt[xn].a.scaleY
                    }
                    ) : (Pt.width = function(xn) {
                        return Yt[xn].a.width + "px"
                    }
                    ,
                    Pt.height = function(xn) {
                        return Yt[xn].a.height + "px"
                    }
                    ,
                    Pt.autoRound = L.autoRound || !1),
                    Pt.x = function(xn) {
                        return Yt[xn].a.x + "px"
                    }
                    ,
                    Pt.y = function(xn) {
                        return Yt[xn].a.y + "px"
                    }
                    ,
                    Pt.rotation = function(xn) {
                        return Yt[xn].a.rotation + (pt ? Vr(xn, en[xn], en) * 360 : 0)
                    }
                    ,
                    Pt.skewX = function(xn) {
                        return Yt[xn].a.skewX
                    }
                    ,
                    en = Yt.map(function(xn) {
                        return xn.t
                    }),
                    (me || me === 0) && (Pt.modifiers = {
                        zIndex: function() {
                            return me
                        }
                    },
                    Pt.zIndex = me,
                    Pt.immediateRender = L.immediateRender !== !1),
                    tt && (Pt.opacity = function(xn) {
                        return Yt[xn].sd < 0 ? 0 : Yt[xn].sd > 0 ? Yt[xn].a.opacity : "+=0"
                    }
                    ),
                    ln.length) {
                        dt = Z.utils.distribute(dt);
                        var Ms = en.slice(ln.length);
                        Pt.stagger = function(xn, Gs) {
                            return dt(~ln.indexOf(Gs) ? en.indexOf(Yt[xn].swap.t) : xn, Gs, Ms)
                        }
                    }
                    if (ae.forEach(function(xn) {
                        return L[xn] && Bt.eventCallback(xn, L[xn], L[xn + "Params"])
                    }),
                    M && en.length) {
                        $t = Te(Pt, $),
                        "scale"in M && (M.scaleX = M.scaleY = M.scale,
                        delete M.scale);
                        for (Pr in M)
                            wr = Te(M[Pr], de),
                            wr[Pr] = Pt[Pr],
                            !("duration"in wr) && "duration"in Pt && (wr.duration = Pt.duration),
                            wr.stagger = Pt.stagger,
                            br.call(Bt, en, wr, 0),
                            delete $t[Pr]
                    }
                    (en.length || Zt.length || nn.length) && (oe && Bt.add(function() {
                        return I(Pn, oe, Bt._zTime < 0 ? "remove" : "add")
                    }, 0) && !G && I(Pn, oe, "add"),
                    en.length && br.call(Bt, en, $t, 0)),
                    X(ct, nn, Bt),
                    X(F, Zt, Bt);
                    var bn = Q && Q.timeline;
                    bn && (bn.add(Bt, 0),
                    Q._final.push(function() {
                        return Dt(Yt, !Ie)
                    })),
                    cr = Bt.duration(),
                    Bt.call(function() {
                        var xn = Bt.time() >= cr;
                        xn && !bn && Dt(Yt, !Ie),
                        oe && I(Pn, oe, xn ? "remove" : "add")
                    })
                }
                ,
                T && (b = Yt.filter(function(Jr) {
                    return !Jr.sd && !Jr.a.isVisible && Jr.b.isVisible
                }).map(function(Jr) {
                    return Jr.a.element
                })),
                Q) {
                    var Os;
                    b && (Os = Q._abs).push.apply(Os, Jt(Yt, b)),
                    Q._run.push(Fi)
                } else
                    b && fn(Jt(Yt, b)),
                    Fi();
                var gn = Q ? Q.timeline : Bt;
                return gn.revert = function() {
                    return ot(gn, 1, 1)
                }
                ,
                gn
            }, vt = function Oe(O) {
                O.vars.onInterrupt && O.vars.onInterrupt.apply(O, O.vars.onInterruptParams || []),
                O.getChildren(!0, !1, !0).forEach(Oe)
            }, ot = function(O, z, L) {
                if (O && O.progress() < 1 && (!O.paused() || L))
                    return z && (vt(O),
                    z < 2 && O.progress(1),
                    O.kill()),
                    !0
            }, Ve = function(O) {
                for (var z = O.idLookup = {}, L = O.alt = {}, ne = O.elementStates, le = ne.length, Ie; le--; )
                    Ie = ne[le],
                    z[Ie.id] ? L[Ie.id] = Ie : z[Ie.id] = Ie
            }, ut = function() {
                function Oe(z, L, ne) {
                    if (this.props = L && L.props,
                    this.simple = !!(L && L.simple),
                    ne)
                        this.targets = ht(z),
                        this.elementStates = z,
                        Ve(this);
                    else {
                        this.targets = Y(z);
                        var le = L && (L.kill === !1 || L.batch && !L.kill);
                        Q && !le && Q._kill.push(this),
                        this.update(le || !!Q)
                    }
                }
                var O = Oe.prototype;
                return O.update = function(L) {
                    var ne = this;
                    return this.elementStates = this.targets.map(function(le) {
                        return new Ft(le,ne.props,ne.simple)
                    }),
                    Ve(this),
                    this.interrupt(L),
                    this.recordInlineStyles(),
                    this
                }
                ,
                O.clear = function() {
                    return this.targets.length = this.elementStates.length = 0,
                    Ve(this),
                    this
                }
                ,
                O.fit = function(L, ne, le) {
                    for (var Ie = Ge(this.elementStates.slice(0), !1, !0), ct = (L || this).idLookup, F = 0, b, T; F < Ie.length; F++)
                        b = Ie[F],
                        le && (b.matrix = re(b.element, !1, !1, !0)),
                        T = ct[b.id],
                        T && ie(b, T, ne, !0, 0, b),
                        b.matrix = re(b.element, !1, !1, !0);
                    return this
                }
                ,
                O.getProperty = function(L, ne) {
                    var le = this.getElementState(L) || At;
                    return (ne in le ? le : le.props || At)[ne]
                }
                ,
                O.add = function(L) {
                    for (var ne = L.targets.length, le = this.idLookup, Ie = this.alt, ct, F, b; ne--; )
                        F = L.elementStates[ne],
                        b = le[F.id],
                        b && (F.element === b.element || Ie[F.id] && Ie[F.id].element === F.element) ? (ct = this.elementStates.indexOf(F.element === b.element ? b : Ie[F.id]),
                        this.targets.splice(ct, 1, L.targets[ne]),
                        this.elementStates.splice(ct, 1, F)) : (this.targets.push(L.targets[ne]),
                        this.elementStates.push(F));
                    return L.interrupted && (this.interrupted = !0),
                    L.simple || (this.simple = !1),
                    Ve(this),
                    this
                }
                ,
                O.compare = function(L) {
                    var ne = L.idLookup, le = this.idLookup, Ie = [], ct = [], F = [], b = [], T = [], M = L.alt, H = this.alt, G = function(jt, Nt, Pt) {
                        return (jt.isVisible !== Nt.isVisible ? jt.isVisible ? F : b : jt.isVisible ? ct : Ie).push(Pt) && T.push(Pt)
                    }, ce = function(jt, Nt, Pt) {
                        return T.indexOf(Pt) < 0 && G(jt, Nt, Pt)
                    }, we, xe, oe, We, me, Qe, tt, dt;
                    for (oe in ne)
                        me = M[oe],
                        Qe = H[oe],
                        we = me ? ke(L, this, oe) : ne[oe],
                        We = we.element,
                        xe = le[oe],
                        Qe ? (dt = xe.isVisible || !Qe.isVisible && We === xe.element ? xe : Qe,
                        tt = me && !we.isVisible && !me.isVisible && dt.element === me.element ? me : we,
                        tt.isVisible && dt.isVisible && tt.element !== dt.element ? ((tt.isDifferent(dt) ? ct : Ie).push(tt.element, dt.element),
                        T.push(tt.element, dt.element)) : G(tt, dt, tt.element),
                        me && tt.element === me.element && (me = ne[oe]),
                        ce(tt.element !== xe.element && me ? me : tt, xe, xe.element),
                        ce(me && me.element === Qe.element ? me : tt, Qe, Qe.element),
                        me && ce(me, Qe.element === me.element ? Qe : xe, me.element)) : (xe ? xe.isDifferent(we) ? G(we, xe, We) : Ie.push(We) : F.push(We),
                        me && ce(me, xe, me.element));
                    for (oe in le)
                        ne[oe] || (b.push(le[oe].element),
                        H[oe] && b.push(H[oe].element));
                    return {
                        changed: ct,
                        unchanged: Ie,
                        enter: F,
                        leave: b
                    }
                }
                ,
                O.recordInlineStyles = function() {
                    for (var L = he[this.props] || ze, ne = this.elementStates.length; ne--; )
                        wt(this.elementStates[ne], L)
                }
                ,
                O.interrupt = function(L) {
                    var ne = this
                      , le = [];
                    this.targets.forEach(function(Ie) {
                        var ct = Ie._flip
                          , F = ot(ct, L ? 0 : 1);
                        L && F && le.indexOf(ct) < 0 && ct.add(function() {
                            return ne.updateVisibility()
                        }),
                        F && le.push(ct)
                    }),
                    !L && le.length && this.updateVisibility(),
                    this.interrupted || (this.interrupted = !!le.length)
                }
                ,
                O.updateVisibility = function() {
                    this.elementStates.forEach(function(L) {
                        var ne = L.element.getBoundingClientRect();
                        L.isVisible = !!(ne.width || ne.height || ne.top || ne.left),
                        L.uncache = 1
                    })
                }
                ,
                O.getElementState = function(L) {
                    return this.elementStates[this.targets.indexOf(Se(L))]
                }
                ,
                O.makeAbsolute = function() {
                    return Ge(this.elementStates.slice(0), !0, !0).map(Lt)
                }
                ,
                Oe
            }(), Ft = function() {
                function Oe(z, L, ne) {
                    this.element = z,
                    this.update(L, ne)
                }
                var O = Oe.prototype;
                return O.isDifferent = function(L) {
                    var ne = this.bounds
                      , le = L.bounds;
                    return ne.top !== le.top || ne.left !== le.left || ne.width !== le.width || ne.height !== le.height || !this.matrix.equals(L.matrix) || this.opacity !== L.opacity || this.props && L.props && JSON.stringify(this.props) !== JSON.stringify(L.props)
                }
                ,
                O.update = function(L, ne) {
                    var le = this
                      , Ie = le.element
                      , ct = Z.getProperty(Ie)
                      , F = Z.core.getCache(Ie)
                      , b = Ie.getBoundingClientRect()
                      , T = Ie.getBBox && typeof Ie.getBBox == "function" && Ie.nodeName.toLowerCase() !== "svg" && Ie.getBBox()
                      , M = ne ? new J(1,0,0,1,b.left + v(),b.top + x()) : re(Ie, !1, !1, !0);
                    F.uncache = 1,
                    le.getProp = ct,
                    le.element = Ie,
                    le.id = lr(Ie),
                    le.matrix = M,
                    le.cache = F,
                    le.bounds = b,
                    le.isVisible = !!(b.width || b.height || b.left || b.top),
                    le.display = ct("display"),
                    le.position = ct("position"),
                    le.parent = Ie.parentNode,
                    le.x = ct("x"),
                    le.y = ct("y"),
                    le.scaleX = F.scaleX,
                    le.scaleY = F.scaleY,
                    le.rotation = ct("rotation"),
                    le.skewX = ct("skewX"),
                    le.opacity = ct("opacity"),
                    le.width = T ? T.width : ye(ct("width", "px"), .04),
                    le.height = T ? T.height : ye(ct("height", "px"), .04),
                    L && Ln(le, Ne[L] || lt(L)),
                    le.ctm = Ie.getCTM && Ie.nodeName.toLowerCase() === "svg" && be(Ie).inverse(),
                    le.simple = ne || Je(M.a) === 1 && !Je(M.b) && !Je(M.c) && Je(M.d) === 1,
                    le.uncache = 0
                }
                ,
                Oe
            }(), ft = function() {
                function Oe(z, L) {
                    this.vars = z,
                    this.batch = L,
                    this.states = [],
                    this.timeline = L.timeline
                }
                var O = Oe.prototype;
                return O.getStateById = function(L) {
                    for (var ne = this.states.length; ne--; )
                        if (this.states[ne].idLookup[L])
                            return this.states[ne]
                }
                ,
                O.kill = function() {
                    this.batch.remove(this)
                }
                ,
                Oe
            }(), gt = function() {
                function Oe(z) {
                    this.id = z,
                    this.actions = [],
                    this._kill = [],
                    this._final = [],
                    this._abs = [],
                    this._run = [],
                    this.data = {},
                    this.state = new ut,
                    this.timeline = Z.timeline()
                }
                var O = Oe.prototype;
                return O.add = function(L) {
                    var ne = this.actions.filter(function(le) {
                        return le.vars === L
                    });
                    return ne.length ? ne[0] : (ne = new ft(typeof L == "function" ? {
                        animate: L
                    } : L,this),
                    this.actions.push(ne),
                    ne)
                }
                ,
                O.remove = function(L) {
                    var ne = this.actions.indexOf(L);
                    return ne >= 0 && this.actions.splice(ne, 1),
                    this
                }
                ,
                O.getState = function(L) {
                    var ne = this
                      , le = Q
                      , Ie = ue;
                    return Q = this,
                    this.state.clear(),
                    this._kill.length = 0,
                    this.actions.forEach(function(ct) {
                        ct.vars.getState && (ct.states.length = 0,
                        ue = ct,
                        ct.state = ct.vars.getState(ct)),
                        L && ct.states.forEach(function(F) {
                            return ne.state.add(F)
                        })
                    }),
                    ue = Ie,
                    Q = le,
                    this.killConflicts(),
                    this
                }
                ,
                O.animate = function() {
                    var L = this, ne = Q, le = this.timeline, Ie = this.actions.length, ct, F;
                    for (Q = this,
                    le.clear(),
                    this._abs.length = this._final.length = this._run.length = 0,
                    this.actions.forEach(function(b) {
                        b.vars.animate && b.vars.animate(b);
                        var T = b.vars.onEnter, M = b.vars.onLeave, H = b.targets, G, ce;
                        H && H.length && (T || M) && (G = new ut,
                        b.states.forEach(function(we) {
                            return G.add(we)
                        }),
                        ce = G.compare(et.getState(H)),
                        ce.enter.length && T && T(ce.enter),
                        ce.leave.length && M && M(ce.leave))
                    }),
                    fn(this._abs),
                    this._run.forEach(function(b) {
                        return b()
                    }),
                    F = le.duration(),
                    ct = this._final.slice(0),
                    le.add(function() {
                        F <= le.time() && (ct.forEach(function(b) {
                            return b()
                        }),
                        qe(L, "onComplete"))
                    }),
                    Q = ne; Ie--; )
                        this.actions[Ie].vars.once && this.actions[Ie].kill();
                    return qe(this, "onStart"),
                    le.restart(),
                    this
                }
                ,
                O.loadState = function(L) {
                    L || (L = function() {
                        return 0
                    }
                    );
                    var ne = [];
                    return this.actions.forEach(function(le) {
                        if (le.vars.loadState) {
                            var Ie, ct = function F(b) {
                                b && (le.targets = b),
                                Ie = ne.indexOf(F),
                                ~Ie && (ne.splice(Ie, 1),
                                ne.length || L())
                            };
                            ne.push(ct),
                            le.vars.loadState(ct)
                        }
                    }),
                    ne.length || L(),
                    this
                }
                ,
                O.setState = function() {
                    return this.actions.forEach(function(L) {
                        return L.targets = L.vars.setState && L.vars.setState(L)
                    }),
                    this
                }
                ,
                O.killConflicts = function(L) {
                    return this.state.interrupt(L),
                    this._kill.forEach(function(ne) {
                        return ne.interrupt(L)
                    }),
                    this
                }
                ,
                O.run = function(L, ne) {
                    var le = this;
                    return this !== Q && (L || this.getState(ne),
                    this.loadState(function() {
                        le._killed || (le.setState(),
                        le.animate())
                    })),
                    this
                }
                ,
                O.clear = function(L) {
                    this.state.clear(),
                    L || (this.actions.length = 0)
                }
                ,
                O.getStateById = function(L) {
                    for (var ne = this.actions.length, le; ne--; )
                        if (le = this.actions[ne].getStateById(L),
                        le)
                            return le;
                    return this.state.idLookup[L] && this.state
                }
                ,
                O.kill = function() {
                    this._killed = 1,
                    this.clear(),
                    delete nt[this.id]
                }
                ,
                Oe
            }(), et = function() {
                function Oe() {}
                return Oe.getState = function(z, L) {
                    var ne = _e(z, L);
                    return ue && ue.states.push(ne),
                    L && L.batch && Oe.batch(L.batch).state.add(ne),
                    ne
                }
                ,
                Oe.from = function(z, L) {
                    return L = L || {},
                    "clearProps"in L || (L.clearProps = !0),
                    je(z, _e(L.targets || z.targets, {
                        props: L.props || z.props,
                        simple: L.simple,
                        kill: !!L.kill
                    }), L, -1)
                }
                ,
                Oe.to = function(z, L) {
                    return je(z, _e(L.targets || z.targets, {
                        props: L.props || z.props,
                        simple: L.simple,
                        kill: !!L.kill
                    }), L, 1)
                }
                ,
                Oe.fromTo = function(z, L, ne) {
                    return je(z, L, ne)
                }
                ,
                Oe.fit = function(z, L, ne) {
                    var le = ne ? Te(ne, de) : {}
                      , Ie = ne || le
                      , ct = Ie.absolute
                      , F = Ie.scale
                      , b = Ie.getVars
                      , T = Ie.props
                      , M = Ie.runBackwards
                      , H = Ie.onComplete
                      , G = Ie.simple
                      , ce = ne && ne.fitChild && Se(ne.fitChild)
                      , we = hn(L, T, G, z)
                      , xe = hn(z, 0, G, we)
                      , oe = T ? he[T] : ze
                      , We = Z.context();
                    return T && Kn(le, we.props),
                    wt(xe, oe),
                    M && ("immediateRender"in le || (le.immediateRender = !0),
                    le.onComplete = function() {
                        rt(xe),
                        H && H.apply(this, arguments)
                    }
                    ),
                    ct && Lt(xe, we),
                    le = ie(xe, we, F || ce, !le.duration && T, ce, le.duration || b ? le : 0),
                    typeof ne == "object" && "zIndex"in ne && (le.zIndex = ne.zIndex),
                    We && !b && We.add(function() {
                        return function() {
                            return rt(xe)
                        }
                    }),
                    b ? le : le.duration ? Z.to(xe.element, le) : null
                }
                ,
                Oe.makeAbsolute = function(z, L) {
                    return (z instanceof ut ? z : new ut(z,L)).makeAbsolute()
                }
                ,
                Oe.batch = function(z) {
                    return z || (z = "default"),
                    nt[z] || (nt[z] = new gt(z))
                }
                ,
                Oe.killFlipsOf = function(z, L) {
                    (z instanceof ut ? z.targets : Y(z)).forEach(function(ne) {
                        return ne && ot(ne._flip, L !== !1 ? 1 : 2)
                    })
                }
                ,
                Oe.isFlipping = function(z) {
                    var L = Oe.getByTarget(z);
                    return !!L && L.isActive()
                }
                ,
                Oe.getByTarget = function(z) {
                    return (Se(z) || At)._flip
                }
                ,
                Oe.getElementState = function(z, L) {
                    return new Ft(Se(z),L)
                }
                ,
                Oe.convertCoordinates = function(z, L, ne) {
                    var le = re(L, !0, !0).multiply(re(z));
                    return ne ? le.apply(ne) : le
                }
                ,
                Oe.register = function(z) {
                    if (se = typeof document < "u" && document.body,
                    se) {
                        Z = z,
                        E(se),
                        Y = Z.utils.toArray,
                        Ze = Z.core.getStyleSaver;
                        var L = Z.utils.snap(.1);
                        ye = function(le, Ie) {
                            return L(parseFloat(le) + Ie)
                        }
                    }
                }
                ,
                Oe
            }();
            et.version = "3.13.0",
            typeof window < "u" && window.gsap && window.gsap.registerPlugin(et),
            n.Flip = et,
            n.default = et,
            Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(Ul, Ul.exports)),
    Ul.exports
}
var UT = zT();
const xg = la(UT);
var Wl = {
    exports: {}
}, WT = Wl.exports, Sg;
function qT() {
    return Sg || (Sg = 1,
    function(e, t) {
        (function(n, r) {
            r(t)
        }
        )(WT, function(n) {
            var r = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig
              , i = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig
              , s = Math.PI / 180
              , o = Math.sin
              , l = Math.cos
              , u = Math.abs
              , p = Math.sqrt
              , h = function(Y) {
                return typeof Y == "number"
            }
              , g = 1e5
              , m = function(Y) {
                return Math.round(Y * g) / g || 0
            };
            function w(ee, Y, Z, Q, ue, se, ye) {
                for (var Ze = ee.length, qe, nt, mt, yt, At; --Ze > -1; )
                    for (qe = ee[Ze],
                    nt = qe.length,
                    mt = 0; mt < nt; mt += 2)
                        yt = qe[mt],
                        At = qe[mt + 1],
                        qe[mt] = yt * Y + At * Q + se,
                        qe[mt + 1] = yt * Z + At * ue + ye;
                return ee._dirty = 1,
                ee
            }
            function E(ee, Y, Z, Q, ue, se, ye, Ze, qe) {
                if (!(ee === Ze && Y === qe)) {
                    Z = u(Z),
                    Q = u(Q);
                    var nt = ue % 360 * s
                      , mt = l(nt)
                      , yt = o(nt)
                      , At = Math.PI
                      , Tt = At * 2
                      , he = (ee - Ze) / 2
                      , ve = (Y - qe) / 2
                      , ae = mt * he + yt * ve
                      , ze = -yt * he + mt * ve
                      , Se = ae * ae
                      , Je = ze * ze
                      , I = Se / (Z * Z) + Je / (Q * Q);
                    I > 1 && (Z = p(I) * Z,
                    Q = p(I) * Q);
                    var $ = Z * Z
                      , de = Q * Q
                      , Me = ($ * de - $ * Je - de * Se) / ($ * Je + de * Se);
                    Me < 0 && (Me = 0);
                    var Te = (se === ye ? -1 : 1) * p(Me)
                      , Ne = Te * (Z * ze / Q)
                      , lt = Te * -(Q * ae / Z)
                      , st = (ee + Ze) / 2
                      , Ue = (Y + qe) / 2
                      , Ge = st + (mt * Ne - yt * lt)
                      , wt = Ue + (yt * Ne + mt * lt)
                      , rt = (ae - Ne) / Z
                      , Dt = (ze - lt) / Q
                      , xt = (-ae - Ne) / Z
                      , Lt = (-ze - lt) / Q
                      , Jt = rt * rt + Dt * Dt
                      , fn = (Dt < 0 ? -1 : 1) * Math.acos(rt / p(Jt))
                      , Fn = (rt * Lt - Dt * xt < 0 ? -1 : 1) * Math.acos((rt * xt + Dt * Lt) / p(Jt * (xt * xt + Lt * Lt)));
                    isNaN(Fn) && (Fn = At),
                    !ye && Fn > 0 ? Fn -= Tt : ye && Fn < 0 && (Fn += Tt),
                    fn %= Tt,
                    Fn %= Tt;
                    var hn = Math.ceil(u(Fn) / (Tt / 4)), Ln = [], Kn = Fn / hn, lr = 4 / 3 * o(Kn / 2) / (1 + l(Kn / 2)), ht = mt * Z, X = yt * Z, ie = yt * -Q, _e = mt * Q, ke;
                    for (ke = 0; ke < hn; ke++)
                        ue = fn + ke * Kn,
                        ae = l(ue),
                        ze = o(ue),
                        rt = l(ue += Kn),
                        Dt = o(ue),
                        Ln.push(ae - lr * ze, ze + lr * ae, rt + lr * Dt, Dt - lr * rt, rt, Dt);
                    for (ke = 0; ke < Ln.length; ke += 2)
                        ae = Ln[ke],
                        ze = Ln[ke + 1],
                        Ln[ke] = ae * ht + ze * ie + Ge,
                        Ln[ke + 1] = ae * X + ze * _e + wt;
                    return Ln[ke - 2] = Ze,
                    Ln[ke - 1] = qe,
                    Ln
                }
            }
            function y(ee) {
                var Y = (ee + "").replace(i, function(Ne) {
                    var lt = +Ne;
                    return lt < 1e-4 && lt > -1e-4 ? 0 : lt
                }).match(r) || [], Z = [], Q = 0, ue = 0, se = 2 / 3, ye = Y.length, Ze = 0, qe = "ERROR: malformed path: " + ee, nt, mt, yt, At, Tt, he, ve, ae, ze, Se, Je, I, $, de, Me, Te = function(lt, st, Ue, Ge) {
                    Se = (Ue - lt) / 3,
                    Je = (Ge - st) / 3,
                    ve.push(lt + Se, st + Je, Ue - Se, Ge - Je, Ue, Ge)
                };
                if (!ee || !isNaN(Y[0]) || isNaN(Y[1]))
                    return console.log(qe),
                    Z;
                for (nt = 0; nt < ye; nt++)
                    if ($ = Tt,
                    isNaN(Y[nt]) ? (Tt = Y[nt].toUpperCase(),
                    he = Tt !== Y[nt]) : nt--,
                    yt = +Y[nt + 1],
                    At = +Y[nt + 2],
                    he && (yt += Q,
                    At += ue),
                    nt || (ae = yt,
                    ze = At),
                    Tt === "M")
                        ve && (ve.length < 8 ? Z.length -= 1 : Ze += ve.length),
                        Q = ae = yt,
                        ue = ze = At,
                        ve = [yt, At],
                        Z.push(ve),
                        nt += 2,
                        Tt = "L";
                    else if (Tt === "C")
                        ve || (ve = [0, 0]),
                        he || (Q = ue = 0),
                        ve.push(yt, At, Q + Y[nt + 3] * 1, ue + Y[nt + 4] * 1, Q += Y[nt + 5] * 1, ue += Y[nt + 6] * 1),
                        nt += 6;
                    else if (Tt === "S")
                        Se = Q,
                        Je = ue,
                        ($ === "C" || $ === "S") && (Se += Q - ve[ve.length - 4],
                        Je += ue - ve[ve.length - 3]),
                        he || (Q = ue = 0),
                        ve.push(Se, Je, yt, At, Q += Y[nt + 3] * 1, ue += Y[nt + 4] * 1),
                        nt += 4;
                    else if (Tt === "Q")
                        Se = Q + (yt - Q) * se,
                        Je = ue + (At - ue) * se,
                        he || (Q = ue = 0),
                        Q += Y[nt + 3] * 1,
                        ue += Y[nt + 4] * 1,
                        ve.push(Se, Je, Q + (yt - Q) * se, ue + (At - ue) * se, Q, ue),
                        nt += 4;
                    else if (Tt === "T")
                        Se = Q - ve[ve.length - 4],
                        Je = ue - ve[ve.length - 3],
                        ve.push(Q + Se, ue + Je, yt + (Q + Se * 1.5 - yt) * se, At + (ue + Je * 1.5 - At) * se, Q = yt, ue = At),
                        nt += 2;
                    else if (Tt === "H")
                        Te(Q, ue, Q = yt, ue),
                        nt += 1;
                    else if (Tt === "V")
                        Te(Q, ue, Q, ue = yt + (he ? ue - Q : 0)),
                        nt += 1;
                    else if (Tt === "L" || Tt === "Z")
                        Tt === "Z" && (yt = ae,
                        At = ze,
                        ve.closed = !0),
                        (Tt === "L" || u(Q - yt) > .5 || u(ue - At) > .5) && (Te(Q, ue, yt, At),
                        Tt === "L" && (nt += 2)),
                        Q = yt,
                        ue = At;
                    else if (Tt === "A") {
                        if (de = Y[nt + 4],
                        Me = Y[nt + 5],
                        Se = Y[nt + 6],
                        Je = Y[nt + 7],
                        mt = 7,
                        de.length > 1 && (de.length < 3 ? (Je = Se,
                        Se = Me,
                        mt--) : (Je = Me,
                        Se = de.substr(2),
                        mt -= 2),
                        Me = de.charAt(1),
                        de = de.charAt(0)),
                        I = E(Q, ue, +Y[nt + 1], +Y[nt + 2], +Y[nt + 3], +de, +Me, (he ? Q : 0) + Se * 1, (he ? ue : 0) + Je * 1),
                        nt += mt,
                        I)
                            for (mt = 0; mt < I.length; mt++)
                                ve.push(I[mt]);
                        Q = ve[ve.length - 2],
                        ue = ve[ve.length - 1]
                    } else
                        console.log(qe);
                return nt = ve.length,
                nt < 6 ? (Z.pop(),
                nt = 0) : ve[0] === ve[nt - 2] && ve[1] === ve[nt - 1] && (ve.closed = !0),
                Z.totalPoints = Ze + nt,
                Z
            }
            function R(ee) {
                h(ee[0]) && (ee = [ee]);
                var Y = "", Z = ee.length, Q, ue, se, ye;
                for (ue = 0; ue < Z; ue++) {
                    for (ye = ee[ue],
                    Y += "M" + m(ye[0]) + "," + m(ye[1]) + " C",
                    Q = ye.length,
                    se = 2; se < Q; se++)
                        Y += m(ye[se++]) + "," + m(ye[se++]) + " " + m(ye[se++]) + "," + m(ye[se++]) + " " + m(ye[se++]) + "," + m(ye[se]) + " ";
                    ye.closed && (Y += "z")
                }
                return Y
            }
            /*!
 * CustomEase 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
            var P, x, v = function() {
                return P || typeof window < "u" && (P = window.gsap) && P.registerPlugin && P
            }, k = function() {
                P = v(),
                P ? (P.registerEase("_CE", re.create),
                x = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
            }, S = 1e20, W = function(Y) {
                return ~~(Y * 1e3 + (Y < 0 ? -.5 : .5)) / 1e3
            }, K = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi, be = /[cLlsSaAhHvVtTqQ]/g, fe = function(Y) {
                var Z = Y.length, Q = S, ue;
                for (ue = 1; ue < Z; ue += 6)
                    +Y[ue] < Q && (Q = +Y[ue]);
                return Q
            }, ge = function(Y, Z, Q) {
                !Q && Q !== 0 && (Q = Math.max(+Y[Y.length - 1], +Y[1]));
                var ue = +Y[0] * -1, se = -Q, ye = Y.length, Ze = 1 / (+Y[ye - 2] + ue), qe = -Z || (Math.abs(+Y[ye - 1] - +Y[1]) < .01 * (+Y[ye - 2] - +Y[0]) ? fe(Y) + se : +Y[ye - 1] + se), nt;
                for (qe ? qe = 1 / qe : qe = -Ze,
                nt = 0; nt < ye; nt += 2)
                    Y[nt] = (+Y[nt] + ue) * Ze,
                    Y[nt + 1] = (+Y[nt + 1] + se) * qe
            }, J = function ee(Y, Z, Q, ue, se, ye, Ze, qe, nt, mt, yt) {
                var At = (Y + Q) / 2, Tt = (Z + ue) / 2, he = (Q + se) / 2, ve = (ue + ye) / 2, ae = (se + Ze) / 2, ze = (ye + qe) / 2, Se = (At + he) / 2, Je = (Tt + ve) / 2, I = (he + ae) / 2, $ = (ve + ze) / 2, de = (Se + I) / 2, Me = (Je + $) / 2, Te = Ze - Y, Ne = qe - Z, lt = Math.abs((Q - Ze) * Ne - (ue - qe) * Te), st = Math.abs((se - Ze) * Ne - (ye - qe) * Te), Ue;
                return mt || (mt = [{
                    x: Y,
                    y: Z
                }, {
                    x: Ze,
                    y: qe
                }],
                yt = 1),
                mt.splice(yt || mt.length - 1, 0, {
                    x: de,
                    y: Me
                }),
                (lt + st) * (lt + st) > nt * (Te * Te + Ne * Ne) && (Ue = mt.length,
                ee(Y, Z, At, Tt, Se, Je, de, Me, nt, mt, yt),
                ee(de, Me, I, $, ae, ze, Ze, qe, nt, mt, yt + 1 + (mt.length - Ue))),
                mt
            }, re = function() {
                function ee(Z, Q, ue) {
                    x || k(),
                    this.id = Z,
                    this.setData(Q, ue)
                }
                var Y = ee.prototype;
                return Y.setData = function(Q, ue) {
                    ue = ue || {},
                    Q = Q || "0,0,1,1";
                    var se = Q.match(K), ye = 1, Ze = [], qe = [], nt = ue.precision || 1, mt = nt <= 1, yt, At, Tt, he, ve, ae, ze, Se, Je;
                    if (this.data = Q,
                    (be.test(Q) || ~Q.indexOf("M") && Q.indexOf("C") < 0) && (se = y(Q)[0]),
                    yt = se.length,
                    yt === 4)
                        se.unshift(0, 0),
                        se.push(1, 1),
                        yt = 8;
                    else if ((yt - 2) % 6)
                        throw "Invalid CustomEase";
                    for ((+se[0] != 0 || +se[yt - 2] != 1) && ge(se, ue.height, ue.originY),
                    this.segment = se,
                    he = 2; he < yt; he += 6)
                        At = {
                            x: +se[he - 2],
                            y: +se[he - 1]
                        },
                        Tt = {
                            x: +se[he + 4],
                            y: +se[he + 5]
                        },
                        Ze.push(At, Tt),
                        J(At.x, At.y, +se[he], +se[he + 1], +se[he + 2], +se[he + 3], Tt.x, Tt.y, 1 / (nt * 2e5), Ze, Ze.length - 1);
                    for (yt = Ze.length,
                    he = 0; he < yt; he++)
                        ze = Ze[he],
                        Se = Ze[he - 1] || ze,
                        (ze.x > Se.x || Se.y !== ze.y && Se.x === ze.x || ze === Se) && ze.x <= 1 ? (Se.cx = ze.x - Se.x,
                        Se.cy = ze.y - Se.y,
                        Se.n = ze,
                        Se.nx = ze.x,
                        mt && he > 1 && Math.abs(Se.cy / Se.cx - Ze[he - 2].cy / Ze[he - 2].cx) > 2 && (mt = 0),
                        Se.cx < ye && (Se.cx ? ye = Se.cx : (Se.cx = .001,
                        he === yt - 1 && (Se.x -= .001,
                        ye = Math.min(ye, .001),
                        mt = 0)))) : (Ze.splice(he--, 1),
                        yt--);
                    if (yt = 1 / ye + 1 | 0,
                    ve = 1 / yt,
                    ae = 0,
                    ze = Ze[0],
                    mt) {
                        for (he = 0; he < yt; he++)
                            Je = he * ve,
                            ze.nx < Je && (ze = Ze[++ae]),
                            At = ze.y + (Je - ze.x) / ze.cx * ze.cy,
                            qe[he] = {
                                x: Je,
                                cx: ve,
                                y: At,
                                cy: 0,
                                nx: 9
                            },
                            he && (qe[he - 1].cy = At - qe[he - 1].y);
                        ae = Ze[Ze.length - 1],
                        qe[yt - 1].cy = ae.y - At,
                        qe[yt - 1].cx = ae.x - qe[qe.length - 1].x
                    } else {
                        for (he = 0; he < yt; he++)
                            ze.nx < he * ve && (ze = Ze[++ae]),
                            qe[he] = ze;
                        ae < Ze.length - 1 && (qe[he - 1] = Ze[Ze.length - 2])
                    }
                    return this.ease = function(I) {
                        var $ = qe[I * yt | 0] || qe[yt - 1];
                        return $.nx < I && ($ = $.n),
                        $.y + (I - $.x) / $.cx * $.cy
                    }
                    ,
                    this.ease.custom = this,
                    this.id && P && P.registerEase(this.id, this.ease),
                    this
                }
                ,
                Y.getSVGData = function(Q) {
                    return ee.getSVGData(this, Q)
                }
                ,
                ee.create = function(Q, ue, se) {
                    return new ee(Q,ue,se).ease
                }
                ,
                ee.register = function(Q) {
                    P = Q,
                    k()
                }
                ,
                ee.get = function(Q) {
                    return P.parseEase(Q)
                }
                ,
                ee.getSVGData = function(Q, ue) {
                    ue = ue || {};
                    var se = ue.width || 100, ye = ue.height || 100, Ze = ue.x || 0, qe = (ue.y || 0) + ye, nt = P.utils.toArray(ue.path)[0], mt, yt, At, Tt, he, ve, ae, ze, Se, Je;
                    if (ue.invert && (ye = -ye,
                    qe = 0),
                    typeof Q == "string" && (Q = P.parseEase(Q)),
                    Q.custom && (Q = Q.custom),
                    Q instanceof ee)
                        mt = R(w([Q.segment], se, 0, 0, -ye, Ze, qe));
                    else {
                        for (mt = [Ze, qe],
                        ae = Math.max(5, (ue.precision || 1) * 200),
                        Tt = 1 / ae,
                        ae += 2,
                        ze = 5 / ae,
                        Se = W(Ze + Tt * se),
                        Je = W(qe + Q(Tt) * -ye),
                        yt = (Je - qe) / (Se - Ze),
                        At = 2; At < ae; At++)
                            he = W(Ze + At * Tt * se),
                            ve = W(qe + Q(At * Tt) * -ye),
                            (Math.abs((ve - Je) / (he - Se) - yt) > ze || At === ae - 1) && (mt.push(Se, Je),
                            yt = (ve - Je) / (he - Se)),
                            Se = he,
                            Je = ve;
                        mt = "M" + mt.join(",")
                    }
                    return nt && nt.setAttribute("d", mt),
                    mt
                }
                ,
                ee
            }();
            re.version = "3.13.0",
            re.headless = !0,
            v() && P.registerPlugin(re),
            n.CustomEase = re,
            n.default = re,
            Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(Wl, Wl.exports)),
    Wl.exports
}
var GT = qT();
const oc = la(GT);
var ql = {
    exports: {}
};
/*!
 * SplitText 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.
 * @author: Jack Doyle
 */
var YT = ql.exports, Tg;
function KT() {
    return Tg || (Tg = 1,
    function(e, t) {
        (function(n, r) {
            r(t)
        }
        )(YT, function(n) {
            let r, i, s, o = () => s || W.register(window.gsap), l = typeof Intl < "u" ? new Intl.Segmenter : 0, u = K => typeof K == "string" ? u(document.querySelectorAll(K)) : "length"in K ? Array.from(K) : [K], p = K => u(K).filter(be => be instanceof HTMLElement), h = [], g = function() {}, m = /\s+/g, w = new RegExp("\\p{RI}\\p{RI}|\\p{Emoji}(\\p{EMod}|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?(\\u{200D}\\p{Emoji}(\\p{EMod}|\\u{FE0F}\\u{20E3}?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?)*|.","gu"), E = {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            }, y = (K, be) => {
                if (be) {
                    let fe = new Set(K.join("").match(be) || h), ge = K.length, J, re, ee, Y;
                    if (fe.size)
                        for (; --ge > -1; ) {
                            re = K[ge];
                            for (ee of fe)
                                if (ee.startsWith(re) && ee.length > re.length) {
                                    for (J = 0,
                                    Y = re; ee.startsWith(Y += K[ge + ++J]) && Y.length < ee.length; )
                                        ;
                                    if (J && Y.length === ee.length) {
                                        K[ge] = ee,
                                        K.splice(ge + 1, J);
                                        break
                                    }
                                }
                        }
                }
                return K
            }
            , R = K => window.getComputedStyle(K).display === "inline" && (K.style.display = "inline-block"), P = (K, be, fe) => be.insertBefore(typeof K == "string" ? document.createTextNode(K) : K, fe), x = (K, be, fe) => {
                let ge = be[K + "sClass"] || ""
                  , {tag: J="div", aria: re="auto", propIndex: ee=!1} = be
                  , Y = K === "line" ? "block" : "inline-block"
                  , Z = ge.indexOf("++") > -1
                  , Q = ue => {
                    let se = document.createElement(J)
                      , ye = fe.length + 1;
                    return ge && (se.className = ge + (Z ? " " + ge + ye : "")),
                    ee && se.style.setProperty("--" + K, ye + ""),
                    re !== "none" && se.setAttribute("aria-hidden", "true"),
                    J !== "span" && (se.style.position = "relative",
                    se.style.display = Y),
                    se.textContent = ue,
                    fe.push(se),
                    se
                }
                ;
                return Z && (ge = ge.replace("++", "")),
                Q.collection = fe,
                Q
            }
            , v = (K, be, fe, ge) => {
                let J = x("line", fe, ge)
                  , re = window.getComputedStyle(K).textAlign || "left";
                return (ee, Y) => {
                    let Z = J("");
                    for (Z.style.textAlign = re,
                    K.insertBefore(Z, be[ee]); ee < Y; ee++)
                        Z.appendChild(be[ee]);
                    Z.normalize()
                }
            }
            , k = (K, be, fe, ge, J, re, ee, Y, Z, Q) => {
                var ue;
                let se = Array.from(K.childNodes), ye = 0, {wordDelimiter: Ze, reduceWhiteSpace: qe=!0, prepareText: nt} = be, mt = K.getBoundingClientRect(), yt = mt, At = !qe && window.getComputedStyle(K).whiteSpace.substring(0, 3) === "pre", Tt = 0, he = fe.collection, ve, ae, ze, Se, Je, I, $, de, Me, Te, Ne, lt, st, Ue, Ge, wt, rt, Dt;
                for (typeof Ze == "object" ? (ze = Ze.delimiter || Ze,
                ae = Ze.replaceWith || "") : ae = Ze === "" ? "" : Ze || " ",
                ve = ae !== " "; ye < se.length; ye++)
                    if (Se = se[ye],
                    Se.nodeType === 3) {
                        for (Ge = Se.textContent || "",
                        qe ? Ge = Ge.replace(m, " ") : At && (Ge = Ge.replace(/\n/g, ae + `
`)),
                        nt && (Ge = nt(Ge, K)),
                        Se.textContent = Ge,
                        Je = ae || ze ? Ge.split(ze || ae) : Ge.match(Y) || h,
                        rt = Je[Je.length - 1],
                        de = ve ? rt.slice(-1) === " " : !rt,
                        rt || Je.pop(),
                        yt = mt,
                        $ = ve ? Je[0].charAt(0) === " " : !Je[0],
                        $ && P(" ", K, Se),
                        Je[0] || Je.shift(),
                        y(Je, Z),
                        re && Q || (Se.textContent = ""),
                        Me = 1; Me <= Je.length; Me++)
                            if (wt = Je[Me - 1],
                            !qe && At && wt.charAt(0) === `
` && ((ue = Se.previousSibling) == null || ue.remove(),
                            P(document.createElement("br"), K, Se),
                            wt = wt.slice(1)),
                            !qe && wt === "")
                                P(ae, K, Se);
                            else if (wt === " ")
                                K.insertBefore(document.createTextNode(" "), Se);
                            else {
                                if (ve && wt.charAt(0) === " " && P(" ", K, Se),
                                Tt && Me === 1 && !$ && he.indexOf(Tt.parentNode) > -1 ? (I = he[he.length - 1],
                                I.appendChild(document.createTextNode(ge ? "" : wt))) : (I = fe(ge ? "" : wt),
                                P(I, K, Se),
                                Tt && Me === 1 && !$ && I.insertBefore(Tt, I.firstChild)),
                                ge)
                                    for (Ne = l ? y([...l.segment(wt)].map(xt => xt.segment), Z) : wt.match(Y) || h,
                                    Dt = 0; Dt < Ne.length; Dt++)
                                        I.appendChild(Ne[Dt] === " " ? document.createTextNode(" ") : ge(Ne[Dt]));
                                if (re && Q) {
                                    if (Ge = Se.textContent = Ge.substring(wt.length + 1, Ge.length),
                                    Te = I.getBoundingClientRect(),
                                    Te.top > yt.top && Te.left <= yt.left) {
                                        for (lt = K.cloneNode(),
                                        st = K.childNodes[0]; st && st !== I; )
                                            Ue = st,
                                            st = st.nextSibling,
                                            lt.appendChild(Ue);
                                        K.parentNode.insertBefore(lt, K),
                                        J && R(lt)
                                    }
                                    yt = Te
                                }
                                (Me < Je.length || de) && P(Me >= Je.length ? " " : ve && wt.slice(-1) === " " ? " " + ae : ae, K, Se)
                            }
                        K.removeChild(Se),
                        Tt = 0
                    } else
                        Se.nodeType === 1 && (ee && ee.indexOf(Se) > -1 ? (he.indexOf(Se.previousSibling) > -1 && he[he.length - 1].appendChild(Se),
                        Tt = Se) : (k(Se, be, fe, ge, J, re, ee, Y, Z, !0),
                        Tt = 0),
                        J && R(Se))
            }
            ;
            const S = class G0 {
                constructor(be, fe) {
                    this.isSplit = !1,
                    o(),
                    this.elements = p(be),
                    this.chars = [],
                    this.words = [],
                    this.lines = [],
                    this.masks = [],
                    this.vars = fe,
                    this._split = () => this.isSplit && this.split(this.vars);
                    let ge = [], J, re = () => {
                        let ee = ge.length, Y;
                        for (; ee--; ) {
                            Y = ge[ee];
                            let Z = Y.element.offsetWidth;
                            if (Z !== Y.width) {
                                Y.width = Z,
                                this._split();
                                return
                            }
                        }
                    }
                    ;
                    this._data = {
                        orig: ge,
                        obs: typeof ResizeObserver < "u" && new ResizeObserver( () => {
                            clearTimeout(J),
                            J = setTimeout(re, 200)
                        }
                        )
                    },
                    g(this),
                    this.split(fe)
                }
                split(be) {
                    this.isSplit && this.revert(),
                    this.vars = be = be || this.vars || {};
                    let {type: fe="chars,words,lines", aria: ge="auto", deepSlice: J=!0, smartWrap: re, onSplit: ee, autoSplit: Y=!1, specialChars: Z, mask: Q} = this.vars, ue = fe.indexOf("lines") > -1, se = fe.indexOf("chars") > -1, ye = fe.indexOf("words") > -1, Ze = se && !ye && !ue, qe = Z && ("push"in Z ? new RegExp("(?:" + Z.join("|") + ")","gu") : Z), nt = qe ? new RegExp(qe.source + "|" + w.source,"gu") : w, mt = !!be.ignore && p(be.ignore), {orig: yt, animTime: At, obs: Tt} = this._data, he;
                    return (se || ye || ue) && (this.elements.forEach( (ve, ae) => {
                        yt[ae] = {
                            element: ve,
                            html: ve.innerHTML,
                            ariaL: ve.getAttribute("aria-label"),
                            ariaH: ve.getAttribute("aria-hidden")
                        },
                        ge === "auto" ? ve.setAttribute("aria-label", (ve.textContent || "").trim()) : ge === "hidden" && ve.setAttribute("aria-hidden", "true");
                        let ze = [], Se = [], Je = [], I = se ? x("char", be, ze) : null, $ = x("word", be, Se), de, Me, Te, Ne;
                        if (k(ve, be, $, I, Ze, J && (ue || Ze), mt, nt, qe, !1),
                        ue) {
                            let lt = u(ve.childNodes), st = v(ve, lt, be, Je), Ue, Ge = [], wt = 0, rt = lt.map(xt => xt.nodeType === 1 ? xt.getBoundingClientRect() : E), Dt = E;
                            for (de = 0; de < lt.length; de++)
                                Ue = lt[de],
                                Ue.nodeType === 1 && (Ue.nodeName === "BR" ? (Ge.push(Ue),
                                st(wt, de + 1),
                                wt = de + 1,
                                Dt = rt[wt]) : (de && rt[de].top > Dt.top && rt[de].left <= Dt.left && (st(wt, de),
                                wt = de),
                                Dt = rt[de]));
                            wt < de && st(wt, de),
                            Ge.forEach(xt => {
                                var Lt;
                                return (Lt = xt.parentNode) == null ? void 0 : Lt.removeChild(xt)
                            }
                            )
                        }
                        if (!ye) {
                            for (de = 0; de < Se.length; de++)
                                if (Me = Se[de],
                                se || !Me.nextSibling || Me.nextSibling.nodeType !== 3)
                                    if (re && !ue) {
                                        for (Te = document.createElement("span"),
                                        Te.style.whiteSpace = "nowrap"; Me.firstChild; )
                                            Te.appendChild(Me.firstChild);
                                        Me.replaceWith(Te)
                                    } else
                                        Me.replaceWith(...Me.childNodes);
                                else
                                    Ne = Me.nextSibling,
                                    Ne && Ne.nodeType === 3 && (Ne.textContent = (Me.textContent || "") + (Ne.textContent || ""),
                                    Me.remove());
                            Se.length = 0,
                            ve.normalize()
                        }
                        this.lines.push(...Je),
                        this.words.push(...Se),
                        this.chars.push(...ze)
                    }
                    ),
                    Q && this[Q] && this.masks.push(...this[Q].map(ve => {
                        let ae = ve.cloneNode();
                        return ve.replaceWith(ae),
                        ae.appendChild(ve),
                        ve.className && (ae.className = ve.className.replace(/(\b\w+\b)/g, "$1-mask")),
                        ae.style.overflow = "clip",
                        ae
                    }
                    ))),
                    this.isSplit = !0,
                    i && (Y ? i.addEventListener("loadingdone", this._split) : i.status === "loading" && console.warn("SplitText called before fonts loaded")),
                    (he = ee && ee(this)) && he.totalTime && (this._data.anim = At ? he.totalTime(At) : he),
                    ue && Y && this.elements.forEach( (ve, ae) => {
                        yt[ae].width = ve.offsetWidth,
                        Tt && Tt.observe(ve)
                    }
                    ),
                    this
                }
                revert() {
                    var be, fe;
                    let {orig: ge, anim: J, obs: re} = this._data;
                    return re && re.disconnect(),
                    ge.forEach( ({element: ee, html: Y, ariaL: Z, ariaH: Q}) => {
                        ee.innerHTML = Y,
                        Z ? ee.setAttribute("aria-label", Z) : ee.removeAttribute("aria-label"),
                        Q ? ee.setAttribute("aria-hidden", Q) : ee.removeAttribute("aria-hidden")
                    }
                    ),
                    this.chars.length = this.words.length = this.lines.length = ge.length = this.masks.length = 0,
                    this.isSplit = !1,
                    i == null || i.removeEventListener("loadingdone", this._split),
                    J && (this._data.animTime = J.totalTime(),
                    J.revert()),
                    (fe = (be = this.vars).onRevert) == null || fe.call(be, this),
                    this
                }
                static create(be, fe) {
                    return new G0(be,fe)
                }
                static register(be) {
                    r = r || be || window.gsap,
                    r && (u = r.utils.toArray,
                    g = r.core.context || g),
                    !s && window.innerWidth > 0 && (i = document.fonts,
                    s = !0)
                }
            }
            ;
            S.version = "3.13.0";
            let W = S;
            n.SplitText = W,
            n.default = W,
            Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(ql, ql.exports)),
    ql.exports
}
var XT = KT();
const Pg = la(XT);
var Gl = {
    exports: {}
}, QT = Gl.exports, kg;
function JT() {
    return kg || (kg = 1,
    function(e, t) {
        (function(n, r) {
            r(t)
        }
        )(QT, function(n) {
            /*!
 * DrawSVGPlugin 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
            var r, i, s, o, l, u, p, h, g = function() {
                return typeof window < "u"
            }, m = function() {
                return r || g() && (r = window.gsap) && r.registerPlugin && r
            }, w = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, E = {
                rect: ["width", "height"],
                circle: ["r", "r"],
                ellipse: ["rx", "ry"],
                line: ["x2", "y2"]
            }, y = function(Y) {
                return Math.round(Y * 1e4) / 1e4
            }, R = function(Y) {
                return parseFloat(Y) || 0
            }, P = function(Y, Z) {
                var Q = R(Y);
                return ~Y.indexOf("%") ? Q / 100 * Z : Q
            }, x = function(Y, Z) {
                return R(Y.getAttribute(Z))
            }, v = Math.sqrt, k = function(Y, Z, Q, ue, se, ye) {
                return v(Math.pow((R(Q) - R(Y)) * se, 2) + Math.pow((R(ue) - R(Z)) * ye, 2))
            }, S = function(Y) {
                return console.warn(Y)
            }, W = function(Y) {
                return Y.getAttribute("vector-effect") === "non-scaling-stroke"
            }, K = 1, be = function(Y, Z, Q) {
                var ue = Y.indexOf(" "), se, ye;
                return ue < 0 ? (se = Q !== void 0 ? Q + "" : Y,
                ye = Y) : (se = Y.substr(0, ue),
                ye = Y.substr(ue + 1)),
                se = P(se, Z),
                ye = P(ye, Z),
                se > ye ? [ye, se] : [se, ye]
            }, fe = function(Y) {
                if (Y = i(Y)[0],
                !Y)
                    return 0;
                var Z = Y.tagName.toLowerCase(), Q = Y.style, ue = 1, se = 1, ye, Ze, qe, nt, mt, yt, At;
                W(Y) && (se = Y.getScreenCTM(),
                ue = v(se.a * se.a + se.b * se.b),
                se = v(se.d * se.d + se.c * se.c));
                try {
                    Ze = Y.getBBox()
                } catch {
                    S("Some browsers won't measure invisible elements (like display:none or masks inside defs).")
                }
                var Tt = Ze || {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }
                  , he = Tt.x
                  , ve = Tt.y
                  , ae = Tt.width
                  , ze = Tt.height;
                if ((!Ze || !ae && !ze) && E[Z] && (ae = x(Y, E[Z][0]),
                ze = x(Y, E[Z][1]),
                Z !== "rect" && Z !== "line" && (ae *= 2,
                ze *= 2),
                Z === "line" && (he = x(Y, "x1"),
                ve = x(Y, "y1"),
                ae = Math.abs(ae - he),
                ze = Math.abs(ze - ve))),
                Z === "path")
                    nt = Q.strokeDasharray,
                    Q.strokeDasharray = "none",
                    ye = Y.getTotalLength() || 0,
                    y(ue) !== y(se) && !u && (u = 1) && S("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."),
                    ye *= (ue + se) / 2,
                    Q.strokeDasharray = nt;
                else if (Z === "rect")
                    ye = ae * 2 * ue + ze * 2 * se;
                else if (Z === "line")
                    ye = k(he, ve, he + ae, ve + ze, ue, se);
                else if (Z === "polyline" || Z === "polygon")
                    for (qe = Y.getAttribute("points").match(w) || [],
                    Z === "polygon" && qe.push(qe[0], qe[1]),
                    ye = 0,
                    mt = 2; mt < qe.length; mt += 2)
                        ye += k(qe[mt - 2], qe[mt - 1], qe[mt], qe[mt + 1], ue, se) || 0;
                else
                    (Z === "circle" || Z === "ellipse") && (yt = ae / 2 * ue,
                    At = ze / 2 * se,
                    ye = Math.PI * (3 * (yt + At) - v((3 * yt + At) * (yt + 3 * At))));
                return ye || 0
            }, ge = function(Y, Z) {
                if (Y = i(Y)[0],
                !Y)
                    return [0, 0];
                Z || (Z = fe(Y) + 1);
                var Q = s.getComputedStyle(Y)
                  , ue = Q.strokeDasharray || ""
                  , se = R(Q.strokeDashoffset)
                  , ye = ue.indexOf(",");
                return ye < 0 && (ye = ue.indexOf(" ")),
                ue = ye < 0 ? Z : R(ue.substr(0, ye)),
                ue > Z && (ue = Z),
                [-se || 0, ue - se || 0]
            }, J = function() {
                g() && (s = window,
                l = r = m(),
                i = r.utils.toArray,
                p = r.core.getStyleSaver,
                h = r.core.reverting || function() {}
                ,
                o = ((s.navigator || {}).userAgent || "").indexOf("Edge") !== -1)
            }, re = {
                version: "3.13.0",
                name: "drawSVG",
                register: function(Y) {
                    r = Y,
                    J()
                },
                init: function(Y, Z, Q, ue, se) {
                    if (!Y.getBBox)
                        return !1;
                    l || J();
                    var ye = fe(Y), Ze, qe, nt;
                    return this.styles = p && p(Y, "strokeDashoffset,strokeDasharray,strokeMiterlimit"),
                    this.tween = Q,
                    this._style = Y.style,
                    this._target = Y,
                    Z + "" == "true" ? Z = "0 100%" : Z ? (Z + "").indexOf(" ") === -1 && (Z = "0 " + Z) : Z = "0 0",
                    Ze = ge(Y, ye),
                    qe = be(Z, ye, Ze[0]),
                    this._length = y(ye),
                    this._dash = y(Ze[1] - Ze[0]),
                    this._offset = y(-Ze[0]),
                    this._dashPT = this.add(this, "_dash", this._dash, y(qe[1] - qe[0]), 0, 0, 0, 0, 0, 1),
                    this._offsetPT = this.add(this, "_offset", this._offset, y(-qe[0]), 0, 0, 0, 0, 0, 1),
                    o && (nt = s.getComputedStyle(Y),
                    nt.strokeLinecap !== nt.strokeLinejoin && (qe = R(nt.strokeMiterlimit),
                    this.add(Y.style, "strokeMiterlimit", qe, qe + .01))),
                    this._live = W(Y) || ~(Z + "").indexOf("live"),
                    this._nowrap = ~(Z + "").indexOf("nowrap"),
                    this._props.push("drawSVG"),
                    K
                },
                render: function(Y, Z) {
                    if (Z.tween._time || !h()) {
                        var Q = Z._pt, ue = Z._style, se, ye, Ze, qe;
                        if (Q) {
                            for (Z._live && (se = fe(Z._target),
                            se !== Z._length && (ye = se / Z._length,
                            Z._length = se,
                            Z._offsetPT && (Z._offsetPT.s *= ye,
                            Z._offsetPT.c *= ye),
                            Z._dashPT ? (Z._dashPT.s *= ye,
                            Z._dashPT.c *= ye) : Z._dash *= ye)); Q; )
                                Q.r(Y, Q.d),
                                Q = Q._next;
                            Ze = Z._dash || Y && Y !== 1 && 1e-4 || 0,
                            se = Z._length - Ze + .1,
                            qe = Z._offset,
                            Ze && qe && Ze + Math.abs(qe % Z._length) > Z._length - .05 && (qe += qe < 0 ? .005 : -.005) && (se += .005),
                            ue.strokeDashoffset = Ze ? qe : qe + .001,
                            ue.strokeDasharray = se < .1 ? "none" : Ze ? Ze + "px," + (Z._nowrap ? 999999 : se) + "px" : "0px, 999999px"
                        }
                    } else
                        Z.styles.revert()
                },
                getLength: fe,
                getPosition: ge
            };
            m() && r.registerPlugin(re),
            n.DrawSVGPlugin = re,
            n.default = re,
            Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(Gl, Gl.exports)),
    Gl.exports
}
var ZT = JT();
const e2 = la(ZT);
var Yl = {
    exports: {}
}, t2 = Yl.exports, Ag;
function n2() {
    return Ag || (Ag = 1,
    function(e, t) {
        (function(n, r) {
            r(t)
        }
        )(t2, function(n) {
            var r = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig
              , i = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig
              , s = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig
              , o = /(^[#\.][a-z]|[a-y][a-z])/i
              , l = Math.PI / 180
              , u = Math.sin
              , p = Math.cos
              , h = Math.abs
              , g = Math.sqrt
              , m = function(X) {
                return typeof X == "string"
            }
              , w = function(X) {
                return typeof X == "number"
            }
              , E = 1e5
              , y = function(X) {
                return Math.round(X * E) / E || 0
            };
            function R(ht) {
                ht = m(ht) && o.test(ht) && document.querySelector(ht) || ht;
                var X = ht.getAttribute ? ht : 0, ie;
                return X && (ht = ht.getAttribute("d")) ? (X._gsPath || (X._gsPath = {}),
                ie = X._gsPath[ht],
                ie && !ie._dirty ? ie : X._gsPath[ht] = K(ht)) : ht ? m(ht) ? K(ht) : w(ht[0]) ? [ht] : ht : console.warn("Expecting a <path> element or an SVG path data string")
            }
            function P(ht) {
                var X = 0, ie;
                for (ht.reverse(); X < ht.length; X += 2)
                    ie = ht[X],
                    ht[X] = ht[X + 1],
                    ht[X + 1] = ie;
                ht.reversed = !ht.reversed
            }
            var x = function(X, ie) {
                var _e = document.createElementNS("http://www.w3.org/2000/svg", "path"), ke = [].slice.call(X.attributes), Fe = ke.length, Ce;
                for (ie = "," + ie + ","; --Fe > -1; )
                    Ce = ke[Fe].nodeName.toLowerCase(),
                    ie.indexOf("," + Ce + ",") < 0 && _e.setAttributeNS(null, Ce, ke[Fe].nodeValue);
                return _e
            }
              , v = {
                rect: "rx,ry,x,y,width,height",
                circle: "r,cx,cy",
                ellipse: "rx,ry,cx,cy",
                line: "x1,x2,y1,y2"
            }
              , k = function(X, ie) {
                for (var _e = ie ? ie.split(",") : [], ke = {}, Fe = _e.length; --Fe > -1; )
                    ke[_e[Fe]] = +X.getAttribute(_e[Fe]) || 0;
                return ke
            };
            function S(ht, X) {
                var ie = ht.tagName.toLowerCase(), _e = .552284749831, ke, Fe, Ce, $e, Ye, je, vt, ot, Ve, ut, Ft, ft, gt, et, Oe, O, z, L, ne, le, Ie, ct;
                return ie === "path" || !ht.getBBox ? ht : (je = x(ht, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"),
                ct = k(ht, v[ie]),
                ie === "rect" ? ($e = ct.rx,
                Ye = ct.ry || $e,
                Fe = ct.x,
                Ce = ct.y,
                ut = ct.width - $e * 2,
                Ft = ct.height - Ye * 2,
                $e || Ye ? (ft = Fe + $e * (1 - _e),
                gt = Fe + $e,
                et = gt + ut,
                Oe = et + $e * _e,
                O = et + $e,
                z = Ce + Ye * (1 - _e),
                L = Ce + Ye,
                ne = L + Ft,
                le = ne + Ye * _e,
                Ie = ne + Ye,
                ke = "M" + O + "," + L + " V" + ne + " C" + [O, le, Oe, Ie, et, Ie, et - (et - gt) / 3, Ie, gt + (et - gt) / 3, Ie, gt, Ie, ft, Ie, Fe, le, Fe, ne, Fe, ne - (ne - L) / 3, Fe, L + (ne - L) / 3, Fe, L, Fe, z, ft, Ce, gt, Ce, gt + (et - gt) / 3, Ce, et - (et - gt) / 3, Ce, et, Ce, Oe, Ce, O, z, O, L].join(",") + "z") : ke = "M" + (Fe + ut) + "," + Ce + " v" + Ft + " h" + -ut + " v" + -Ft + " h" + ut + "z") : ie === "circle" || ie === "ellipse" ? (ie === "circle" ? ($e = Ye = ct.r,
                ot = $e * _e) : ($e = ct.rx,
                Ye = ct.ry,
                ot = Ye * _e),
                Fe = ct.cx,
                Ce = ct.cy,
                vt = $e * _e,
                ke = "M" + (Fe + $e) + "," + Ce + " C" + [Fe + $e, Ce + ot, Fe + vt, Ce + Ye, Fe, Ce + Ye, Fe - vt, Ce + Ye, Fe - $e, Ce + ot, Fe - $e, Ce, Fe - $e, Ce - ot, Fe - vt, Ce - Ye, Fe, Ce - Ye, Fe + vt, Ce - Ye, Fe + $e, Ce - ot, Fe + $e, Ce].join(",") + "z") : ie === "line" ? ke = "M" + ct.x1 + "," + ct.y1 + " L" + ct.x2 + "," + ct.y2 : (ie === "polyline" || ie === "polygon") && (Ve = (ht.getAttribute("points") + "").match(i) || [],
                Fe = Ve.shift(),
                Ce = Ve.shift(),
                ke = "M" + Fe + "," + Ce + " L" + Ve.join(","),
                ie === "polygon" && (ke += "," + Fe + "," + Ce + "z")),
                je.setAttribute("d", be(je._gsRawPath = K(ke))),
                X && ht.parentNode && (ht.parentNode.insertBefore(je, ht),
                ht.parentNode.removeChild(ht)),
                je)
            }
            function W(ht, X, ie, _e, ke, Fe, Ce, $e, Ye) {
                if (!(ht === $e && X === Ye)) {
                    ie = h(ie),
                    _e = h(_e);
                    var je = ke % 360 * l
                      , vt = p(je)
                      , ot = u(je)
                      , Ve = Math.PI
                      , ut = Ve * 2
                      , Ft = (ht - $e) / 2
                      , ft = (X - Ye) / 2
                      , gt = vt * Ft + ot * ft
                      , et = -ot * Ft + vt * ft
                      , Oe = gt * gt
                      , O = et * et
                      , z = Oe / (ie * ie) + O / (_e * _e);
                    z > 1 && (ie = g(z) * ie,
                    _e = g(z) * _e);
                    var L = ie * ie
                      , ne = _e * _e
                      , le = (L * ne - L * O - ne * Oe) / (L * O + ne * Oe);
                    le < 0 && (le = 0);
                    var Ie = (Fe === Ce ? -1 : 1) * g(le)
                      , ct = Ie * (ie * et / _e)
                      , F = Ie * -(_e * gt / ie)
                      , b = (ht + $e) / 2
                      , T = (X + Ye) / 2
                      , M = b + (vt * ct - ot * F)
                      , H = T + (ot * ct + vt * F)
                      , G = (gt - ct) / ie
                      , ce = (et - F) / _e
                      , we = (-gt - ct) / ie
                      , xe = (-et - F) / _e
                      , oe = G * G + ce * ce
                      , We = (ce < 0 ? -1 : 1) * Math.acos(G / g(oe))
                      , me = (G * xe - ce * we < 0 ? -1 : 1) * Math.acos((G * we + ce * xe) / g(oe * (we * we + xe * xe)));
                    isNaN(me) && (me = Ve),
                    !Ce && me > 0 ? me -= ut : Ce && me < 0 && (me += ut),
                    We %= ut,
                    me %= ut;
                    var Qe = Math.ceil(h(me) / (ut / 4)), tt = [], dt = me / Qe, pt = 4 / 3 * u(dt / 2) / (1 + p(dt / 2)), jt = vt * ie, Nt = ot * ie, Pt = ot * -_e, Bt = vt * _e, $t;
                    for ($t = 0; $t < Qe; $t++)
                        ke = We + $t * dt,
                        gt = p(ke),
                        et = u(ke),
                        G = p(ke += dt),
                        ce = u(ke),
                        tt.push(gt - pt * et, et + pt * gt, G + pt * ce, ce - pt * G, G, ce);
                    for ($t = 0; $t < tt.length; $t += 2)
                        gt = tt[$t],
                        et = tt[$t + 1],
                        tt[$t] = gt * jt + et * Pt + M,
                        tt[$t + 1] = gt * Nt + et * Bt + H;
                    return tt[$t - 2] = $e,
                    tt[$t - 1] = Ye,
                    tt
                }
            }
            function K(ht) {
                var X = (ht + "").replace(s, function(ct) {
                    var F = +ct;
                    return F < 1e-4 && F > -1e-4 ? 0 : F
                }).match(r) || [], ie = [], _e = 0, ke = 0, Fe = 2 / 3, Ce = X.length, $e = 0, Ye = "ERROR: malformed path: " + ht, je, vt, ot, Ve, ut, Ft, ft, gt, et, Oe, O, z, L, ne, le, Ie = function(F, b, T, M) {
                    Oe = (T - F) / 3,
                    O = (M - b) / 3,
                    ft.push(F + Oe, b + O, T - Oe, M - O, T, M)
                };
                if (!ht || !isNaN(X[0]) || isNaN(X[1]))
                    return console.log(Ye),
                    ie;
                for (je = 0; je < Ce; je++)
                    if (L = ut,
                    isNaN(X[je]) ? (ut = X[je].toUpperCase(),
                    Ft = ut !== X[je]) : je--,
                    ot = +X[je + 1],
                    Ve = +X[je + 2],
                    Ft && (ot += _e,
                    Ve += ke),
                    je || (gt = ot,
                    et = Ve),
                    ut === "M")
                        ft && (ft.length < 8 ? ie.length -= 1 : $e += ft.length),
                        _e = gt = ot,
                        ke = et = Ve,
                        ft = [ot, Ve],
                        ie.push(ft),
                        je += 2,
                        ut = "L";
                    else if (ut === "C")
                        ft || (ft = [0, 0]),
                        Ft || (_e = ke = 0),
                        ft.push(ot, Ve, _e + X[je + 3] * 1, ke + X[je + 4] * 1, _e += X[je + 5] * 1, ke += X[je + 6] * 1),
                        je += 6;
                    else if (ut === "S")
                        Oe = _e,
                        O = ke,
                        (L === "C" || L === "S") && (Oe += _e - ft[ft.length - 4],
                        O += ke - ft[ft.length - 3]),
                        Ft || (_e = ke = 0),
                        ft.push(Oe, O, ot, Ve, _e += X[je + 3] * 1, ke += X[je + 4] * 1),
                        je += 4;
                    else if (ut === "Q")
                        Oe = _e + (ot - _e) * Fe,
                        O = ke + (Ve - ke) * Fe,
                        Ft || (_e = ke = 0),
                        _e += X[je + 3] * 1,
                        ke += X[je + 4] * 1,
                        ft.push(Oe, O, _e + (ot - _e) * Fe, ke + (Ve - ke) * Fe, _e, ke),
                        je += 4;
                    else if (ut === "T")
                        Oe = _e - ft[ft.length - 4],
                        O = ke - ft[ft.length - 3],
                        ft.push(_e + Oe, ke + O, ot + (_e + Oe * 1.5 - ot) * Fe, Ve + (ke + O * 1.5 - Ve) * Fe, _e = ot, ke = Ve),
                        je += 2;
                    else if (ut === "H")
                        Ie(_e, ke, _e = ot, ke),
                        je += 1;
                    else if (ut === "V")
                        Ie(_e, ke, _e, ke = ot + (Ft ? ke - _e : 0)),
                        je += 1;
                    else if (ut === "L" || ut === "Z")
                        ut === "Z" && (ot = gt,
                        Ve = et,
                        ft.closed = !0),
                        (ut === "L" || h(_e - ot) > .5 || h(ke - Ve) > .5) && (Ie(_e, ke, ot, Ve),
                        ut === "L" && (je += 2)),
                        _e = ot,
                        ke = Ve;
                    else if (ut === "A") {
                        if (ne = X[je + 4],
                        le = X[je + 5],
                        Oe = X[je + 6],
                        O = X[je + 7],
                        vt = 7,
                        ne.length > 1 && (ne.length < 3 ? (O = Oe,
                        Oe = le,
                        vt--) : (O = le,
                        Oe = ne.substr(2),
                        vt -= 2),
                        le = ne.charAt(1),
                        ne = ne.charAt(0)),
                        z = W(_e, ke, +X[je + 1], +X[je + 2], +X[je + 3], +ne, +le, (Ft ? _e : 0) + Oe * 1, (Ft ? ke : 0) + O * 1),
                        je += vt,
                        z)
                            for (vt = 0; vt < z.length; vt++)
                                ft.push(z[vt]);
                        _e = ft[ft.length - 2],
                        ke = ft[ft.length - 1]
                    } else
                        console.log(Ye);
                return je = ft.length,
                je < 6 ? (ie.pop(),
                je = 0) : ft[0] === ft[je - 2] && ft[1] === ft[je - 1] && (ft.closed = !0),
                ie.totalPoints = $e + je,
                ie
            }
            function be(ht) {
                w(ht[0]) && (ht = [ht]);
                var X = "", ie = ht.length, _e, ke, Fe, Ce;
                for (ke = 0; ke < ie; ke++) {
                    for (Ce = ht[ke],
                    X += "M" + y(Ce[0]) + "," + y(Ce[1]) + " C",
                    _e = Ce.length,
                    Fe = 2; Fe < _e; Fe++)
                        X += y(Ce[Fe++]) + "," + y(Ce[Fe++]) + " " + y(Ce[Fe++]) + "," + y(Ce[Fe++]) + " " + y(Ce[Fe++]) + "," + y(Ce[Fe]) + " ";
                    Ce.closed && (X += "z")
                }
                return X
            }
            /*!
 * MorphSVGPlugin 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
            var fe, ge, J, re, ee, Y = function() {
                return fe || typeof window < "u" && (fe = window.gsap) && fe.registerPlugin && fe
            }, Z = function(X) {
                return typeof X == "function"
            }, Q = Math.atan2, ue = Math.cos, se = Math.sin, ye = Math.sqrt, Ze = Math.PI, qe = Ze * 2, nt = Ze * .3, mt = Ze * .7, yt = 1e20, At = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, Tt = /(^[#\.][a-z]|[a-y][a-z])/i, he = /[achlmqstvz]/i, ve = function(X) {
                return console && console.warn(X)
            }, ae = 1, ze = function(X) {
                var ie = X.length, _e = 0, ke = 0, Fe;
                for (Fe = 0; Fe < ie; Fe++)
                    _e += X[Fe++],
                    ke += X[Fe];
                return [_e / (ie / 2), ke / (ie / 2)]
            }, Se = function(X) {
                var ie = X.length, _e = X[0], ke = _e, Fe = X[1], Ce = Fe, $e, Ye, je;
                for (je = 6; je < ie; je += 6)
                    $e = X[je],
                    Ye = X[je + 1],
                    $e > _e ? _e = $e : $e < ke && (ke = $e),
                    Ye > Fe ? Fe = Ye : Ye < Ce && (Ce = Ye);
                return X.centerX = (_e + ke) / 2,
                X.centerY = (Fe + Ce) / 2,
                X.size = (_e - ke) * (Fe - Ce)
            }, Je = function(X, ie) {
                ie === void 0 && (ie = 3);
                for (var _e = X.length, ke = X[0][0], Fe = ke, Ce = X[0][1], $e = Ce, Ye = 1 / ie, je, vt, ot, Ve, ut, Ft, ft, gt, et, Oe, O, z, L, ne, le, Ie; --_e > -1; )
                    for (ut = X[_e],
                    je = ut.length,
                    Ve = 6; Ve < je; Ve += 6)
                        for (et = ut[Ve],
                        Oe = ut[Ve + 1],
                        O = ut[Ve + 2] - et,
                        ne = ut[Ve + 3] - Oe,
                        z = ut[Ve + 4] - et,
                        le = ut[Ve + 5] - Oe,
                        L = ut[Ve + 6] - et,
                        Ie = ut[Ve + 7] - Oe,
                        Ft = ie; --Ft > -1; )
                            ft = Ye * Ft,
                            gt = 1 - ft,
                            vt = (ft * ft * L + 3 * gt * (ft * z + gt * O)) * ft + et,
                            ot = (ft * ft * Ie + 3 * gt * (ft * le + gt * ne)) * ft + Oe,
                            vt > ke ? ke = vt : vt < Fe && (Fe = vt),
                            ot > Ce ? Ce = ot : ot < $e && ($e = ot);
                return X.centerX = (ke + Fe) / 2,
                X.centerY = (Ce + $e) / 2,
                X.left = Fe,
                X.width = ke - Fe,
                X.top = $e,
                X.height = Ce - $e,
                X.size = (ke - Fe) * (Ce - $e)
            }, I = function(X, ie) {
                return ie.length - X.length
            }, $ = function(X, ie) {
                var _e = X.size || Se(X)
                  , ke = ie.size || Se(ie);
                return Math.abs(ke - _e) < (_e + ke) / 20 ? ie.centerX - X.centerX || ie.centerY - X.centerY : ke - _e
            }, de = function(X, ie) {
                var _e = X.slice(0), ke = X.length, Fe = ke - 2, Ce, $e;
                for (ie = ie | 0,
                Ce = 0; Ce < ke; Ce++)
                    $e = (Ce + ie) % Fe,
                    X[Ce++] = _e[$e],
                    X[Ce] = _e[$e + 1]
            }, Me = function(X, ie, _e, ke, Fe) {
                var Ce = X.length, $e = 0, Ye = Ce - 2, je, vt, ot, Ve;
                for (_e *= 6,
                vt = 0; vt < Ce; vt += 6)
                    je = (vt + _e) % Ye,
                    Ve = X[je] - (ie[vt] - ke),
                    ot = X[je + 1] - (ie[vt + 1] - Fe),
                    $e += ye(ot * ot + Ve * Ve);
                return $e
            }, Te = function(X, ie, _e) {
                var ke = X.length, Fe = ze(X), Ce = ze(ie), $e = Ce[0] - Fe[0], Ye = Ce[1] - Fe[1], je = Me(X, ie, 0, $e, Ye), vt = 0, ot, Ve, ut;
                for (ut = 6; ut < ke; ut += 6)
                    Ve = Me(X, ie, ut / 6, $e, Ye),
                    Ve < je && (je = Ve,
                    vt = ut);
                if (_e)
                    for (ot = X.slice(0),
                    P(ot),
                    ut = 6; ut < ke; ut += 6)
                        Ve = Me(ot, ie, ut / 6, $e, Ye),
                        Ve < je && (je = Ve,
                        vt = -ut);
                return vt / 6
            }, Ne = function(X, ie, _e) {
                for (var ke = X.length, Fe = yt, Ce = 0, $e = 0, Ye, je, vt, ot, Ve, ut; --ke > -1; )
                    for (Ye = X[ke],
                    ut = Ye.length,
                    Ve = 0; Ve < ut; Ve += 6)
                        je = Ye[Ve] - ie,
                        vt = Ye[Ve + 1] - _e,
                        ot = ye(je * je + vt * vt),
                        ot < Fe && (Fe = ot,
                        Ce = Ye[Ve],
                        $e = Ye[Ve + 1]);
                return [Ce, $e]
            }, lt = function(X, ie, _e, ke, Fe, Ce) {
                var $e = ie.length, Ye = 0, je = Math.min(X.size || Se(X), ie[_e].size || Se(ie[_e])) * ke, vt = yt, ot = X.centerX + Fe, Ve = X.centerY + Ce, ut, Ft, ft, gt, et;
                for (Ft = _e; Ft < $e && (ut = ie[Ft].size || Se(ie[Ft]),
                !(ut < je)); Ft++)
                    ft = ie[Ft].centerX - ot,
                    gt = ie[Ft].centerY - Ve,
                    et = ye(ft * ft + gt * gt),
                    et < vt && (Ye = Ft,
                    vt = et);
                return et = ie[Ye],
                ie.splice(Ye, 1),
                et
            }, st = function(X, ie) {
                var _e = 0, ke = .999999, Fe = X.length, Ce = ie / ((Fe - 2) / 6), $e, Ye, je, vt, ot, Ve, ut, Ft, ft, gt, et, Oe, O, z;
                for (O = 2; O < Fe; O += 6)
                    for (_e += Ce; _e > ke; )
                        $e = X[O - 2],
                        Ye = X[O - 1],
                        je = X[O],
                        vt = X[O + 1],
                        ot = X[O + 2],
                        Ve = X[O + 3],
                        ut = X[O + 4],
                        Ft = X[O + 5],
                        z = 1 / ((Math.floor(_e) || 1) + 1),
                        ft = $e + (je - $e) * z,
                        et = je + (ot - je) * z,
                        ft += (et - ft) * z,
                        et += (ot + (ut - ot) * z - et) * z,
                        gt = Ye + (vt - Ye) * z,
                        Oe = vt + (Ve - vt) * z,
                        gt += (Oe - gt) * z,
                        Oe += (Ve + (Ft - Ve) * z - Oe) * z,
                        X.splice(O, 4, $e + (je - $e) * z, Ye + (vt - Ye) * z, ft, gt, ft + (et - ft) * z, gt + (Oe - gt) * z, et, Oe, ot + (ut - ot) * z, Ve + (Ft - Ve) * z),
                        O += 6,
                        Fe += 6,
                        _e--;
                return X
            }, Ue = function(X, ie, _e, ke, Fe) {
                var Ce = ie.length - X.length, $e = Ce > 0 ? ie : X, Ye = Ce > 0 ? X : ie, je = 0, vt = ke === "complexity" ? I : $, ot = ke === "position" ? 0 : typeof ke == "number" ? ke : .8, Ve = Ye.length, ut = typeof _e == "object" && _e.push ? _e.slice(0) : [_e], Ft = ut[0] === "reverse" || ut[0] < 0, ft = _e === "log", gt, et, Oe, O, z, L, ne;
                if (Ye[0]) {
                    if ($e.length > 1 && (X.sort(vt),
                    ie.sort(vt),
                    L = $e.size || Je($e),
                    L = Ye.size || Je(Ye),
                    L = $e.centerX - Ye.centerX,
                    ne = $e.centerY - Ye.centerY,
                    vt === $))
                        for (Ve = 0; Ve < Ye.length; Ve++)
                            $e.splice(Ve, 0, lt(Ye[Ve], $e, Ve, ot, L, ne));
                    if (Ce)
                        for (Ce < 0 && (Ce = -Ce),
                        $e[0].length > Ye[0].length && st(Ye[0], ($e[0].length - Ye[0].length) / 6 | 0),
                        Ve = Ye.length; je < Ce; )
                            O = $e[Ve].size || Se($e[Ve]),
                            Oe = Ne(Ye, $e[Ve].centerX, $e[Ve].centerY),
                            O = Oe[0],
                            z = Oe[1],
                            Ye[Ve++] = [O, z, O, z, O, z, O, z],
                            Ye.totalPoints += 8,
                            je++;
                    for (Ve = 0; Ve < X.length; Ve++)
                        gt = ie[Ve],
                        et = X[Ve],
                        Ce = gt.length - et.length,
                        Ce < 0 ? st(gt, -Ce / 6 | 0) : Ce > 0 && st(et, Ce / 6 | 0),
                        Ft && Fe !== !1 && !et.reversed && P(et),
                        _e = ut[Ve] || ut[Ve] === 0 ? ut[Ve] : "auto",
                        _e && (et.closed || Math.abs(et[0] - et[et.length - 2]) < .5 && Math.abs(et[1] - et[et.length - 1]) < .5 ? _e === "auto" || _e === "log" ? (ut[Ve] = _e = Te(et, gt, !Ve || Fe === !1),
                        _e < 0 && (Ft = !0,
                        P(et),
                        _e = -_e),
                        de(et, _e * 6)) : _e !== "reverse" && (Ve && _e < 0 && P(et),
                        de(et, (_e < 0 ? -_e : _e) * 6)) : !Ft && (_e === "auto" && Math.abs(gt[0] - et[0]) + Math.abs(gt[1] - et[1]) + Math.abs(gt[gt.length - 2] - et[et.length - 2]) + Math.abs(gt[gt.length - 1] - et[et.length - 1]) > Math.abs(gt[0] - et[et.length - 2]) + Math.abs(gt[1] - et[et.length - 1]) + Math.abs(gt[gt.length - 2] - et[0]) + Math.abs(gt[gt.length - 1] - et[1]) || _e % 2) ? (P(et),
                        ut[Ve] = -1,
                        Ft = !0) : _e === "auto" ? ut[Ve] = 0 : _e === "reverse" && (ut[Ve] = -1),
                        et.closed !== gt.closed && (et.closed = gt.closed = !1));
                    return ft && ve("shapeIndex:[" + ut.join(",") + "]"),
                    X.shapeIndex = ut,
                    ut
                }
            }, Ge = function(X, ie, _e, ke, Fe) {
                var Ce = K(X[0])
                  , $e = K(X[1]);
                Ue(Ce, $e, ie || ie === 0 ? ie : "auto", _e, Fe) && (X[0] = be(Ce),
                X[1] = be($e),
                (ke === "log" || ke === !0) && ve('precompile:["' + X[0] + '","' + X[1] + '"]'))
            }, wt = function(X, ie) {
                if (!ie)
                    return X;
                var _e = X.match(At) || [], ke = _e.length, Fe = "", Ce, $e, Ye;
                for (ie === "reverse" ? ($e = ke - 1,
                Ce = -2) : ($e = ((parseInt(ie, 10) || 0) * 2 + 1 + ke * 100) % ke,
                Ce = 2),
                Ye = 0; Ye < ke; Ye += 2)
                    Fe += _e[$e - 1] + "," + _e[$e] + " ",
                    $e = ($e + Ce) % ke;
                return Fe
            }, rt = function(X, ie) {
                var _e = 0, ke = parseFloat(X[0]), Fe = parseFloat(X[1]), Ce = ke + "," + Fe + " ", $e = .999999, Ye, je, vt, ot, Ve, ut, Ft;
                for (vt = X.length,
                Ye = ie * .5 / (vt * .5 - 1),
                je = 0; je < vt - 2; je += 2) {
                    if (_e += Ye,
                    ut = parseFloat(X[je + 2]),
                    Ft = parseFloat(X[je + 3]),
                    _e > $e)
                        for (Ve = 1 / (Math.floor(_e) + 1),
                        ot = 1; _e > $e; )
                            Ce += (ke + (ut - ke) * Ve * ot).toFixed(2) + "," + (Fe + (Ft - Fe) * Ve * ot).toFixed(2) + " ",
                            _e--,
                            ot++;
                    Ce += ut + "," + Ft + " ",
                    ke = ut,
                    Fe = Ft
                }
                return Ce
            }, Dt = function(X) {
                var ie = X[0].match(At) || []
                  , _e = X[1].match(At) || []
                  , ke = _e.length - ie.length;
                ke > 0 ? X[0] = rt(ie, ke) : X[1] = rt(_e, -ke)
            }, xt = function(X) {
                return isNaN(X) ? Dt : function(ie) {
                    Dt(ie),
                    ie[1] = wt(ie[1], parseInt(X, 10))
                }
            }, Lt = function(X, ie, _e) {
                var ke = typeof X == "string", Fe, Ce;
                return (!ke || Tt.test(X) || (X.match(At) || []).length < 3) && (Fe = ge(X)[0],
                Fe ? (Ce = (Fe.nodeName + "").toUpperCase(),
                ie && Ce !== "PATH" && (Fe = S(Fe, !1),
                Ce = "PATH"),
                X = Fe.getAttribute(Ce === "PATH" ? "d" : "points") || "",
                Fe === _e && (X = Fe.getAttributeNS(null, "data-original") || X)) : (ve("WARNING: invalid morph to: " + X),
                X = !1)),
                X
            }, Jt = function(X, ie) {
                for (var _e = X.length, ke = .2 * (ie || 1), Fe, Ce, $e, Ye, je, vt, ot, Ve, ut, Ft, ft, gt; --_e > -1; ) {
                    for (Ce = X[_e],
                    ft = Ce.isSmooth = Ce.isSmooth || [0, 0, 0, 0],
                    gt = Ce.smoothData = Ce.smoothData || [0, 0, 0, 0],
                    ft.length = 4,
                    Ve = Ce.length - 2,
                    ot = 6; ot < Ve; ot += 6)
                        $e = Ce[ot] - Ce[ot - 2],
                        Ye = Ce[ot + 1] - Ce[ot - 1],
                        je = Ce[ot + 2] - Ce[ot],
                        vt = Ce[ot + 3] - Ce[ot + 1],
                        ut = Q(Ye, $e),
                        Ft = Q(vt, je),
                        Fe = Math.abs(ut - Ft) < ke,
                        Fe && (gt[ot - 2] = ut,
                        gt[ot + 2] = Ft,
                        gt[ot - 1] = ye($e * $e + Ye * Ye),
                        gt[ot + 3] = ye(je * je + vt * vt)),
                        ft.push(Fe, Fe, 0, 0, Fe, Fe);
                    Ce[Ve] === Ce[0] && Ce[Ve + 1] === Ce[1] && ($e = Ce[0] - Ce[Ve - 2],
                    Ye = Ce[1] - Ce[Ve - 1],
                    je = Ce[2] - Ce[0],
                    vt = Ce[3] - Ce[1],
                    ut = Q(Ye, $e),
                    Ft = Q(vt, je),
                    Math.abs(ut - Ft) < ke && (gt[Ve - 2] = ut,
                    gt[2] = Ft,
                    gt[Ve - 1] = ye($e * $e + Ye * Ye),
                    gt[3] = ye(je * je + vt * vt),
                    ft[Ve - 2] = ft[Ve - 1] = !0))
                }
                return X
            }, fn = function(X) {
                var ie = X.trim().split(" ")
                  , _e = ~X.indexOf("left") ? 0 : ~X.indexOf("right") ? 100 : isNaN(parseFloat(ie[0])) ? 50 : parseFloat(ie[0])
                  , ke = ~X.indexOf("top") ? 0 : ~X.indexOf("bottom") ? 100 : isNaN(parseFloat(ie[1])) ? 50 : parseFloat(ie[1]);
                return {
                    x: _e / 100,
                    y: ke / 100
                }
            }, Fn = function(X) {
                return X !== X % Ze ? X + (X < 0 ? qe : -qe) : X
            }, hn = "Use MorphSVGPlugin.convertToPath() to convert to a path before morphing.", Ln = function(X, ie, _e, ke) {
                var Fe = this._origin, Ce = this._eOrigin, $e = X[_e] - Fe.x, Ye = X[_e + 1] - Fe.y, je = ye($e * $e + Ye * Ye), vt = Q(Ye, $e), ot, Ve;
                return $e = ie[_e] - Ce.x,
                Ye = ie[_e + 1] - Ce.y,
                ot = Q(Ye, $e) - vt,
                Ve = Fn(ot),
                !ke && J && Math.abs(Ve + J.ca) < nt && (ke = J),
                this._anchorPT = J = {
                    _next: this._anchorPT,
                    t: X,
                    sa: vt,
                    ca: ke && Ve * ke.ca < 0 && Math.abs(Ve) > mt ? ot : Ve,
                    sl: je,
                    cl: ye($e * $e + Ye * Ye) - je,
                    i: _e
                }
            }, Kn = function(X) {
                fe = Y(),
                ee = ee || fe && fe.plugins.morphSVG,
                fe && ee ? (ge = fe.utils.toArray,
                ee.prototype._tweenRotation = Ln,
                re = 1) : X && ve("Please gsap.registerPlugin(MorphSVGPlugin)")
            }, lr = {
                version: "3.13.0",
                name: "morphSVG",
                rawVars: 1,
                register: function(X, ie) {
                    fe = X,
                    ee = ie,
                    Kn()
                },
                init: function(X, ie, _e, ke, Fe) {
                    if (re || Kn(1),
                    !ie)
                        return ve("invalid shape"),
                        !1;
                    Z(ie) && (ie = ie.call(_e, ke, X, Fe));
                    var Ce, $e, Ye, je, vt, ot, Ve, ut, Ft, ft, gt, et, Oe, O, z, L, ne, le, Ie, ct, F, b;
                    if (typeof ie == "string" || ie.getBBox || ie[0])
                        ie = {
                            shape: ie
                        };
                    else if (typeof ie == "object") {
                        Ce = {};
                        for ($e in ie)
                            Ce[$e] = Z(ie[$e]) && $e !== "render" ? ie[$e].call(_e, ke, X, Fe) : ie[$e];
                        ie = Ce
                    }
                    var T = X.nodeType ? window.getComputedStyle(X) : {}
                      , M = T.fill + ""
                      , H = !(M === "none" || (M.match(At) || [])[3] === "0" || T.fillRule === "evenodd")
                      , G = (ie.origin || "50 50").split(",");
                    if (Ce = (X.nodeName + "").toUpperCase(),
                    vt = Ce === "POLYLINE" || Ce === "POLYGON",
                    Ce !== "PATH" && !vt && !ie.prop)
                        return ve("Cannot morph a <" + Ce + "> element. " + hn),
                        !1;
                    if ($e = Ce === "PATH" ? "d" : "points",
                    !ie.prop && !Z(X.setAttribute))
                        return !1;
                    if (je = Lt(ie.shape || ie.d || ie.points || "", $e === "d", X),
                    vt && he.test(je))
                        return ve("A <" + Ce + "> cannot accept path data. " + hn),
                        !1;
                    if (ot = ie.shapeIndex || ie.shapeIndex === 0 ? ie.shapeIndex : "auto",
                    Ve = ie.map || lr.defaultMap,
                    this._prop = ie.prop,
                    this._render = ie.render || lr.defaultRender,
                    this._apply = "updateTarget"in ie ? ie.updateTarget : lr.defaultUpdateTarget,
                    this._rnd = Math.pow(10, isNaN(ie.precision) ? 2 : +ie.precision),
                    this._tween = _e,
                    je) {
                        if (this._target = X,
                        ne = typeof ie.precompile == "object",
                        ft = this._prop ? X[this._prop] : X.getAttribute($e),
                        !this._prop && !X.getAttributeNS(null, "data-original") && X.setAttributeNS(null, "data-original", ft),
                        $e === "d" || this._prop) {
                            if (ft = K(ne ? ie.precompile[0] : ft),
                            gt = K(ne ? ie.precompile[1] : je),
                            !ne && !Ue(ft, gt, ot, Ve, H))
                                return !1;
                            for ((ie.precompile === "log" || ie.precompile === !0) && ve('precompile:["' + be(ft) + '","' + be(gt) + '"]'),
                            F = (ie.type || lr.defaultType) !== "linear",
                            F && (ft = Jt(ft, ie.smoothTolerance),
                            gt = Jt(gt, ie.smoothTolerance),
                            ft.size || Je(ft),
                            gt.size || Je(gt),
                            ct = fn(G[0]),
                            this._origin = ft.origin = {
                                x: ft.left + ct.x * ft.width,
                                y: ft.top + ct.y * ft.height
                            },
                            G[1] && (ct = fn(G[1])),
                            this._eOrigin = {
                                x: gt.left + ct.x * gt.width,
                                y: gt.top + ct.y * gt.height
                            }),
                            this._rawPath = X._gsRawPath = ft,
                            Oe = ft.length; --Oe > -1; )
                                for (z = ft[Oe],
                                L = gt[Oe],
                                ut = z.isSmooth || [],
                                Ft = L.isSmooth || [],
                                O = z.length,
                                J = 0,
                                et = 0; et < O; et += 2)
                                    (L[et] !== z[et] || L[et + 1] !== z[et + 1]) && (F ? ut[et] && Ft[et] ? (le = z.smoothData,
                                    Ie = L.smoothData,
                                    b = et + (et === O - 4 ? 7 - O : 5),
                                    this._controlPT = {
                                        _next: this._controlPT,
                                        i: et,
                                        j: Oe,
                                        l1s: le[et + 1],
                                        l1c: Ie[et + 1] - le[et + 1],
                                        l2s: le[b],
                                        l2c: Ie[b] - le[b]
                                    },
                                    Ye = this._tweenRotation(z, L, et + 2),
                                    this._tweenRotation(z, L, et, Ye),
                                    this._tweenRotation(z, L, b - 1, Ye),
                                    et += 4) : this._tweenRotation(z, L, et) : (Ye = this.add(z, et, z[et], L[et], 0, 0, 0, 0, 0, 1),
                                    Ye = this.add(z, et + 1, z[et + 1], L[et + 1], 0, 0, 0, 0, 0, 1) || Ye))
                        } else
                            Ye = this.add(X, "setAttribute", X.getAttribute($e) + "", je + "", ke, Fe, 0, xt(ot), $e);
                        F && (this.add(this._origin, "x", this._origin.x, this._eOrigin.x, 0, 0, 0, 0, 0, 1),
                        Ye = this.add(this._origin, "y", this._origin.y, this._eOrigin.y, 0, 0, 0, 0, 0, 1)),
                        Ye && (this._props.push("morphSVG"),
                        Ye.end = je,
                        Ye.endProp = $e)
                    }
                    return ae
                },
                render: function(X, ie) {
                    for (var _e = ie._rawPath, ke = ie._controlPT, Fe = ie._anchorPT, Ce = ie._rnd, $e = ie._target, Ye = ie._pt, je, vt, ot, Ve, ut, Ft, ft, gt, et, Oe, O, z, L; Ye; )
                        Ye.r(X, Ye.d),
                        Ye = Ye._next;
                    if (X === 1 && ie._apply)
                        for (Ye = ie._pt; Ye; )
                            Ye.end && (ie._prop ? $e[ie._prop] = Ye.end : $e.setAttribute(Ye.endProp, Ye.end)),
                            Ye = Ye._next;
                    else if (_e) {
                        for (; Fe; )
                            Ft = Fe.sa + X * Fe.ca,
                            ut = Fe.sl + X * Fe.cl,
                            Fe.t[Fe.i] = ie._origin.x + ue(Ft) * ut,
                            Fe.t[Fe.i + 1] = ie._origin.y + se(Ft) * ut,
                            Fe = Fe._next;
                        for (ot = X < .5 ? 2 * X * X : (4 - 2 * X) * X - 1; ke; )
                            ft = ke.i,
                            Ve = _e[ke.j],
                            L = ft + (ft === Ve.length - 4 ? 7 - Ve.length : 5),
                            Ft = Q(Ve[L] - Ve[ft + 1], Ve[L - 1] - Ve[ft]),
                            O = se(Ft),
                            z = ue(Ft),
                            et = Ve[ft + 2],
                            Oe = Ve[ft + 3],
                            ut = ke.l1s + ot * ke.l1c,
                            Ve[ft] = et - z * ut,
                            Ve[ft + 1] = Oe - O * ut,
                            ut = ke.l2s + ot * ke.l2c,
                            Ve[L - 1] = et + z * ut,
                            Ve[L] = Oe + O * ut,
                            ke = ke._next;
                        if ($e._gsRawPath = _e,
                        ie._apply) {
                            for (je = "",
                            vt = " ",
                            gt = 0; gt < _e.length; gt++)
                                for (Ve = _e[gt],
                                ut = Ve.length,
                                je += "M" + (Ve[0] * Ce | 0) / Ce + vt + (Ve[1] * Ce | 0) / Ce + " C",
                                ft = 2; ft < ut; ft++)
                                    je += (Ve[ft] * Ce | 0) / Ce + vt;
                            ie._prop ? $e[ie._prop] = je : $e.setAttribute("d", je)
                        }
                    }
                    ie._render && _e && ie._render.call(ie._tween, _e, $e)
                },
                kill: function(X) {
                    this._pt = this._rawPath = 0
                },
                getRawPath: R,
                stringToRawPath: K,
                rawPathToString: be,
                normalizeStrings: function(X, ie, _e) {
                    var ke = _e.shapeIndex
                      , Fe = _e.map
                      , Ce = [X, ie];
                    return Ge(Ce, ke, Fe),
                    Ce
                },
                pathFilter: Ge,
                pointsFilter: Dt,
                getTotalSize: Je,
                equalizeSegmentQuantity: Ue,
                convertToPath: function(X, ie) {
                    return ge(X).map(function(_e) {
                        return S(_e, ie !== !1)
                    })
                },
                defaultType: "linear",
                defaultUpdateTarget: !0,
                defaultMap: "size"
            };
            Y() && fe.registerPlugin(lr),
            n.MorphSVGPlugin = lr,
            n.default = lr,
            Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(Yl, Yl.exports)),
    Yl.exports
}
var r2 = n2();
const i2 = la(r2);
var Kl = {
    exports: {}
}, s2 = Kl.exports, Rg;
function o2() {
    return Rg || (Rg = 1,
    function(e, t) {
        (function(n, r) {
            r(t)
        }
        )(s2, function(n) {
            var r = /(?:^\s+|\s+$)/g
              , i = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2642\u2640]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDD27\uDCBC\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCC\uDFCB]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
            function s(v) {
                var k = v.nodeType
                  , S = "";
                if (k === 1 || k === 9 || k === 11) {
                    if (typeof v.textContent == "string")
                        return v.textContent;
                    for (v = v.firstChild; v; v = v.nextSibling)
                        S += s(v)
                } else if (k === 3 || k === 4)
                    return v.nodeValue;
                return S
            }
            function o(v, k, S, W, K) {
                if (v += "",
                S && (v = v.trim ? v.trim() : v.replace(r, "")),
                k && k !== "")
                    return v.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(k);
                for (var be = [], fe = v.length, ge = 0, J, re; ge < fe; ge++)
                    re = v.charAt(ge),
                    (re.charCodeAt(0) >= 55296 && re.charCodeAt(0) <= 56319 || v.charCodeAt(ge + 1) >= 65024 && v.charCodeAt(ge + 1) <= 65039) && (J = ((v.substr(ge, 12).split(i) || [])[1] || "").length || 2,
                    re = v.substr(ge, J),
                    be.emoji = 1,
                    ge += J - 1),
                    be.push(K ? re : re === ">" ? "&gt;" : re === "<" ? "&lt;" : W && re === " " && (v.charAt(ge - 1) === " " || v.charAt(ge + 1) === " ") ? "&nbsp;" : re);
                return be
            }
            /*!
 * ScrambleTextPlugin 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
            var l = function() {
                function v(S) {
                    this.chars = o(S),
                    this.sets = [],
                    this.length = 50;
                    for (var W = 0; W < 20; W++)
                        this.sets[W] = w(80, this.chars)
                }
                var k = v.prototype;
                return k.grow = function(W) {
                    for (var K = 0; K < 20; K++)
                        this.sets[K] += w(W - this.length, this.chars);
                    this.length = W
                }
                ,
                v
            }(), u, p, h = function() {
                return u || typeof window < "u" && (u = window.gsap) && u.registerPlugin && u
            }, g = 1, m = /\s+/g, w = function(k, S) {
                for (var W = S.length, K = ""; --k > -1; )
                    K += S[~~(Math.random() * W)];
                return K
            }, E = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", y = E.toLowerCase(), R = {
                upperCase: new l(E),
                lowerCase: new l(y),
                upperAndLowerCase: new l(E + y)
            }, P = function() {
                p = u = h()
            }, x = {
                version: "3.13.0",
                name: "scrambleText",
                register: function(k, S, W) {
                    u = k,
                    P()
                },
                init: function(k, S, W, K, be) {
                    if (p || P(),
                    this.prop = "innerHTML"in k ? "innerHTML" : "textContent"in k ? "textContent" : 0,
                    !!this.prop) {
                        this.target = k,
                        typeof S != "object" && (S = {
                            text: S
                        });
                        var fe = S.text || S.value || "", ge = S.trim !== !1, J = this, re, ee, Y, Z;
                        return J.delimiter = re = S.delimiter || "",
                        J.original = o(s(k).replace(m, " ").split("&nbsp;").join(""), re, ge),
                        (fe === "{original}" || fe === !0 || fe == null) && (fe = J.original.join(re)),
                        J.text = o((fe || "").replace(m, " "), re, ge),
                        J.hasClass = !!(S.newClass || S.oldClass),
                        J.newClass = S.newClass,
                        J.oldClass = S.oldClass,
                        Z = re === "",
                        J.textHasEmoji = Z && !!J.text.emoji,
                        J.charsHaveEmoji = !!S.chars && !!o(S.chars).emoji,
                        J.length = Z ? J.original.length : J.original.join(re).length,
                        J.lengthDif = (Z ? J.text.length : J.text.join(re).length) - J.length,
                        J.fillChar = S.fillChar || S.chars && ~S.chars.indexOf(" ") ? "&nbsp;" : "",
                        J.charSet = Y = R[S.chars || "upperCase"] || new l(S.chars),
                        J.speed = .05 / (S.speed || 1),
                        J.prevScrambleTime = 0,
                        J.setIndex = Math.random() * 20 | 0,
                        ee = J.length + Math.max(J.lengthDif, 0),
                        ee > Y.length && Y.grow(ee),
                        J.chars = Y.sets[J.setIndex],
                        J.revealDelay = S.revealDelay || 0,
                        J.tweenLength = S.tweenLength !== !1,
                        J.tween = W,
                        J.rightToLeft = !!S.rightToLeft,
                        J._props.push("scrambleText", "text"),
                        g
                    }
                },
                render: function(k, S) {
                    var W = S.target, K = S.prop, be = S.text, fe = S.delimiter, ge = S.tween, J = S.prevScrambleTime, re = S.revealDelay, ee = S.setIndex, Y = S.chars, Z = S.charSet, Q = S.length, ue = S.textHasEmoji, se = S.charsHaveEmoji, ye = S.lengthDif, Ze = S.tweenLength, qe = S.oldClass, nt = S.newClass, mt = S.rightToLeft, yt = S.fillChar, At = S.speed, Tt = S.original, he = S.hasClass, ve = be.length, ae = ge._time, ze = ae - J, Se, Je, I, $, de, Me, Te, Ne, lt, st, Ue;
                    re && (ge._from && (ae = ge._dur - ae),
                    k = ae === 0 ? 0 : ae < re ? 1e-6 : ae === ge._dur ? 1 : ge._ease((ae - re) / (ge._dur - re))),
                    k < 0 ? k = 0 : k > 1 && (k = 1),
                    mt && (k = 1 - k),
                    Se = ~~(k * ve + .5),
                    k ? ((ze > At || ze < -At) && (S.setIndex = ee = (ee + (Math.random() * 19 | 0)) % 20,
                    S.chars = Z.sets[ee],
                    S.prevScrambleTime += ze),
                    $ = Y) : $ = Tt.join(fe),
                    Ue = ge._from ? k : 1 - k,
                    st = Q + (Ze ? ge._from ? Ue * Ue * Ue : 1 - Ue * Ue * Ue : 1) * ye,
                    mt ? k === 1 && (ge._from || ge.data === "isFromStart") ? (I = "",
                    $ = Tt.join(fe)) : (Te = be.slice(Se).join(fe),
                    se ? I = o($).slice(0, st - (ue ? o(Te) : Te).length + .5 | 0).join("") : I = $.substr(0, st - (ue ? o(Te) : Te).length + .5 | 0),
                    $ = Te) : (I = be.slice(0, Se).join(fe),
                    Je = (ue ? o(I) : I).length,
                    se ? $ = o($).slice(Je, st + .5 | 0).join("") : $ = $.substr(Je, st - Je + .5 | 0)),
                    he ? (Ne = mt ? qe : nt,
                    lt = mt ? nt : qe,
                    de = Ne && Se !== 0,
                    Me = lt && Se !== ve,
                    Te = (de ? "<span class='" + Ne + "'>" : "") + I + (de ? "</span>" : "") + (Me ? "<span class='" + lt + "'>" : "") + fe + $ + (Me ? "</span>" : "")) : Te = I + fe + $,
                    W[K] = yt === "&nbsp;" && ~Te.indexOf("  ") ? Te.split("  ").join("&nbsp;&nbsp;") : Te
                }
            };
            x.emojiSafeSplit = o,
            x.getText = s,
            h() && u.registerPlugin(x),
            n.ScrambleTextPlugin = x,
            n.default = x,
            Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })
    }(Kl, Kl.exports)),
    Kl.exports
}
var a2 = o2();
const l2 = la(a2);
var bu = (e, t, n) => (1 - n) * e + n * t
  , u2 = (e, t, n) => {
    const r = bu(Math.cos(e), Math.cos(t), n)
      , i = bu(Math.sin(e), Math.sin(t), n);
    return Math.atan2(i, r)
}
  , c2 = (e, t, n, r) => bu(e, t, 1 - Math.exp(-n * r))
  , Y0 = (e, t, n) => Math.max(Math.min(e, n), t)
  , K0 = (e, t, n, r) => {
    const i = (e - t) / (n - t);
    return (r == null ? void 0 : r.clamp) === !0 ? Y0(i, 0, 1) : i
}
  , f2 = (e, t, n, r, i, s) => bu(r, i, K0(e, t, n, s))
  , Vd = (e, t) => (t = t === void 0 ? 100 : 10 ** t,
Math.round(e * t) / t)
  , d2 = (e, t, n) => Vd(e, n) === Vd(t, n) ? Math.round(t) : e
  , Bc = {
    int: (e, t) => Math.floor(t === void 0 ? Bc.range(0, e) : Bc.range(e, t)),
    range: (e, t) => Math.random() * (t - e),
    arr: e => e[Math.floor(Math.random() * e.length)]
}
  , h2 = {
    create: e => [...Array(e).keys()],
    shuffle: e => {
        for (let t = e.length - 1; t > 0; t--) {
            const n = Math.floor(Math.random() * (t + 1));
            [e[t],e[n]] = [e[n], e[t]]
        }
        return e
    }
    ,
    rand: Bc.arr,
    shift: (e, t) => e.length === 0 || t < 0 || t >= e.length ? e : [...e.slice(t), ...e.slice(0, t)],
    spliceNth: (e, t) => {
        if (t <= 0)
            throw new Error("Step size must be greater than 0");
        const n = [];
        let r = 0;
        for (let i = 0; i < e.length; i++)
            i % t === 0 ? n.push(e[i]) : e[r++] = e[i];
        return e.length = r,
        n
    }
}
  , p2 = e => 9 < e ? "" + e : "0" + e
  , g2 = {
    add: (e, t) => {
        e.classList.add(t)
    }
    ,
    remove: (e, t) => {
        e.classList.remove(t)
    }
    ,
    toggle: (e, t, n) => {
        e.classList.toggle(t, n)
    }
};
function _2(e, t) {
    return t in e && e[t] != null
}
var m2 = (e, t) => (e % t + t) % t
  , y2 = {
    expo: {
        expo: In.gsap.parseEase("expo"),
        expoInOut: In.gsap.parseEase("expo.inOut"),
        expoIn: In.gsap.parseEase("expo.in"),
        expoOut: In.gsap.parseEase("expo.out")
    },
    pow1: {
        in: In.gsap.parseEase("power1.in"),
        out: In.gsap.parseEase("power1.out"),
        inOut: In.gsap.parseEase("power1.inOut")
    },
    pow2: {
        in: In.gsap.parseEase("power2.in"),
        out: In.gsap.parseEase("power2.out"),
        inOut: In.gsap.parseEase("power2.inOut")
    },
    pow3: {
        in: In.gsap.parseEase("power3.in"),
        out: In.gsap.parseEase("power3.out"),
        inOut: In.gsap.parseEase("power3.inOut")
    },
    pow4: {
        in: In.gsap.parseEase("power4.in"),
        out: In.gsap.parseEase("power4.out"),
        inOut: In.gsap.parseEase("power4.inOut")
    }
}
  , pl = {
    Lerp: bu,
    rLerp: u2,
    iLerp: K0,
    Damp: c2,
    map: f2,
    Clamp: Y0,
    Round: Vd,
    RoundWhenClose: d2,
    Rand: Bc,
    Arr: h2,
    Digit: p2,
    isKeyOf: _2,
    Class: g2,
    mod: m2,
    Ease: y2
}
  , v2 = (e, t, n) => {
    const {noTrailing: r=!1, noLeading: i=!1, debounceMode: s=void 0} = {};
    let o, l = !1, u = 0;
    const p = () => {
        o && clearTimeout(o)
    }
      , h = m => {
        const {upcomingOnly: w=!1} = m || {};
        p(),
        l = !w
    }
    ;
    function g(...m) {
        const w = this
          , E = Date.now() - u;
        if (l)
            return;
        const y = () => {
            u = Date.now(),
            t.apply(w, m)
        }
          , R = () => {
            o = void 0
        }
        ;
        !i && s && !o && y(),
        p(),
        s === void 0 && E > e ? i ? (u = Date.now(),
        r || (o = setTimeout(s ? R : y, e))) : y() : r !== !0 && (o = setTimeout(s ? R : y, s === void 0 ? e - E : e))
    }
    return g.cancel = h,
    g
}
;
class b2 {
    constructor() {
        St(this, "width", 0);
        St(this, "height", 0);
        St(this, "previousWidth", 0);
        St(this, "previousHeight", 0);
        St(this, "fakeFullHeight", 0);
        St(this, "iOS", !1);
        St(this, "isMobile", !1);
        St(this, "isWindows", !1);
        St(this, "breakpoints", []);
        St(this, "pointerMatchMedia", null);
        St(this, "updateFns", []);
        St(this, "internalResize", () => {
            let t = !1;
            return this.previousWidth = this.width,
            this.previousHeight = this.height,
            this.width = window.innerWidth,
            this.height = window.innerHeight,
            this.isMobile && this.previousWidth === this.width && this.previousHeight <= this.height ? this.height = this.previousHeight : t = !0,
            this.isMobile && this.width > this.height && (this.height = window.innerHeight,
            t = !0),
            this.checkBreakpoints(),
            t && this.setProperties(),
            t
        }
        );
        St(this, "onResize", () => {
            this.internalResize() && (this.updateNoThrottle(),
            this.updateThrottled())
        }
        );
        St(this, "updateNoThrottle", () => {
            this.updateFns.filter(t => t.noThrottle).forEach(t => t.fn({
                width: this.width,
                height: this.height
            }, this))
        }
        );
        St(this, "updateThrottled", v2(200, () => {
            this.updateFns.filter(t => !t.noThrottle).forEach(t => t.fn({
                width: this.width,
                height: this.height
            }, this)),
            setTimeout( () => {
                ka.refresh()
            }
            , 1)
        }
        ));
        St(this, "onPointerChange", t => {
            this.isMobile = !t.matches || this.iOS
        }
        );
        typeof window < "u" && (this.pointerMatchMedia = window.matchMedia("(hover: hover)"),
        this.checkDevice())
    }
    checkDevice() {
        this.iOS = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend"in document,
        this.isWindows = navigator.userAgent.includes("Windows"),
        this.isMobile = !this.pointerMatchMedia.matches || this.iOS
    }
    getFullVh() {
        const t = document.createElement("div");
        t.style.cssText = "position:fixed;top:0;left:0;height:100vh;visibility:hidden;pointer-events:none;",
        document.body.appendChild(t);
        const n = t.offsetHeight;
        return document.body.removeChild(t),
        n
    }
    setProperties() {
        if (this.isMobile) {
            document.documentElement.style.setProperty("--vw", document.documentElement.clientWidth * .01 + "px"),
            document.documentElement.style.setProperty("--vh", `${(window.screen.height || window.innerHeight) / 100}px`),
            document.documentElement.style.setProperty("--dvh", window.innerHeight * .01 + "px"),
            document.documentElement.style.setProperty("--svh", document.documentElement.clientHeight * .01 + "px"),
            document.documentElement.style.setProperty("--lvh", `${(window.screen.height || window.innerHeight) / 100}px`);
            return
        }
        document.documentElement.style.setProperty("--vw", "1vw"),
        document.documentElement.style.setProperty("--vh", "1vh"),
        document.documentElement.style.setProperty("--dvh", "1dvh"),
        document.documentElement.style.setProperty("--svh", "1svh"),
        document.documentElement.style.setProperty("--lvh", "1lvh")
    }
    checkBreakpoints() {
        for (const t of this.breakpoints)
            t.active = this.width >= t.size
    }
    setBreakpoints(t) {
        this.breakpoints = t.map(n => ({
            ...n,
            active: !1
        }))
    }
    add(t, n=0, r=!1, i=!1) {
        const s = {
            fn: t,
            priority: n,
            noThrottle: r
        };
        return this.updateFns.push(s),
        this.updateFns.sort( (o, l) => o.priority - l.priority),
        i && s.fn({
            width: this.width,
            height: this.height
        }, this),
        () => {
            this.remove(t)
        }
    }
    remove(t) {
        const n = this.updateFns.findIndex(r => r.fn === t);
        n !== -1 && this.updateFns.splice(n, 1)
    }
    start() {
        this.stop(),
        window.addEventListener("resize", this.onResize, !1),
        this.pointerMatchMedia.addEventListener("change", this.onPointerChange),
        this.internalResize(),
        setTimeout( () => {
            ka.refresh()
        }
        , 1)
    }
    stop() {
        window.removeEventListener("resize", this.onResize, !1),
        this.pointerMatchMedia.removeEventListener("change", this.onPointerChange)
    }
}
var Gf = null
  , Ou = () => (Gf || (Gf = new b2),
Gf);
class w2 {
    constructor() {
        St(this, "gsapTicker");
        St(this, "updateFns");
        St(this, "time", 0);
        St(this, "update", (t, n) => {
            this.time = t,
            this.updateFns.forEach(r => r.fn({
                et: t,
                dt: n / 1e3
            }))
        }
        );
        this.gsapTicker = In.gsap.ticker,
        this.updateFns = []
    }
    add(t, n=0) {
        const r = {
            fn: t,
            priority: n
        };
        return this.updateFns.push(r),
        this.updateFns.sort( (i, s) => i.priority - s.priority),
        () => {
            this.remove(t)
        }
    }
    remove(t) {
        const n = this.updateFns.findIndex(r => r.fn === t);
        n !== -1 && this.updateFns.splice(n, 1)
    }
    start() {
        this.stop(),
        this.gsapTicker.add(this.update)
    }
    stop() {
        this.gsapTicker.remove(this.update)
    }
}
var Yf = null
  , X0 = () => (Yf || (Yf = new w2),
Yf);
const D2 = ki( () => {
    const e = Ou();
    e.setBreakpoints([{
        name: "xs",
        size: 0
    }, {
        name: "sm",
        size: 480
    }, {
        name: "md",
        size: 768
    }, {
        name: "lg",
        size: 1024
    }, {
        name: "xlg",
        size: 1280
    }, {
        name: "xl",
        size: 1440
    }, {
        name: "xxl",
        size: 1680
    }, {
        name: "xxxl",
        size: 1920
    }]);
    const t = X0();
    return e.start(),
    t.start(),
    {
        provide: {
            viewport: e,
            ticker: t
        }
    }
}
)
  , E2 = ki( () => (In.gsap.registerPlugin(ka, Pg, oc, xg, i2, e2, VT, l2),
ka.config({
    ignoreMobileResize: !0
}),
In.gsap.ticker.lagSmoothing(0),
oc.create("custom.fastInOut", ".52,0,0,1"),
oc.create("easeCustomNotch", ".67,.05,.43,1"),
oc.create("menuEase", "M0,0 L0.009,0.012 L0.02,0.049 L0.093,0.409 L0.119,0.513 L0.147,0.606 L0.179,0.691 L0.213,0.762 L0.25,0.82 L0.291,0.868 L0.336,0.907 L0.387,0.937 L0.513,0.976 L0.688,0.994 L1,1"),
{
    provide: {
        gsap: In.gsap,
        ScrollTrigger: ka,
        SplitText: Pg,
        Flip: xg
    }
}))
  , C2 = [aE, uE, CE, UC, ox, ax, lx, ux, cx, Px, kx, $S, BS, jS, bT, OT, D2, E2]
  , ua = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [r,i] of t)
        n[r] = i;
    return n
}
  , x2 = {}
  , S2 = {
    viewBox: "0 0 215 49",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
};
function T2(e, t) {
    return It(),
    Cn("svg", S2, t[0] || (t[0] = [gh('<path d="M9.16512 0C8.26239 0 7.39524 0.369725 6.75488 1.02245L1.00056 6.92436C0.360201 7.58165 0 8.47629 0 9.40289V48.0871C0 48.5892 0.400223 49 0.889385 49H34.3481C35.2508 49 36.1179 48.6303 36.7583 47.973L46.7416 37.7211C47.382 37.0684 47.7422 36.1737 47.7422 35.2471V0.912902C47.7422 0.410806 47.342 0 46.8528 0H9.16512ZM40.9206 16.0123C40.9206 16.8339 40.2714 17.5003 39.4709 17.5003H22.1324C21.3586 17.5003 20.6604 18.1531 20.6827 18.9473C20.696 19.2942 20.8339 19.6137 21.0518 19.8556C21.074 19.8784 21.0918 19.9013 21.1185 19.9241L28.5626 27.5696C28.8339 27.8481 28.9895 28.2269 28.9895 28.6195V40.5191C28.9895 41.3408 28.3403 42.0072 27.5398 42.0072H20.2068C19.4064 42.0072 18.7571 41.3408 18.7571 40.5191V18.9929C18.7571 18.1713 18.1079 17.5049 17.3074 17.5049H8.27128C7.47084 17.5049 6.82159 16.8385 6.82159 16.0169V8.48999C6.82159 7.66838 7.47084 7.00196 8.27128 7.00196H18.1568C18.5437 7.00196 18.9128 7.15715 19.184 7.44015L26.6149 15.0674C26.6415 15.0994 26.6771 15.1359 26.7082 15.1633C26.9306 15.3733 27.2241 15.5056 27.5487 15.5285C28.3403 15.5741 28.9895 14.8529 28.9895 14.0404V8.49455C28.9895 7.67294 29.6388 7.00652 30.4392 7.00652H39.4754C40.2758 7.00652 40.9251 7.67294 40.9251 8.49455V16.0214L40.9206 16.0123Z" fill="currentColor"></path><path d="M57.9746 14.2048V9.35724H81.988V14.2048H72.8718V39.6473H67.0508V14.2048H57.9746Z" fill="currentColor"></path><path d="M89.3921 35.7173C91.0997 35.7173 92.8518 35.0919 93.9902 33.1292H99.7712C98.5928 36.4704 95.3777 40.1905 89.4321 40.1905C82.3927 40.1905 78.2793 34.7998 78.2793 28.3273C78.2793 21.8549 82.7973 16.6696 89.2676 16.6696C95.7379 16.6696 100.256 22.0603 100.011 29.998H83.8557C84.1403 33.8413 86.7462 35.7218 89.3921 35.7218V35.7173ZM94.3193 26.0268C94.1992 22.2246 91.5933 20.8872 89.232 20.8872C87.1153 20.8872 84.3893 22.2657 83.9402 26.0268H94.3193Z" fill="currentColor"></path><path d="M113.001 22.6034C110.235 22.6034 108.403 23.6487 108.403 27.8663V39.6473H102.786V17.1717H108.323V21.0972C109.586 18.3402 111.578 17.2128 114.104 17.2128C114.468 17.2128 114.957 17.2538 115.327 17.2949V22.7267C114.513 22.6445 113.819 22.6034 113.005 22.6034H113.001Z" fill="currentColor"></path><path d="M137.583 27.9485V39.6473H131.967V26.57C131.967 24.1052 131.762 21.3071 128.467 21.3071C124.723 21.3071 124.114 24.5251 124.114 27.9485V39.6473H118.497V17.1717H124.114V20.1386C125.337 17.9248 127.573 16.6696 130.219 16.6696C133.964 16.6696 135.591 18.7191 136.445 20.344C138.153 17.8381 140.354 16.6696 143.649 16.6696C149.145 16.6696 151.058 20.1797 151.058 25.4837V39.6473H145.441V26.57C145.441 24.1052 145.237 21.3071 141.941 21.3071C138.197 21.3071 137.588 24.5251 137.588 27.9485H137.583Z" fill="currentColor"></path><path d="M159.969 14.7068H154.353V9.36181H159.969V14.7068ZM159.969 39.6473H154.353V17.1717H159.969V39.6473Z" fill="currentColor"></path><path d="M175.56 16.6696C180.812 16.6696 183.129 19.9697 183.129 25.4837V39.6473H177.512V26.7389C177.512 23.813 176.903 21.3071 173.728 21.3071C170.024 21.3071 169.21 24.3973 169.21 27.9485V39.6473H163.594V17.1717H169.21V20.1386C170.473 17.8837 172.874 16.6696 175.56 16.6696Z" fill="currentColor"></path><path d="M185.815 33.5902C185.815 28.2863 191.636 26.6978 200.223 25.6936V25.3193C200.223 21.8503 198.391 20.6407 196.114 20.6407C193.957 20.6407 192.165 21.8092 192.045 24.2741H186.793C187.202 19.8465 190.782 16.5874 196.399 16.5874C201.606 16.5874 205.839 18.8834 205.839 26.4878C205.839 27.1999 205.759 30.1623 205.759 32.2117C205.759 35.7629 206.004 37.7668 206.409 39.6473H201.241C201.077 38.9353 200.957 37.9356 200.877 36.8493C199.329 39.1863 197.012 40.1905 193.713 40.1905C189.519 40.1905 185.815 37.6846 185.815 33.5902ZM191.596 33.2981C191.596 34.9276 192.859 36.265 195.38 36.265C198.88 36.265 200.387 34.3023 200.387 31.0432V29.3726C194.122 30.039 191.596 30.7922 191.596 33.2981Z" fill="currentColor"></path><path d="M209.384 39.6473V9.35724H215V39.6428H209.384V39.6473Z" fill="currentColor"></path>', 9)]))
}
const Q0 = ua(x2, [["render", T2]])
  , P2 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Q0
}, Symbol.toStringTag, {
    value: "Module"
}))
  , k2 = {
    class: "site-grid | w-full mx-auto"
}
  , J0 = {
    __name: "Container",
    props: {
        tag: {
            type: String,
            default: "section",
            validator: e => ["section", "div", "header", "footer", "nav"].includes(e)
        }
    },
    setup(e) {
        return (t, n) => (It(),
        Wn(nl(e.tag), {
            class: "site-container"
        }, {
            default: Tn( () => [kt("div", k2, [ys(t.$slots, "default")])]),
            _: 3
        }))
    }
}
  , A2 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: J0
}, Symbol.toStringTag, {
    value: "Module"
}));
function Fh(e, t) {
    const n = typeof e == "string" && !t ? `${e}Context` : t
      , r = Symbol(n);
    return [o => {
        const l = pr(r, o);
        if (l || l === null)
            return l;
        throw new Error(`Injection \`${r.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`)
    }
    , o => (ns(r, o),
    o)]
}
function sl() {
    let e = document.activeElement;
    if (e == null)
        return null;
    for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null; )
        e = e.shadowRoot.activeElement;
    return e
}
function Z0(e, t, n) {
    const r = n.originalEvent.target
      , i = new CustomEvent(e,{
        bubbles: !1,
        cancelable: !0,
        detail: n
    });
    t && r.addEventListener(e, t, {
        once: !0
    }),
    r.dispatchEvent(i)
}
function Ih(e) {
    return e ? e.flatMap(t => t.type === er ? Ih(t.children) : [t]) : []
}
const R2 = ["INPUT", "TEXTAREA"];
function ey(e, t, n, r={}) {
    if (!t || r.enableIgnoredElement && R2.includes(t.nodeName))
        return null;
    const {arrowKeyOptions: i="both", attributeName: s="[data-reka-collection-item]", itemsArray: o=[], loop: l=!0, dir: u="ltr", preventScroll: p=!0, focus: h=!1} = r
      , [g,m,w,E,y,R] = [e.key === "ArrowRight", e.key === "ArrowLeft", e.key === "ArrowUp", e.key === "ArrowDown", e.key === "Home", e.key === "End"]
      , P = w || E
      , x = g || m;
    if (!y && !R && (!P && !x || i === "vertical" && x || i === "horizontal" && P))
        return null;
    const v = o;
    if (!v.length)
        return null;
    p && e.preventDefault();
    let k = null;
    return x || P ? k = ty(v, t, {
        goForward: P ? E : u === "ltr" ? g : m,
        loop: l
    }) : y ? k = v.at(0) || null : R && (k = v.at(-1) || null),
    h && (k == null || k.focus()),
    k
}
function ty(e, t, n, r=e.length) {
    if (--r === 0)
        return null;
    const i = e.indexOf(t)
      , s = n.goForward ? i + 1 : i - 1;
    if (!n.loop && (s < 0 || s >= e.length))
        return null;
    const o = (s + e.length) % e.length
      , l = e[o];
    return l ? l.hasAttribute("disabled") && l.getAttribute("disabled") !== "false" ? ty(e, l, n, r) : l : null
}
const [ny,kA] = Fh("ConfigProvider");
function AA(e, t) {
    var n;
    const r = qr();
    return fs( () => {
        r.value = e()
    }
    , {
        ...t,
        flush: (n = void 0) != null ? n : "sync"
    }),
    yl(r)
}
function Mu(e) {
    return Lo() ? (ds(e),
    !0) : !1
}
function RA() {
    const e = new Set
      , t = s => {
        e.delete(s)
    }
    ;
    return {
        on: s => {
            e.add(s);
            const o = () => t(s);
            return Mu(o),
            {
                off: o
            }
        }
        ,
        off: t,
        trigger: (...s) => Promise.all(Array.from(e).map(o => o(...s))),
        clear: () => {
            e.clear()
        }
    }
}
function OA(e) {
    let t = !1, n;
    const r = Ss(!0);
    return (...i) => (t || (n = r.run( () => e(...i)),
    t = !0),
    n)
}
function MA(e) {
    let t = 0, n, r;
    const i = () => {
        t -= 1,
        r && t <= 0 && (r.stop(),
        n = void 0,
        r = void 0)
    }
    ;
    return (...s) => (t += 1,
    r || (r = Ss(!0),
    n = r.run( () => e(...s))),
    Mu(i),
    n)
}
function O2(e) {
    if (!sr(e))
        return Gr(e);
    const t = new Proxy({},{
        get(n, r, i) {
            return Re(Reflect.get(e.value, r, i))
        },
        set(n, r, i) {
            return sr(e.value[r]) && !sr(i) ? e.value[r].value = i : e.value[r] = i,
            !0
        },
        deleteProperty(n, r) {
            return Reflect.deleteProperty(e.value, r)
        },
        has(n, r) {
            return Reflect.has(e.value, r)
        },
        ownKeys() {
            return Object.keys(e.value)
        },
        getOwnPropertyDescriptor() {
            return {
                enumerable: !0,
                configurable: !0
            }
        }
    });
    return Gr(t)
}
function M2(e) {
    return O2(zt(e))
}
function L2(e, ...t) {
    const n = t.flat()
      , r = n[0];
    return M2( () => Object.fromEntries(typeof r == "function" ? Object.entries(ol(e)).filter( ([i,s]) => !r(Qr(s), i)) : Object.entries(ol(e)).filter(i => !n.includes(i[0]))))
}
const Ma = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const F2 = e => typeof e < "u"
  , I2 = Object.prototype.toString
  , N2 = e => I2.call(e) === "[object Object]"
  , jd = () => {}
  , LA = $2();
function $2() {
    var e, t;
    return Ma && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent))
}
function ry(e, t) {
    function n(...r) {
        return new Promise( (i, s) => {
            Promise.resolve(e( () => t.apply(this, r), {
                fn: t,
                thisArg: this,
                args: r
            })).then(i).catch(s)
        }
        )
    }
    return n
}
const iy = e => e();
function B2(e, t={}) {
    let n, r, i = jd;
    const s = u => {
        clearTimeout(u),
        i(),
        i = jd
    }
    ;
    let o;
    return u => {
        const p = Qr(e)
          , h = Qr(t.maxWait);
        return n && s(n),
        p <= 0 || h !== void 0 && h <= 0 ? (r && (s(r),
        r = null),
        Promise.resolve(u())) : new Promise( (g, m) => {
            i = t.rejectOnCancel ? m : g,
            o = u,
            h && !r && (r = setTimeout( () => {
                n && s(n),
                r = null,
                g(o())
            }
            , h)),
            n = setTimeout( () => {
                r && s(r),
                r = null,
                g(u())
            }
            , p)
        }
        )
    }
}
function H2(e=iy, t={}) {
    const {initialState: n="active"} = t
      , r = j2(n === "active");
    function i() {
        r.value = !1
    }
    function s() {
        r.value = !0
    }
    const o = (...l) => {
        r.value && e(...l)
    }
    ;
    return {
        isActive: yl(r),
        pause: i,
        resume: s,
        eventFilter: o
    }
}
function V2(e) {
    return Or()
}
function Kf(e) {
    return Array.isArray(e) ? e : [e]
}
function j2(...e) {
    if (e.length !== 1)
        return ko(...e);
    const t = e[0];
    return typeof t == "function" ? yl(Qc( () => ({
        get: t,
        set: jd
    }))) : Ut(t)
}
function sy(e, t=1e4) {
    return Qc( (n, r) => {
        let i = Qr(e), s;
        const o = () => setTimeout( () => {
            i = Qr(e),
            r()
        }
        , Qr(t));
        return Mu( () => {
            clearTimeout(s)
        }
        ),
        {
            get() {
                return n(),
                i
            },
            set(l) {
                i = l,
                r(),
                clearTimeout(s),
                s = o()
            }
        }
    }
    )
}
function z2(e, t=200, n={}) {
    return ry(B2(t, n), e)
}
function U2(e, t, n={}) {
    const {eventFilter: r=iy, ...i} = n;
    return tr(e, ry(r, t), i)
}
function Og(e, t, n={}) {
    const {eventFilter: r, initialState: i="active", ...s} = n
      , {eventFilter: o, pause: l, resume: u, isActive: p} = H2(r, {
        initialState: i
    });
    return {
        stop: U2(e, t, {
            ...s,
            eventFilter: o
        }),
        pause: l,
        resume: u,
        isActive: p
    }
}
function FA(e, t, ...[n]) {
    const {flush: r="sync", deep: i=!1, immediate: s=!0, direction: o="both", transform: l={}} = n || {}
      , u = []
      , p = "ltr"in l && l.ltr || (m => m)
      , h = "rtl"in l && l.rtl || (m => m);
    return (o === "both" || o === "ltr") && u.push(Og(e, m => {
        u.forEach(w => w.pause()),
        t.value = p(m),
        u.forEach(w => w.resume())
    }
    , {
        flush: r,
        deep: i,
        immediate: s
    })),
    (o === "both" || o === "rtl") && u.push(Og(t, m => {
        u.forEach(w => w.pause()),
        e.value = h(m),
        u.forEach(w => w.resume())
    }
    , {
        flush: r,
        deep: i,
        immediate: s
    })),
    () => {
        u.forEach(m => m.stop())
    }
}
const IA = Qr;
function NA(e, t) {
    V2() && Io(e, t)
}
function W2(e, t, n) {
    return tr(e, t, {
        ...n,
        immediate: !0
    })
}
const hf = Ma ? window : void 0;
function La(e) {
    var t;
    const n = Qr(e);
    return (t = n == null ? void 0 : n.$el) != null ? t : n
}
function q2(...e) {
    const t = []
      , n = () => {
        t.forEach(l => l()),
        t.length = 0
    }
      , r = (l, u, p, h) => (l.addEventListener(u, p, h),
    () => l.removeEventListener(u, p, h))
      , i = zt( () => {
        const l = Kf(Qr(e[0])).filter(u => u != null);
        return l.every(u => typeof u != "string") ? l : void 0
    }
    )
      , s = W2( () => {
        var l, u;
        return [(u = (l = i.value) == null ? void 0 : l.map(p => La(p))) != null ? u : [hf].filter(p => p != null), Kf(Qr(i.value ? e[1] : e[0])), Kf(Re(i.value ? e[2] : e[1])), Qr(i.value ? e[3] : e[2])]
    }
    , ([l,u,p,h]) => {
        if (n(),
        !(l != null && l.length) || !(u != null && u.length) || !(p != null && p.length))
            return;
        const g = N2(h) ? {
            ...h
        } : h;
        t.push(...l.flatMap(m => u.flatMap(w => p.map(E => r(m, w, E, g)))))
    }
    , {
        flush: "post"
    })
      , o = () => {
        s(),
        n()
    }
    ;
    return Mu(n),
    o
}
function G2() {
    const e = qr(!1)
      , t = Or();
    return t && xi( () => {
        e.value = !0
    }
    , t),
    e
}
function Y2(e) {
    const t = G2();
    return zt( () => (t.value,
    !!e()))
}
function K2(e) {
    return typeof e == "function" ? e : typeof e == "string" ? t => t.key === e : Array.isArray(e) ? t => e.includes(t.key) : () => !0
}
function X2(...e) {
    let t, n, r = {};
    e.length === 3 ? (t = e[0],
    n = e[1],
    r = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0,
    n = e[0],
    r = e[1]) : (t = e[0],
    n = e[1]) : (t = !0,
    n = e[0]);
    const {target: i=hf, eventName: s="keydown", passive: o=!1, dedupe: l=!1} = r
      , u = K2(t);
    return q2(i, s, h => {
        h.repeat && Qr(l) || u(h) && n(h)
    }
    , o)
}
function Q2(e) {
    return JSON.parse(JSON.stringify(e))
}
function Mg(e, t, n={}) {
    const {window: r=hf, ...i} = n;
    let s;
    const o = Y2( () => r && "ResizeObserver"in r)
      , l = () => {
        s && (s.disconnect(),
        s = void 0)
    }
      , u = zt( () => {
        const g = Qr(e);
        return Array.isArray(g) ? g.map(m => La(m)) : [La(g)]
    }
    )
      , p = tr(u, g => {
        if (l(),
        o.value && r) {
            s = new ResizeObserver(t);
            for (const m of g)
                m && s.observe(m, i)
        }
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , h = () => {
        l(),
        p()
    }
    ;
    return Mu(h),
    {
        isSupported: o,
        stop: h
    }
}
function J2(e, t, n, r={}) {
    var i, s, o;
    const {clone: l=!1, passive: u=!1, eventName: p, deep: h=!1, defaultValue: g, shouldEmit: m} = r
      , w = Or()
      , E = n || (w == null ? void 0 : w.emit) || ((i = w == null ? void 0 : w.$emit) == null ? void 0 : i.bind(w)) || ((o = (s = w == null ? void 0 : w.proxy) == null ? void 0 : s.$emit) == null ? void 0 : o.bind(w == null ? void 0 : w.proxy));
    let y = p;
    t || (t = "modelValue"),
    y = y || `update:${t.toString()}`;
    const R = v => l ? typeof l == "function" ? l(v) : Q2(v) : v
      , P = () => F2(e[t]) ? R(e[t]) : g
      , x = v => {
        m ? m(v) && E(y, v) : E(y, v)
    }
    ;
    if (u) {
        const v = P()
          , k = Ut(v);
        let S = !1;
        return tr( () => e[t], W => {
            S || (S = !0,
            k.value = R(W),
            Ci( () => S = !1))
        }
        ),
        tr(k, W => {
            !S && (W !== e[t] || h) && x(W)
        }
        , {
            deep: h
        }),
        k
    } else
        return zt({
            get() {
                return P()
            },
            set(v) {
                x(v)
            }
        })
}
function Z2(e) {
    const t = ny({
        dir: Ut("ltr")
    });
    return zt( () => {
        var n;
        return (e == null ? void 0 : e.value) || ((n = t.dir) == null ? void 0 : n.value) || "ltr"
    }
    )
}
function eP(e) {
    const t = Or()
      , n = t == null ? void 0 : t.type.emits
      , r = {};
    return n != null && n.length || console.warn(`No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`),
    n == null || n.forEach(i => {
        r[Za(Ei(i))] = (...s) => e(i, ...s)
    }
    ),
    r
}
function No() {
    const e = Or()
      , t = Ut()
      , n = zt( () => {
        var o, l;
        return ["#text", "#comment"].includes((o = t.value) == null ? void 0 : o.$el.nodeName) ? (l = t.value) == null ? void 0 : l.$el.nextElementSibling : La(t)
    }
    )
      , r = Object.assign({}, e.exposed)
      , i = {};
    for (const o in e.props)
        Object.defineProperty(i, o, {
            enumerable: !0,
            configurable: !0,
            get: () => e.props[o]
        });
    if (Object.keys(r).length > 0)
        for (const o in r)
            Object.defineProperty(i, o, {
                enumerable: !0,
                configurable: !0,
                get: () => r[o]
            });
    Object.defineProperty(i, "$el", {
        enumerable: !0,
        configurable: !0,
        get: () => e.vnode.el
    }),
    e.exposed = i;
    function s(o) {
        t.value = o,
        o && (Object.defineProperty(i, "$el", {
            enumerable: !0,
            configurable: !0,
            get: () => o instanceof Element ? o : o.$el
        }),
        e.exposed = i)
    }
    return {
        forwardRef: s,
        currentRef: t,
        currentElement: n
    }
}
function tP(e) {
    const t = Or()
      , n = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce( (i, s) => {
        const o = (t == null ? void 0 : t.type.props[s]).default;
        return o !== void 0 && (i[s] = o),
        i
    }
    , {})
      , r = ko(e);
    return zt( () => {
        const i = {}
          , s = (t == null ? void 0 : t.vnode.props) ?? {};
        return Object.keys(s).forEach(o => {
            i[Ei(o)] = s[o]
        }
        ),
        Object.keys({
            ...n,
            ...i
        }).reduce( (o, l) => (r.value[l] !== void 0 && (o[l] = r.value[l]),
        o), {})
    }
    )
}
function nP(e, t) {
    const n = tP(e)
      , r = t ? eP(t) : {};
    return zt( () => ({
        ...n.value,
        ...r
    }))
}
let rP = 0;
function oy(e, t="reka") {
    if (e)
        return e;
    if ("useId"in Bb)
        return `${t}-${Zl == null ? void 0 : Zl()}`;
    const n = ny({
        useId: void 0
    });
    return n.useId ? `${t}-${n.useId()}` : `${t}-${++rP}`
}
function iP(e, t) {
    const n = Ut(e);
    function r(s) {
        return t[n.value][s] ?? n.value
    }
    return {
        state: n,
        dispatch: s => {
            n.value = r(s)
        }
    }
}
function sP(e, t) {
    var R;
    const n = Ut({})
      , r = Ut("none")
      , i = Ut(e)
      , s = e.value ? "mounted" : "unmounted";
    let o;
    const l = ((R = t.value) == null ? void 0 : R.ownerDocument.defaultView) ?? hf
      , {state: u, dispatch: p} = iP(s, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    })
      , h = P => {
        var x;
        if (Ma) {
            const v = new CustomEvent(P,{
                bubbles: !1,
                cancelable: !1
            });
            (x = t.value) == null || x.dispatchEvent(v)
        }
    }
    ;
    tr(e, async (P, x) => {
        var k;
        const v = x !== P;
        if (await Ci(),
        v) {
            const S = r.value
              , W = ac(t.value);
            P ? (p("MOUNT"),
            h("enter"),
            W === "none" && h("after-enter")) : W === "none" || W === "undefined" || ((k = n.value) == null ? void 0 : k.display) === "none" ? (p("UNMOUNT"),
            h("leave"),
            h("after-leave")) : x && S !== W ? (p("ANIMATION_OUT"),
            h("leave")) : (p("UNMOUNT"),
            h("after-leave"))
        }
    }
    , {
        immediate: !0
    });
    const g = P => {
        const x = ac(t.value)
          , v = x.includes(CSS.escape(P.animationName))
          , k = u.value === "mounted" ? "enter" : "leave";
        if (P.target === t.value && v && (h(`after-${k}`),
        p("ANIMATION_END"),
        !i.value)) {
            const S = t.value.style.animationFillMode;
            t.value.style.animationFillMode = "forwards",
            o = l == null ? void 0 : l.setTimeout( () => {
                var W;
                ((W = t.value) == null ? void 0 : W.style.animationFillMode) === "forwards" && (t.value.style.animationFillMode = S)
            }
            )
        }
        P.target === t.value && x === "none" && p("ANIMATION_END")
    }
      , m = P => {
        P.target === t.value && (r.value = ac(t.value))
    }
      , w = tr(t, (P, x) => {
        P ? (n.value = getComputedStyle(P),
        P.addEventListener("animationstart", m),
        P.addEventListener("animationcancel", g),
        P.addEventListener("animationend", g)) : (p("ANIMATION_END"),
        o !== void 0 && (l == null || l.clearTimeout(o)),
        x == null || x.removeEventListener("animationstart", m),
        x == null || x.removeEventListener("animationcancel", g),
        x == null || x.removeEventListener("animationend", g))
    }
    , {
        immediate: !0
    })
      , E = tr(u, () => {
        const P = ac(t.value);
        r.value = u.value === "mounted" ? P : "none"
    }
    );
    return bl( () => {
        w(),
        E()
    }
    ),
    {
        isPresent: zt( () => ["mounted", "unmountSuspended"].includes(u.value))
    }
}
function ac(e) {
    return e && getComputedStyle(e).animationName || "none"
}
var ay = Mn({
    name: "Presence",
    props: {
        present: {
            type: Boolean,
            required: !0
        },
        forceMount: {
            type: Boolean
        }
    },
    slots: {},
    setup(e, {slots: t, expose: n}) {
        var p;
        const {present: r, forceMount: i} = ol(e)
          , s = Ut()
          , {isPresent: o} = sP(r, s);
        n({
            present: o
        });
        let l = t.default({
            present: o.value
        });
        l = Ih(l || []);
        const u = Or();
        if (l && (l == null ? void 0 : l.length) > 1) {
            const h = (p = u == null ? void 0 : u.parent) != null && p.type.name ? `<${u.parent.type.name} />` : "component";
            throw new Error([`Detected an invalid children for \`${h}\` for  \`Presence\` component.`, "", "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.", "You can apply a few solutions:", ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map(g => `  - ${g}`).join(`
`)].join(`
`))
        }
        return () => i.value || r.value || o.value ? ar(t.default({
            present: o.value
        })[0], {
            ref: h => {
                const g = La(h);
                return typeof (g == null ? void 0 : g.hasAttribute) > "u" || (g != null && g.hasAttribute("data-reka-popper-content-wrapper") ? s.value = g.firstElementChild : s.value = g),
                g
            }
        }) : null
    }
});
const zd = Mn({
    name: "PrimitiveSlot",
    inheritAttrs: !1,
    setup(e, {attrs: t, slots: n}) {
        return () => {
            var u;
            if (!n.default)
                return null;
            const r = Ih(n.default())
              , i = r.findIndex(p => p.type !== si);
            if (i === -1)
                return r;
            const s = r[i];
            (u = s.props) == null || delete u.ref;
            const o = s.props ? oo(t, s.props) : t
              , l = Us({
                ...s,
                props: {}
            }, o);
            return r.length === 1 ? l : (r[i] = l,
            r)
        }
    }
})
  , oP = ["area", "img", "input"]
  , Mo = Mn({
    name: "Primitive",
    inheritAttrs: !1,
    props: {
        asChild: {
            type: Boolean,
            default: !1
        },
        as: {
            type: [String, Object],
            default: "div"
        }
    },
    setup(e, {attrs: t, slots: n}) {
        const r = e.asChild ? "template" : e.as;
        return typeof r == "string" && oP.includes(r) ? () => ar(r, t) : r !== "template" ? () => ar(e.as, t, {
            default: n.default
        }) : () => ar(zd, t, {
            default: n.default
        })
    }
});
function Lg() {
    const e = Ut()
      , t = zt( () => {
        var n, r;
        return ["#text", "#comment"].includes((n = e.value) == null ? void 0 : n.$el.nodeName) ? (r = e.value) == null ? void 0 : r.$el.nextElementSibling : La(e)
    }
    );
    return {
        primitiveElement: e,
        currentElement: t
    }
}
const aP = "dismissableLayer.pointerDownOutside"
  , lP = "dismissableLayer.focusOutside";
function ly(e, t) {
    const n = t.closest("[data-dismissable-layer]")
      , r = e.dataset.dismissableLayer === "" ? e : e.querySelector("[data-dismissable-layer]")
      , i = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
    return !!(n && (r === n || i.indexOf(r) < i.indexOf(n)))
}
function uP(e, t, n=!0) {
    var o;
    const r = ((o = t == null ? void 0 : t.value) == null ? void 0 : o.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document)
      , i = Ut(!1)
      , s = Ut( () => {}
    );
    return fs(l => {
        if (!Ma || !Qr(n))
            return;
        const u = async h => {
            const g = h.target;
            if (!(!(t != null && t.value) || !g)) {
                if (ly(t.value, g)) {
                    i.value = !1;
                    return
                }
                if (h.target && !i.value) {
                    let w = function() {
                        Z0(aP, e, m)
                    };
                    const m = {
                        originalEvent: h
                    };
                    h.pointerType === "touch" ? (r.removeEventListener("click", s.value),
                    s.value = w,
                    r.addEventListener("click", s.value, {
                        once: !0
                    })) : w()
                } else
                    r.removeEventListener("click", s.value);
                i.value = !1
            }
        }
          , p = window.setTimeout( () => {
            r.addEventListener("pointerdown", u)
        }
        , 0);
        l( () => {
            window.clearTimeout(p),
            r.removeEventListener("pointerdown", u),
            r.removeEventListener("click", s.value)
        }
        )
    }
    ),
    {
        onPointerDownCapture: () => {
            Qr(n) && (i.value = !0)
        }
    }
}
function cP(e, t, n=!0) {
    var s;
    const r = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document)
      , i = Ut(!1);
    return fs(o => {
        if (!Ma || !Qr(n))
            return;
        const l = async u => {
            if (!(t != null && t.value))
                return;
            await Ci(),
            await Ci();
            const p = u.target;
            !t.value || !p || ly(t.value, p) || u.target && !i.value && Z0(lP, e, {
                originalEvent: u
            })
        }
        ;
        r.addEventListener("focusin", l),
        o( () => r.removeEventListener("focusin", l))
    }
    ),
    {
        onFocusCapture: () => {
            Qr(n) && (i.value = !0)
        }
        ,
        onBlurCapture: () => {
            Qr(n) && (i.value = !1)
        }
    }
}
const wo = Gr({
    layersRoot: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
});
var fP = Mn({
    __name: "DismissableLayer",
    props: {
        disableOutsidePointerEvents: {
            type: Boolean,
            required: !1,
            default: !1
        },
        asChild: {
            type: Boolean,
            required: !1
        },
        as: {
            type: null,
            required: !1
        }
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
    setup(e, {emit: t}) {
        const n = e
          , r = t
          , {forwardRef: i, currentElement: s} = No()
          , o = zt( () => {
            var E;
            return ((E = s.value) == null ? void 0 : E.ownerDocument) ?? globalThis.document
        }
        )
          , l = zt( () => wo.layersRoot)
          , u = zt( () => s.value ? Array.from(l.value).indexOf(s.value) : -1)
          , p = zt( () => wo.layersWithOutsidePointerEventsDisabled.size > 0)
          , h = zt( () => {
            const E = Array.from(l.value)
              , [y] = [...wo.layersWithOutsidePointerEventsDisabled].slice(-1)
              , R = E.indexOf(y);
            return u.value >= R
        }
        )
          , g = uP(async E => {
            const y = [...wo.branches].some(R => R == null ? void 0 : R.contains(E.target));
            !h.value || y || (r("pointerDownOutside", E),
            r("interactOutside", E),
            await Ci(),
            E.defaultPrevented || r("dismiss"))
        }
        , s)
          , m = cP(E => {
            [...wo.branches].some(R => R == null ? void 0 : R.contains(E.target)) || (r("focusOutside", E),
            r("interactOutside", E),
            E.defaultPrevented || r("dismiss"))
        }
        , s);
        X2("Escape", E => {
            u.value === l.value.size - 1 && (r("escapeKeyDown", E),
            E.defaultPrevented || r("dismiss"))
        }
        );
        let w;
        return fs(E => {
            s.value && (n.disableOutsidePointerEvents && (wo.layersWithOutsidePointerEventsDisabled.size === 0 && (w = o.value.body.style.pointerEvents,
            o.value.body.style.pointerEvents = "none"),
            wo.layersWithOutsidePointerEventsDisabled.add(s.value)),
            l.value.add(s.value),
            E( () => {
                n.disableOutsidePointerEvents && wo.layersWithOutsidePointerEventsDisabled.size === 1 && (o.value.body.style.pointerEvents = w)
            }
            ))
        }
        ),
        fs(E => {
            E( () => {
                s.value && (l.value.delete(s.value),
                wo.layersWithOutsidePointerEventsDisabled.delete(s.value))
            }
            )
        }
        ),
        (E, y) => (It(),
        Wn(Re(Mo), {
            ref: Re(i),
            "as-child": E.asChild,
            as: E.as,
            "data-dismissable-layer": "",
            style: ml({
                pointerEvents: p.value ? h.value ? "auto" : "none" : void 0
            }),
            onFocusCapture: Re(m).onFocusCapture,
            onBlurCapture: Re(m).onBlurCapture,
            onPointerdownCapture: Re(g).onPointerDownCapture
        }, {
            default: Tn( () => [ys(E.$slots, "default")]),
            _: 3
        }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]))
    }
})
  , dP = fP;
const Fg = "data-reka-collection-item";
function Lu(e={}) {
    const {key: t="", isProvider: n=!1} = e
      , r = `${t}CollectionProvider`;
    let i;
    if (n) {
        const h = Ut(new Map);
        i = {
            collectionRef: Ut(),
            itemMap: h
        },
        ns(r, i)
    } else
        i = pr(r);
    const s = (h=!1) => {
        const g = i.collectionRef.value;
        if (!g)
            return [];
        const m = Array.from(g.querySelectorAll(`[${Fg}]`))
          , E = Array.from(i.itemMap.value.values()).sort( (y, R) => m.indexOf(y.ref) - m.indexOf(R.ref));
        return h ? E : E.filter(y => y.ref.dataset.disabled !== "")
    }
      , o = Mn({
        name: "CollectionSlot",
        setup(h, {slots: g}) {
            const {primitiveElement: m, currentElement: w} = Lg();
            return tr(w, () => {
                i.collectionRef.value = w.value
            }
            ),
            () => ar(zd, {
                ref: m
            }, g)
        }
    })
      , l = Mn({
        name: "CollectionItem",
        inheritAttrs: !1,
        props: {
            value: {
                validator: () => !0
            }
        },
        setup(h, {slots: g, attrs: m}) {
            const {primitiveElement: w, currentElement: E} = Lg();
            return fs(y => {
                if (E.value) {
                    const R = Eu(E.value);
                    i.itemMap.value.set(R, {
                        ref: E.value,
                        value: h.value
                    }),
                    y( () => i.itemMap.value.delete(R))
                }
            }
            ),
            () => ar(zd, {
                ...m,
                [Fg]: "",
                ref: w
            }, g)
        }
    })
      , u = zt( () => Array.from(i.itemMap.value.values()))
      , p = zt( () => i.itemMap.value.size);
    return {
        getItems: s,
        reactiveItems: u,
        itemMapSize: p,
        CollectionSlot: o,
        CollectionItem: l
    }
}
var hP = Mn({
    __name: "VisuallyHidden",
    props: {
        feature: {
            type: String,
            required: !1,
            default: "focusable"
        },
        asChild: {
            type: Boolean,
            required: !1
        },
        as: {
            type: null,
            required: !1,
            default: "span"
        }
    },
    setup(e) {
        return (t, n) => (It(),
        Wn(Re(Mo), {
            as: t.as,
            "as-child": t.asChild,
            "aria-hidden": t.feature === "focusable" ? "true" : void 0,
            "data-hidden": t.feature === "fully-hidden" ? "" : void 0,
            tabindex: t.feature === "fully-hidden" ? "-1" : void 0,
            style: {
                position: "absolute",
                border: 0,
                width: "1px",
                height: "1px",
                padding: 0,
                margin: "-1px",
                overflow: "hidden",
                clip: "rect(0, 0, 0, 0)",
                clipPath: "inset(50%)",
                whiteSpace: "nowrap",
                wordWrap: "normal",
                top: "-1px",
                left: "-1px"
            }
        }, {
            default: Tn( () => [ys(t.$slots, "default")]),
            _: 3
        }, 8, ["as", "as-child", "aria-hidden", "data-hidden", "tabindex"]))
    }
})
  , pP = hP;
const [Dl,gP] = Fh(["NavigationMenuRoot", "NavigationMenuSub"], "NavigationMenuContext");
var _P = Mn({
    __name: "NavigationMenuRoot",
    props: {
        modelValue: {
            type: String,
            required: !1,
            default: void 0
        },
        defaultValue: {
            type: String,
            required: !1
        },
        dir: {
            type: String,
            required: !1
        },
        orientation: {
            type: String,
            required: !1,
            default: "horizontal"
        },
        delayDuration: {
            type: Number,
            required: !1,
            default: 200
        },
        skipDelayDuration: {
            type: Number,
            required: !1,
            default: 300
        },
        disableClickTrigger: {
            type: Boolean,
            required: !1,
            default: !1
        },
        disableHoverTrigger: {
            type: Boolean,
            required: !1,
            default: !1
        },
        disablePointerLeaveClose: {
            type: Boolean,
            required: !1
        },
        unmountOnHide: {
            type: Boolean,
            required: !1,
            default: !0
        },
        asChild: {
            type: Boolean,
            required: !1
        },
        as: {
            type: null,
            required: !1,
            default: "nav"
        }
    },
    emits: ["update:modelValue"],
    setup(e, {emit: t}) {
        const n = e
          , i = J2(n, "modelValue", t, {
            defaultValue: n.defaultValue ?? "",
            passive: n.modelValue === void 0
        })
          , s = Ut("")
          , {forwardRef: o, currentElement: l} = No()
          , u = Ut()
          , p = Ut()
          , h = Ut()
          , {getItems: g, CollectionSlot: m} = Lu({
            key: "NavigationMenu",
            isProvider: !0
        })
          , {delayDuration: w, skipDelayDuration: E, dir: y, disableClickTrigger: R, disableHoverTrigger: P, unmountOnHide: x} = ol(n)
          , v = Z2(y)
          , k = sy(!1, E)
          , S = zt( () => i.value !== "" || k.value ? 150 : w.value)
          , W = z2(K => {
            typeof K == "string" && (s.value = i.value,
            i.value = K)
        }
        , S);
        return fs( () => {
            if (!i.value)
                return;
            const K = g().map(be => be.ref);
            h.value = K.find(be => be.id.includes(i.value))
        }
        ),
        gP({
            isRootMenu: !0,
            modelValue: i,
            previousValue: s,
            baseId: oy(void 0, "reka-navigation-menu"),
            disableClickTrigger: R,
            disableHoverTrigger: P,
            dir: v,
            unmountOnHide: x,
            orientation: n.orientation,
            rootNavigationMenu: l,
            indicatorTrack: u,
            activeTrigger: h,
            onIndicatorTrackChange: K => {
                u.value = K
            }
            ,
            viewport: p,
            onViewportChange: K => {
                p.value = K
            }
            ,
            onTriggerEnter: K => {
                W(K)
            }
            ,
            onTriggerLeave: () => {
                k.value = !0,
                W("")
            }
            ,
            onContentEnter: () => {
                W()
            }
            ,
            onContentLeave: () => {
                n.disablePointerLeaveClose || W("")
            }
            ,
            onItemSelect: K => {
                s.value = i.value,
                i.value = K
            }
            ,
            onItemDismiss: () => {
                s.value = i.value,
                i.value = ""
            }
        }),
        (K, be) => (It(),
        Wn(Re(m), null, {
            default: Tn( () => [tn(Re(Mo), {
                ref: Re(o),
                "aria-label": "Main",
                as: K.as,
                "as-child": K.asChild,
                "data-orientation": K.orientation,
                dir: Re(v),
                "data-reka-navigation-menu": ""
            }, {
                default: Tn( () => [ys(K.$slots, "default", {
                    modelValue: Re(i)
                })]),
                _: 3
            }, 8, ["as", "as-child", "data-orientation", "dir"])]),
            _: 3
        }))
    }
})
  , mP = _P;
function pf(e) {
    return e ? "open" : "closed"
}
function uy(e, t) {
    return `${e}-trigger-${t}`
}
function Nh(e, t) {
    return `${e}-content-${t}`
}
const yP = "navigationMenu.linkSelect"
  , pc = "navigationMenu.rootContentDismiss";
function Ud(e) {
    const t = []
      , n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
        acceptNode: r => {
            const i = r.tagName === "INPUT" && r.type === "hidden";
            return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; n.nextNode(); )
        t.push(n.currentNode);
    return t
}
function cy(e) {
    const t = sl();
    return e.some(n => n === t ? !0 : (n.focus(),
    sl() !== t))
}
function vP(e) {
    return e.forEach(t => {
        t.dataset.tabindex = t.getAttribute("tabindex") || "",
        t.setAttribute("tabindex", "-1")
    }
    ),
    () => {
        e.forEach(t => {
            const n = t.dataset.tabindex;
            t.setAttribute("tabindex", n)
        }
        )
    }
}
function fy(e) {
    return t => t.pointerType === "mouse" ? e(t) : void 0
}
const [$h,bP] = Fh("NavigationMenuItem");
var wP = Mn({
    __name: "NavigationMenuItem",
    props: {
        value: {
            type: String,
            required: !1
        },
        asChild: {
            type: Boolean,
            required: !1
        },
        as: {
            type: null,
            required: !1,
            default: "li"
        }
    },
    setup(e) {
        const t = e;
        No();
        const {getItems: n} = Lu({
            key: "NavigationMenu"
        })
          , r = Dl()
          , i = oy(t.value)
          , s = Ut()
          , o = Ut()
          , l = Nh(r.baseId, i);
        let u = () => ({});
        const p = Ut(!1);
        async function h(E="start") {
            const y = document.getElementById(l);
            if (y) {
                u();
                const R = Ud(y);
                R.length && cy(E === "start" ? R : R.reverse())
            }
        }
        function g() {
            const E = document.getElementById(l);
            if (E) {
                const y = Ud(E);
                y.length && (u = vP(y))
            }
        }
        bP({
            value: i,
            contentId: l,
            triggerRef: s,
            focusProxyRef: o,
            wasEscapeCloseRef: p,
            onEntryKeyDown: h,
            onFocusProxyEnter: h,
            onContentFocusOutside: g,
            onRootContentClose: g
        });
        function m() {
            var E;
            r.onItemDismiss(),
            (E = s.value) == null || E.focus()
        }
        function w(E) {
            const y = sl();
            if (E.keyCode === 32 || E.key === "Enter")
                if (r.modelValue.value === i) {
                    m(),
                    E.preventDefault();
                    return
                } else {
                    E.target.click(),
                    E.preventDefault();
                    return
                }
            const R = n().filter(x => {
                var v;
                return (v = x.ref.parentElement) == null ? void 0 : v.hasAttribute("data-menu-item")
            }
            ).map(x => x.ref);
            if (!R.includes(y))
                return;
            const P = ey(E, y, void 0, {
                itemsArray: R,
                loop: !1
            });
            P && (P == null || P.focus()),
            E.preventDefault(),
            E.stopPropagation()
        }
        return (E, y) => (It(),
        Wn(Re(Mo), {
            "as-child": E.asChild,
            as: E.as,
            "data-menu-item": "",
            onKeydown: Fm(w, ["up", "down", "left", "right", "home", "end", "space"])
        }, {
            default: Tn( () => [ys(E.$slots, "default")]),
            _: 3
        }, 8, ["as-child", "as"]))
    }
})
  , DP = wP
  , EP = Mn({
    __name: "NavigationMenuContentImpl",
    props: {
        disableOutsidePointerEvents: {
            type: Boolean,
            required: !1
        },
        asChild: {
            type: Boolean,
            required: !1
        },
        as: {
            type: null,
            required: !1
        }
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
    setup(e, {emit: t}) {
        const n = e
          , r = t
          , {getItems: i} = Lu({
            key: "NavigationMenu"
        })
          , {forwardRef: s, currentElement: o} = No()
          , l = Dl()
          , u = $h()
          , p = uy(l.baseId, u.value)
          , h = Nh(l.baseId, u.value)
          , g = Ut(null)
          , m = zt( () => {
            const x = i().map(be => be.ref.id.split("trigger-")[1]);
            l.dir.value === "rtl" && x.reverse();
            const v = x.indexOf(l.modelValue.value)
              , k = x.indexOf(l.previousValue.value)
              , S = u.value === l.modelValue.value
              , W = k === x.indexOf(u.value);
            if (!S && !W)
                return g.value;
            const K = ( () => {
                if (v !== k) {
                    if (S && k !== -1)
                        return v > k ? "from-end" : "from-start";
                    if (W && v !== -1)
                        return v > k ? "to-start" : "to-end"
                }
                return null
            }
            )();
            return g.value = K,
            K
        }
        );
        function w(x) {
            var k, S;
            if (r("focusOutside", x),
            r("interactOutside", x),
            x.detail.originalEvent.target.hasAttribute("data-navigation-menu-trigger") && x.preventDefault(),
            !x.defaultPrevented) {
                u.onContentFocusOutside();
                const W = x.target;
                (S = (k = l.rootNavigationMenu) == null ? void 0 : k.value) != null && S.contains(W) && x.preventDefault()
            }
        }
        function E(x) {
            var v;
            if (r("pointerDownOutside", x),
            !x.defaultPrevented) {
                const k = x.target
                  , S = i().some(K => K.ref.contains(k))
                  , W = l.isRootMenu && ((v = l.viewport.value) == null ? void 0 : v.contains(k));
                (S || W || !l.isRootMenu) && x.preventDefault()
            }
        }
        fs(x => {
            const v = o.value;
            if (l.isRootMenu && v) {
                const k = () => {
                    var S;
                    l.onItemDismiss(),
                    u.onRootContentClose(),
                    v.contains(sl()) && ((S = u.triggerRef.value) == null || S.focus())
                }
                ;
                v.addEventListener(pc, k),
                x( () => v.removeEventListener(pc, k))
            }
        }
        );
        function y(x) {
            var v, k;
            r("escapeKeyDown", x),
            x.defaultPrevented || (l.onItemDismiss(),
            (k = (v = u.triggerRef) == null ? void 0 : v.value) == null || k.focus(),
            u.wasEscapeCloseRef.value = !0)
        }
        function R(x) {
            var K;
            if (x.target.closest("[data-reka-navigation-menu]") !== l.rootNavigationMenu.value)
                return;
            const v = x.altKey || x.ctrlKey || x.metaKey
              , k = x.key === "Tab" && !v
              , S = Ud(x.currentTarget);
            if (k) {
                const be = sl()
                  , fe = S.findIndex(re => re === be)
                  , J = x.shiftKey ? S.slice(0, fe).reverse() : S.slice(fe + 1, S.length);
                if (cy(J))
                    x.preventDefault();
                else {
                    (K = u.focusProxyRef.value) == null || K.focus();
                    return
                }
            }
            const W = ey(x, sl(), void 0, {
                itemsArray: S,
                loop: !1,
                enableIgnoredElement: !0
            });
            W == null || W.focus()
        }
        function P() {
            var v;
            const x = new Event(pc,{
                bubbles: !0,
                cancelable: !0
            });
            (v = o.value) == null || v.dispatchEvent(x)
        }
        return (x, v) => (It(),
        Wn(Re(dP), oo({
            id: Re(h),
            ref: Re(s),
            "aria-labelledby": Re(p),
            "data-motion": m.value,
            "data-state": Re(pf)(Re(l).modelValue.value === Re(u).value),
            "data-orientation": Re(l).orientation
        }, n, {
            onKeydown: R,
            onEscapeKeyDown: y,
            onPointerDownOutside: E,
            onFocusOutside: w,
            onDismiss: P
        }), {
            default: Tn( () => [ys(x.$slots, "default")]),
            _: 3
        }, 16, ["id", "aria-labelledby", "data-motion", "data-state", "data-orientation"]))
    }
})
  , CP = EP
  , xP = Mn({
    inheritAttrs: !1,
    __name: "NavigationMenuContent",
    props: {
        forceMount: {
            type: Boolean,
            required: !1
        },
        disableOutsidePointerEvents: {
            type: Boolean,
            required: !1
        },
        asChild: {
            type: Boolean,
            required: !1
        },
        as: {
            type: null,
            required: !1
        }
    },
    emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
    setup(e, {emit: t}) {
        const n = e
          , r = t
          , i = nP(L2(n, "forceMount"), r)
          , {forwardRef: s} = No()
          , o = Dl()
          , l = $h()
          , u = zt( () => l.value === o.modelValue.value)
          , p = zt( () => o.viewport.value && !o.modelValue.value && o.previousValue.value ? o.previousValue.value === l.value : !1);
        return (h, g) => (It(),
        Wn(D_, {
            to: Re(Ma) && Re(o).viewport.value ? Re(o).viewport.value : "body",
            disabled: Re(Ma) && Re(o).viewport.value ? !Re(o).viewport.value : !0
        }, [tn(Re(ay), {
            present: h.forceMount || u.value || p.value,
            "force-mount": !Re(o).unmountOnHide.value
        }, {
            default: Tn( ({present: m}) => [tn(CP, oo({
                ref: Re(s),
                "data-state": Re(pf)(u.value),
                style: {
                    pointerEvents: !u.value && Re(o).isRootMenu ? "none" : void 0
                }
            }, {
                ...h.$attrs,
                ...Re(i)
            }, {
                hidden: !m,
                onPointerenter: g[0] || (g[0] = w => Re(o).onContentEnter(Re(l).value)),
                onPointerleave: g[1] || (g[1] = w => Re(fy)( () => Re(o).onContentLeave())(w)),
                onPointerDownOutside: g[2] || (g[2] = w => r("pointerDownOutside", w)),
                onFocusOutside: g[3] || (g[3] = w => r("focusOutside", w)),
                onInteractOutside: g[4] || (g[4] = w => r("interactOutside", w))
            }), {
                default: Tn( () => [ys(h.$slots, "default")]),
                _: 2
            }, 1040, ["data-state", "style", "hidden"])]),
            _: 3
        }, 8, ["present", "force-mount"])], 8, ["to", "disabled"]))
    }
})
  , SP = xP
  , TP = Mn({
    __name: "NavigationMenuLink",
    props: {
        active: {
            type: Boolean,
            required: !1
        },
        asChild: {
            type: Boolean,
            required: !1
        },
        as: {
            type: null,
            required: !1,
            default: "a"
        }
    },
    emits: ["select"],
    setup(e, {emit: t}) {
        const n = e
          , r = t
          , {CollectionItem: i} = Lu({
            key: "NavigationMenu"
        });
        No();
        async function s(o) {
            var u;
            const l = new CustomEvent(yP,{
                bubbles: !0,
                cancelable: !0,
                detail: {
                    originalEvent: o
                }
            });
            if (r("select", l),
            !l.defaultPrevented && !o.metaKey) {
                const p = new CustomEvent(pc,{
                    bubbles: !0,
                    cancelable: !0
                });
                (u = o.target) == null || u.dispatchEvent(p)
            }
        }
        return (o, l) => (It(),
        Wn(Re(i), null, {
            default: Tn( () => [tn(Re(Mo), {
                as: o.as,
                "data-active": o.active ? "" : void 0,
                "aria-current": o.active ? "page" : void 0,
                "as-child": n.asChild,
                onClick: s
            }, {
                default: Tn( () => [ys(o.$slots, "default")]),
                _: 3
            }, 8, ["as", "data-active", "aria-current", "as-child"])]),
            _: 3
        }))
    }
})
  , PP = TP
  , kP = Mn({
    inheritAttrs: !1,
    __name: "NavigationMenuList",
    props: {
        asChild: {
            type: Boolean,
            required: !1
        },
        as: {
            type: null,
            required: !1,
            default: "ul"
        }
    },
    setup(e) {
        const t = e
          , n = Dl()
          , {forwardRef: r, currentElement: i} = No();
        return xi( () => {
            n.onIndicatorTrackChange(i.value)
        }
        ),
        (s, o) => (It(),
        Wn(Re(Mo), {
            ref: Re(r),
            style: {
                position: "relative"
            }
        }, {
            default: Tn( () => [tn(Re(Mo), oo(s.$attrs, {
                "as-child": t.asChild,
                as: s.as,
                "data-orientation": Re(n).orientation
            }), {
                default: Tn( () => [ys(s.$slots, "default")]),
                _: 3
            }, 16, ["as-child", "as", "data-orientation"])]),
            _: 3
        }, 512))
    }
})
  , AP = kP;
const RP = ["aria-owns"];
var OP = Mn({
    inheritAttrs: !1,
    __name: "NavigationMenuTrigger",
    props: {
        disabled: {
            type: Boolean,
            required: !1
        },
        asChild: {
            type: Boolean,
            required: !1
        },
        as: {
            type: null,
            required: !1,
            default: "button"
        }
    },
    setup(e) {
        const t = e
          , n = Dl()
          , r = $h()
          , {CollectionItem: i} = Lu({
            key: "NavigationMenu"
        })
          , {forwardRef: s, currentElement: o} = No()
          , l = Ut("")
          , u = Ut("")
          , p = sy(!1, 300)
          , h = Ut(!1)
          , g = zt( () => r.value === n.modelValue.value);
        xi( () => {
            r.triggerRef = o,
            l.value = uy(n.baseId, r.value),
            u.value = Nh(n.baseId, r.value)
        }
        );
        function m() {
            n.disableHoverTrigger.value || (h.value = !1,
            r.wasEscapeCloseRef.value = !1)
        }
        function w(v) {
            if (!n.disableHoverTrigger.value && v.pointerType === "mouse") {
                if (t.disabled || h.value || r.wasEscapeCloseRef.value || p.value)
                    return;
                n.onTriggerEnter(r.value),
                p.value = !0
            }
        }
        function E(v) {
            if (!n.disableHoverTrigger.value && v.pointerType === "mouse") {
                if (t.disabled)
                    return;
                n.onTriggerLeave(),
                p.value = !1
            }
        }
        function y(v) {
            v.pointerType === "mouse" && n.disableClickTrigger.value || p.value || (g.value ? n.onItemSelect("") : n.onItemSelect(r.value),
            h.value = g.value)
        }
        function R(v) {
            const S = {
                horizontal: "ArrowDown",
                vertical: n.dir.value === "rtl" ? "ArrowLeft" : "ArrowRight"
            }[n.orientation];
            g.value && v.key === S && (r.onEntryKeyDown(),
            v.preventDefault(),
            v.stopPropagation())
        }
        function P(v) {
            r.focusProxyRef.value = La(v)
        }
        function x(v) {
            const k = document.getElementById(r.contentId)
              , S = v.relatedTarget
              , W = S === o.value
              , K = k == null ? void 0 : k.contains(S);
            (W || !K) && r.onFocusProxyEnter(W ? "start" : "end")
        }
        return (v, k) => (It(),
        Cn(er, null, [tn(Re(i), null, {
            default: Tn( () => [tn(Re(Mo), oo({
                id: l.value,
                ref: Re(s),
                disabled: v.disabled,
                "data-disabled": v.disabled ? "" : void 0,
                "data-state": Re(pf)(g.value),
                "data-navigation-menu-trigger": "",
                "aria-expanded": g.value,
                "aria-controls": u.value,
                "as-child": t.asChild,
                as: v.as
            }, v.$attrs, {
                onPointerenter: m,
                onPointermove: w,
                onPointerleave: E,
                onClick: y,
                onKeydown: R
            }), {
                default: Tn( () => [ys(v.$slots, "default")]),
                _: 3
            }, 16, ["id", "disabled", "data-disabled", "data-state", "aria-expanded", "aria-controls", "as-child", "as"])]),
            _: 3
        }), g.value ? (It(),
        Cn(er, {
            key: 0
        }, [tn(Re(pP), {
            ref: P,
            "aria-hidden": "true",
            tabindex: 0,
            onFocus: x
        }), Re(n).viewport ? (It(),
        Cn("span", {
            key: 0,
            "aria-owns": u.value
        }, null, 8, RP)) : ii("v-if", !0)], 64)) : ii("v-if", !0)], 64))
    }
})
  , MP = OP
  , LP = Mn({
    inheritAttrs: !1,
    __name: "NavigationMenuViewport",
    props: {
        forceMount: {
            type: Boolean,
            required: !1
        },
        align: {
            type: String,
            required: !1,
            default: "center"
        },
        asChild: {
            type: Boolean,
            required: !1
        },
        as: {
            type: null,
            required: !1
        }
    },
    setup(e) {
        var w;
        const t = e
          , {forwardRef: n, currentElement: r} = No()
          , i = Dl()
          , {activeTrigger: s, rootNavigationMenu: o, modelValue: l} = i
          , u = Ut()
          , p = Ut()
          , h = zt( () => !!i.modelValue.value);
        tr(r, () => {
            i.onViewportChange(r.value)
        }
        );
        const g = Ut();
        tr([l, h], () => {
            Ci( () => {
                r.value && requestAnimationFrame( () => {
                    var y;
                    const E = (y = r.value) == null ? void 0 : y.querySelector("[data-state=open]");
                    g.value = E
                }
                )
            }
            )
        }
        , {
            immediate: !0
        });
        function m() {
            if (g.value && s.value && o.value) {
                const E = document.documentElement.offsetWidth
                  , y = document.documentElement.offsetHeight
                  , R = o.value.getBoundingClientRect()
                  , P = s.value.getBoundingClientRect()
                  , {offsetWidth: x, offsetHeight: v} = g.value
                  , k = P.left - R.left
                  , S = P.top - R.top;
                let W = null
                  , K = null;
                switch (t.align) {
                case "start":
                    W = k,
                    K = S;
                    break;
                case "end":
                    W = k - x + P.width,
                    K = S - v + P.height;
                    break;
                default:
                    W = k - x / 2 + P.width / 2,
                    K = S - v / 2 + P.height / 2
                }
                const be = 10;
                W + R.left < be && (W = be - R.left);
                const fe = W + R.left + x;
                fe > E - be && (W -= fe - E + be,
                W < be - R.left && (W = be - R.left)),
                K + R.top < be && (K = be - R.top);
                const ge = K + R.top + v;
                ge > y - be && (K -= ge - y + be,
                K < be - R.top && (K = be - R.top)),
                W = Math.round(W),
                K = Math.round(K),
                p.value = {
                    left: W,
                    top: K
                }
            }
        }
        return Mg(g, () => {
            g.value && (u.value = {
                width: g.value.offsetWidth,
                height: g.value.offsetHeight
            },
            m())
        }
        ),
        Mg([(w = globalThis.document) == null ? void 0 : w.body, o], () => {
            m()
        }
        ),
        (E, y) => (It(),
        Wn(Re(ay), {
            present: E.forceMount || h.value,
            "force-mount": !Re(i).unmountOnHide.value,
            onAfterLeave: y[2] || (y[2] = () => {
                u.value = void 0,
                p.value = void 0
            }
            )
        }, {
            default: Tn( ({present: R}) => {
                var P, x, v, k;
                return [tn(Re(Mo), oo(E.$attrs, {
                    ref: Re(n),
                    as: E.as,
                    "as-child": E.asChild,
                    "data-state": Re(pf)(h.value),
                    "data-orientation": Re(i).orientation,
                    style: {
                        pointerEvents: !h.value && Re(i).isRootMenu ? "none" : void 0,
                        "--reka-navigation-menu-viewport-width": u.value ? `${(P = u.value) == null ? void 0 : P.width}px` : void 0,
                        "--reka-navigation-menu-viewport-height": u.value ? `${(x = u.value) == null ? void 0 : x.height}px` : void 0,
                        "--reka-navigation-menu-viewport-left": p.value ? `${(v = p.value) == null ? void 0 : v.left}px` : void 0,
                        "--reka-navigation-menu-viewport-top": p.value ? `${(k = p.value) == null ? void 0 : k.top}px` : void 0
                    },
                    hidden: !R,
                    onPointerenter: y[0] || (y[0] = S => Re(i).onContentEnter(Re(i).modelValue.value)),
                    onPointerleave: y[1] || (y[1] = S => Re(fy)( () => Re(i).onContentLeave())(S))
                }), {
                    default: Tn( () => [ys(E.$slots, "default")]),
                    _: 2
                }, 1040, ["as", "as-child", "data-state", "data-orientation", "style", "hidden"])]
            }
            ),
            _: 3
        }, 8, ["present", "force-mount"]))
    }
})
  , FP = LP;
function wu(e) {
    if (!e)
        return "/";
    if (typeof e == "string")
        return e === "home" ? "/" : e.startsWith("/") ? e : `/${e}`;
    if (e.linktype === "story" && e.story) {
        const t = e.story.full_slug || e.story.slug;
        return !t || t === "home" ? "/" : t.startsWith("/") ? t : `/${t}`
    }
    return "/"
}
const IP = {
    class: "dropdown-inner"
}
  , NP = {
    class: "dropdown-tabs"
}
  , $P = ["onClick", "onMouseenter"]
  , BP = {
    class: "tab-label body-3"
}
  , HP = {
    class: "dropdown-content"
}
  , VP = {
    key: 0,
    class: "content-wrapper"
}
  , jP = {
    class: "content-text"
}
  , zP = {
    key: 0,
    class: "content-links"
}
  , UP = {
    class: "content-link-text"
}
  , WP = Mn({
    __name: "NavigationDropdown",
    props: {
        label: {},
        sections: {}
    },
    setup(e) {
        const t = e
          , n = Ut(void 0)
          , r = Ut(0)
          , i = zt( () => t.sections[r.value]);
        return tr(n, s => {
            s !== t.label && (r.value = 0)
        }
        ),
        (s, o) => {
            const l = wc("StoryblokRichText")
              , u = V0;
            return It(),
            Wn(Re(mP), {
                modelValue: Re(n),
                "onUpdate:modelValue": o[0] || (o[0] = p => sr(n) ? n.value = p : null),
                class: "navigation-menu-root"
            }, {
                default: Tn( () => [tn(Re(AP), null, {
                    default: Tn( () => [tn(Re(DP), {
                        value: s.label
                    }, {
                        default: Tn( () => [tn(Re(MP), {
                            "as-child": ""
                        }, {
                            default: Tn( () => [kt("button", {
                                class: ks(["nav-dropdown-trigger", {
                                    "is-open": Re(n) === s.label
                                }]),
                                type: "button"
                            }, [To(Ji(s.label) + " ", 1), o[1] || (o[1] = kt("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                width: "12",
                                height: "12",
                                viewBox: "0 0 12 12",
                                fill: "none",
                                class: "arrow-icon"
                            }, [kt("path", {
                                d: "M3 4.5L6 7.5L9 4.5",
                                stroke: "currentColor",
                                "stroke-width": "1.5",
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round"
                            })], -1))], 2)]),
                            _: 1
                        }), tn(Re(SP), {
                            class: "nav-dropdown-content"
                        }, {
                            default: Tn( () => [kt("div", IP, [kt("div", NP, [(It(!0),
                            Cn(er, null, So(s.sections, (p, h) => (It(),
                            Cn("button", {
                                key: h,
                                class: ks(["dropdown-tab", {
                                    "is-active": Re(r) === h
                                }]),
                                onClick: g => r.value = h,
                                onMouseenter: g => r.value = h
                            }, [kt("span", BP, Ji(p.title), 1), o[2] || (o[2] = kt("svg", {
                                xmlns: "http://www.w3.org/2000/svg",
                                width: "16",
                                height: "16",
                                viewBox: "0 0 16 16",
                                fill: "none",
                                class: "tab-arrow"
                            }, [kt("path", {
                                d: "M6 12L10 8L6 4",
                                stroke: "currentColor",
                                "stroke-width": "1.5",
                                "stroke-linecap": "round",
                                "stroke-linejoin": "round"
                            })], -1))], 42, $P))), 128))]), kt("div", HP, [Re(i) ? (It(),
                            Cn("div", VP, [kt("div", jP, [Re(i).content ? (It(),
                            Wn(l, {
                                key: 0,
                                doc: Re(i).content
                            }, null, 8, ["doc"])) : ii("", !0)]), Re(i).links && Re(i).links.length > 0 ? (It(),
                            Cn("div", zP, [(It(!0),
                            Cn(er, null, So(Re(i).links, (p, h) => (It(),
                            Wn(Re(PP), {
                                key: h,
                                "as-child": ""
                            }, {
                                default: Tn( () => [tn(u, {
                                    to: Re(wu)(p.link),
                                    class: "content-link"
                                }, {
                                    default: Tn( () => [kt("span", UP, Ji(p.label), 1), o[3] || (o[3] = kt("svg", {
                                        xmlns: "http://www.w3.org/2000/svg",
                                        width: "16",
                                        height: "16",
                                        viewBox: "0 0 16 16",
                                        fill: "none",
                                        class: "link-arrow"
                                    }, [kt("path", {
                                        d: "M4 12L10 6M10 6H4M10 6V12",
                                        stroke: "currentColor",
                                        "stroke-width": "1.5",
                                        "stroke-linecap": "round",
                                        "stroke-linejoin": "round"
                                    })], -1))]),
                                    _: 2
                                }, 1032, ["to"])]),
                                _: 2
                            }, 1024))), 128))])) : ii("", !0)])) : ii("", !0)])])]),
                            _: 1
                        })]),
                        _: 1
                    }, 8, ["value"])]),
                    _: 1
                }), tn(Re(FP), {
                    ref: "viewportRef",
                    class: "navigation-menu-viewport"
                }, null, 512)]),
                _: 1
            }, 8, ["modelValue"])
        }
    }
})
  , dy = ua(WP, [["__scopeId", "data-v-79500c25"]])
  , qP = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: dy
}, Symbol.toStringTag, {
    value: "Module"
}))
  , GP = Mn({
    __name: "NavigationDropdown",
    props: {
        blok: {}
    },
    setup(e) {
        const t = e
          , n = zt( () => t.blok.sections ? t.blok.sections.map(r => ({
            title: r.title,
            content: r.content,
            links: r.links
        })) : []);
        return (r, i) => r.blok.label && r.blok.sections ? (It(),
        Wn(dy, {
            key: 0,
            label: r.blok.label,
            sections: Re(n)
        }, null, 8, ["label", "sections"])) : ii("", !0)
    }
});
function YP(e, t) {
    const n = Ru()
      , r = qr(!1)
      , i = qr(!0);
    let s = null
      , o = null;
    const l = () => {
        var g;
        (g = n.value) == null || g.stop(),
        s == null || s.kill(),
        o == null || o.kill(),
        s = In.gsap.timeline({
            defaults: {
                overwrite: "auto"
            }
        }),
        s.fromTo(e.value, {
            opacity: 0
        }, {
            opacity: 1,
            duration: .3,
            ease: "expo.out"
        }, 0),
        s.to(e.value, {
            clipPath: "inset(0% 0% 0% 0%)",
            duration: 1.4,
            ease: "menuEase"
        }, 0)
    }
      , u = () => {
        var m;
        (m = n.value) == null || m.start(),
        s == null || s.kill(),
        o == null || o.kill(),
        o = In.gsap.timeline({
            defaults: {
                overwrite: "auto"
            }
        }),
        o.to(e.value, {
            clipPath: "inset(0% 0% 100% 0%)",
            duration: .75,
            ease: "power2.inOut"
        }, 0),
        o.to(e.value, {
            opacity: 0,
            duration: .15
        }, .55),
        (Array.isArray(t.value) ? t.value : t.value ? [t.value] : []).forEach( (w, E) => {
            const y = w.querySelectorAll(".--char");
            o == null || o.set(y, {
                color: "var(--c-lime)",
                stagger: .05
            }, E * .05),
            o == null || o.to(y, {
                opacity: 0,
                stagger: .05,
                duration: .1
            }, E * .05)
        }
        )
    }
    ;
    return {
        mobileMenuOpen: r,
        canToggleMobileMenu: i,
        toggleMobileMenu: () => {
            r.value ? (r.value = !1,
            u()) : (r.value = !0,
            l())
        }
        ,
        closeMenu: () => {
            i.value = !1,
            r.value = !1,
            u()
        }
        ,
        openMobileMenu: l,
        closeMobileMenu: u
    }
}
function KP() {
    const e = Ut(1)
      , t = Ut(null)
      , n = Ut(new Set)
      , r = Ut([]);
    let i = null;
    const s = w => {
        const E = [];
        return w.forEach(y => {
            if (y.component === "Link")
                E.push({
                    id: y._uid,
                    label: y.label || "",
                    type: "link",
                    path: wu(y.link)
                });
            else if (y.component === "NavigationDropdown") {
                const R = (y.sections || []).map( (P, x) => ({
                    id: `${y._uid}-section-${x}`,
                    title: P.title || "",
                    links: (P.links || []).map( (v, k) => ({
                        id: `${y._uid}-section-${x}-link-${k}`,
                        label: v.label || "",
                        path: wu(v.link)
                    }))
                }));
                E.push({
                    id: y._uid,
                    label: y.label || "",
                    type: "dropdown",
                    sections: R
                })
            }
        }
        ),
        E
    }
      , o = (w, E=null, y) => {
        w === 1 ? (e.value = 1,
        t.value = null,
        r.value = []) : (r.value.push({
            level: e.value,
            parent: t.value
        }),
        e.value = w,
        t.value = E),
        y != null && y.value && g(y.value)
    }
      , l = w => {
        if (r.value.length > 0) {
            const E = r.value.pop();
            e.value = E.level,
            t.value = E.parent,
            w != null && w.value && g(w.value, !0)
        } else
            e.value = 1,
            t.value = null,
            w != null && w.value && g(w.value, !0)
    }
      , u = w => {
        n.value.has(w) ? n.value.delete(w) : n.value.add(w)
    }
      , p = w => n.value.has(w)
      , h = () => {
        e.value = 1,
        t.value = null,
        r.value = [],
        n.value.clear()
    }
      , g = (w, E=!1) => {
        i == null || i.kill(),
        i = In.gsap.timeline(),
        i.to(w, {
            x: E ? "100%" : "-100%",
            opacity: 0,
            duration: .2,
            ease: "power2.inOut"
        }),
        i.set(w, {
            x: E ? "-100%" : "100%"
        }),
        i.to(w, {
            x: 0,
            opacity: 1,
            duration: .2,
            ease: "power2.inOut"
        })
    }
    ;
    return {
        currentNavLevel: e,
        currentParent: t,
        expandedItems: n,
        navHistory: r,
        parseNavigationData: s,
        navigateToLevel: o,
        navigateBack: l,
        toggleExpand: u,
        isExpanded: p,
        resetNavigationState: h,
        getCurrentLevel2Items: w => {
            if (e.value !== 2 || !t.value)
                return [];
            const E = w.find(y => y.label === t.value);
            return (E == null ? void 0 : E.sections) || []
        }
    }
}
const XP = {
    class: "site-header"
}
  , QP = {
    class: "inner"
}
  , JP = {
    key: 0
}
  , ZP = {
    class: "nav | font-nav"
}
  , ek = {
    class: "header-cta"
}
  , tk = {
    class: "link-active"
}
  , nk = ["aria-expanded"]
  , rk = {
    ref: "mobileMenuRef",
    class: "mobile-menu",
    "data-lenis-prevent": ""
}
  , ik = ["aria-hidden"]
  , sk = {
    key: 0,
    class: "mobile-menu-items-level-1"
}
  , ok = ["onClick"]
  , ak = {
    key: 1,
    class: "mobile-menu-items-level-2"
}
  , lk = ["onClick"]
  , uk = {
    key: 0,
    class: "nav-level-3"
}
  , ck = {
    key: 1,
    class: "nav-item-link"
}
  , fk = {
    key: 0,
    class: "mobile-menu-contact"
}
  , dk = Mn({
    __name: "SiteHeader",
    setup(e) {
        const t = Ru()
          , n = Pu()
          , {data: r} = YC("config:storyblok")
          , i = Un("mobileMenuRef")
          , s = Un("mobileMenuItemsRef")
          , o = Un("link")
          , {mobileMenuOpen: l, toggleMobileMenu: u, closeMenu: p} = YP(i, o)
          , {currentNavLevel: h, currentParent: g, parseNavigationData: m, navigateToLevel: w, navigateBack: E, toggleExpand: y, isExpanded: R, resetNavigationState: P, getCurrentLevel2Items: x} = KP()
          , v = zt( () => n.path.startsWith("/blog/"))
          , k = zt( () => {
            var ee, Y, Z;
            return ((Z = (Y = (ee = r.value) == null ? void 0 : ee.story) == null ? void 0 : Y.content) == null ? void 0 : Z.navigation_items) || []
        }
        )
          , S = zt( () => m(k.value))
          , W = zt( () => x(S.value))
          , K = zt( () => {
            var Y, Z, Q, ue;
            const ee = (ue = (Q = (Z = (Y = r.value) == null ? void 0 : Y.story) == null ? void 0 : Z.content) == null ? void 0 : Q.cta) == null ? void 0 : ue[0];
            return ee ? {
                label: ee.label,
                path: wu(ee.link)
            } : null
        }
        )
          , be = () => {
            l.value,
            P(),
            u()
        }
          , fe = () => {
            P(),
            p()
        }
          , ge = (ee, Y=null) => {
            w(ee, Y, s)
        }
          , J = () => {
            E(s)
        }
          , re = () => {
            var ee;
            n.name === "index" && ((ee = t.value) == null || ee.scrollTo(0))
        }
        ;
        return xi( () => {
            In.gsap.set(i.value, {
                autoAlpha: 1,
                clipPath: "inset(0% 0% 100% 0%)"
            })
        }
        ),
        (ee, Y) => {
            const Z = V0
              , Q = Q0
              , ue = J0;
            return It(),
            Cn("header", XP, [tn(ue, {
                tag: "div"
            }, {
                default: Tn( () => {
                    var se, ye, Ze;
                    return [Re(v) ? (It(),
                    Wn(Z, {
                        key: 0,
                        to: "/resources",
                        class: "back-to-resources-button | font-nav",
                        "aria-label": "Back to Resources"
                    }, {
                        default: Tn( () => Y[1] || (Y[1] = [kt("svg", {
                            xmlns: "http://www.w3.org/2000/svg",
                            width: "24",
                            height: "25",
                            viewBox: "0 0 24 25",
                            fill: "currentColor"
                        }, [kt("path", {
                            d: "M20 11.5H7.83L13.42 5.91L12 4.5L4 12.5L12 20.5L13.41 19.09L7.83 13.5H20V11.5Z",
                            fill: "currentColor"
                        })], -1), kt("span", null, "Back to Resources", -1)])),
                        _: 1
                    })) : ii("", !0), kt("div", QP, [!Re(l) || Re(h) === 1 ? (It(),
                    Wn(Z, {
                        key: 0,
                        class: "logo-link",
                        to: "/",
                        "aria-label": "Go to homepage",
                        onClick: Y[0] || (Y[0] = () => {
                            fe(),
                            re()
                        }
                        )
                    }, {
                        default: Tn( () => [tn(Q, {
                            class: "logo"
                        })]),
                        _: 1
                    })) : ii("", !0), Re(l) && Re(h) > 1 ? (It(),
                    Cn("button", {
                        key: 1,
                        class: "mobile-nav-back-button | label-6",
                        "aria-label": "Go back",
                        onClick: J
                    }, [Y[2] || (Y[2] = kt("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        width: "16",
                        height: "16",
                        viewBox: "0 0 16 16",
                        fill: "none"
                    }, [kt("path", {
                        d: "M10 12L6 8L10 4",
                        stroke: "currentColor",
                        "stroke-width": "1.5",
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round"
                    })], -1)), Re(g) ? (It(),
                    Cn("span", JP, Ji(Re(g)), 1)) : ii("", !0)])) : ii("", !0), kt("nav", ZP, [kt("ul", null, [(It(!0),
                    Cn(er, null, So(((Ze = (ye = (se = Re(r)) == null ? void 0 : se.story) == null ? void 0 : ye.content) == null ? void 0 : Ze.navigation_items) || [], qe => (It(),
                    Cn("li", {
                        key: qe._uid
                    }, [qe.component === "NavigationDropdown" ? (It(),
                    Wn(GP, {
                        key: 0,
                        blok: qe
                    }, null, 8, ["blok"])) : qe.component === "Link" ? (It(),
                    Wn(Z, {
                        key: 1,
                        to: Re(wu)(qe.link)
                    }, {
                        default: Tn( () => [To(Ji(qe.label), 1)]),
                        _: 2
                    }, 1032, ["to"])) : ii("", !0)]))), 128))])]), kt("div", ek, [Re(K) ? (It(),
                    Wn(Z, {
                        key: 0,
                        class: "cta-button",
                        to: Re(K).path
                    }, {
                        default: Tn( () => [kt("span", tk, Ji(Re(K).label), 1)]),
                        _: 1
                    }, 8, ["to"])) : ii("", !0)]), kt("button", {
                        class: ks(["toggle-mobile-menu-button | label-6", {
                            active: Re(l)
                        }]),
                        "aria-label": "Toggle menu",
                        "aria-expanded": Re(l) ? "true" : "false",
                        "aria-haspopup": "true",
                        "aria-controls": "mobile-menu",
                        onClick: be
                    }, Y[3] || (Y[3] = [kt("span", {
                        class: "wrapper"
                    }, [kt("span", {
                        class: "hl --1 t"
                    }), kt("span", {
                        class: "hl --2 t"
                    }), kt("span", {
                        class: "cl --1 t"
                    }, [kt("span", {
                        class: "cli --g t"
                    }), kt("span", {
                        class: "cli t"
                    })]), kt("span", {
                        class: "cl --2 t"
                    }, [kt("span", {
                        class: "cli --g t"
                    }), kt("span", {
                        class: "cli t"
                    })])], -1)]), 10, nk)]), kt("div", rk, [kt("nav", {
                        id: "mobile-menu",
                        ref: "mobileMenuItemsRef",
                        class: "mobile-menu-items | menu-typo no-scrollbar",
                        "aria-hidden": Re(l) ? "false" : "true"
                    }, [Re(h) === 1 ? (It(),
                    Cn("ul", sk, [(It(!0),
                    Cn(er, null, So(Re(S), qe => (It(),
                    Cn("li", {
                        key: qe.id,
                        ref_for: !0,
                        ref: "link"
                    }, [qe.type === "link" ? (It(),
                    Wn(Z, {
                        key: 0,
                        to: qe.path,
                        class: "nav-item-link",
                        onClick: fe
                    }, {
                        default: Tn( () => [To(Ji(qe.label), 1)]),
                        _: 2
                    }, 1032, ["to"])) : qe.type === "dropdown" ? (It(),
                    Cn("button", {
                        key: 1,
                        type: "button",
                        class: "nav-item-button",
                        onClick: nt => ge(2, qe.label)
                    }, [kt("span", null, Ji(qe.label), 1), Y[4] || (Y[4] = kt("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        width: "16",
                        height: "16",
                        viewBox: "0 0 16 16",
                        fill: "none",
                        class: "chevron-right"
                    }, [kt("path", {
                        d: "M6 12L10 8L6 4",
                        stroke: "currentColor",
                        "stroke-width": "1.5",
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round"
                    })], -1))], 8, ok)) : ii("", !0)]))), 128))])) : ii("", !0), Re(h) === 2 ? (It(),
                    Cn("ul", ak, [(It(!0),
                    Cn(er, null, So(Re(W), qe => (It(),
                    Cn("li", {
                        key: qe.id,
                        class: "nav-item-level-2"
                    }, [qe.links && qe.links.length > 0 ? (It(),
                    Cn(er, {
                        key: 0
                    }, [kt("button", {
                        type: "button",
                        class: ks(["nav-item-button expandable", {
                            expanded: Re(R)(qe.id)
                        }]),
                        onClick: nt => Re(y)(qe.id)
                    }, [kt("span", null, Ji(qe.title), 1), (It(),
                    Cn("svg", {
                        xmlns: "http://www.w3.org/2000/svg",
                        width: "16",
                        height: "16",
                        viewBox: "0 0 16 16",
                        fill: "none",
                        class: ks(["chevron-down", {
                            "chevron-up": Re(R)(qe.id)
                        }])
                    }, Y[5] || (Y[5] = [kt("path", {
                        d: "M4 6L8 10L12 6",
                        stroke: "currentColor",
                        "stroke-width": "1.5",
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round"
                    }, null, -1)]), 2))], 10, lk), Re(R)(qe.id) ? (It(),
                    Cn("ul", uk, [(It(!0),
                    Cn(er, null, So(qe.links, nt => (It(),
                    Cn("li", {
                        key: nt.id
                    }, [tn(Z, {
                        to: nt.path,
                        class: "nav-item-link level-3",
                        onClick: fe
                    }, {
                        default: Tn( () => [To(Ji(nt.label), 1)]),
                        _: 2
                    }, 1032, ["to"])]))), 128))])) : ii("", !0)], 64)) : (It(),
                    Cn("span", ck, Ji(qe.title), 1))]))), 128))])) : ii("", !0)], 8, ik), Re(l) ? (It(),
                    Cn("div", fk, [Re(K) ? (It(),
                    Wn(Z, {
                        key: 0,
                        class: "mobile-contact-button | label-4",
                        to: Re(K).path,
                        onClick: fe
                    }, {
                        default: Tn( () => [To(Ji(Re(K).label), 1)]),
                        _: 1
                    }, 8, ["to"])) : ii("", !0)])) : ii("", !0)], 512)]
                }
                ),
                _: 1
            })])
        }
    }
})
  , hy = ua(dk, [["__scopeId", "data-v-3faa160e"]])
  , hk = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: hy
}, Symbol.toStringTag, {
    value: "Module"
}))
  , py = (e="RouteProvider") => Mn({
    name: e,
    props: {
        vnode: {
            type: Object,
            required: !0
        },
        route: {
            type: Object,
            required: !0
        },
        vnodeRef: Object,
        renderKey: String,
        trackRootNodes: Boolean
    },
    setup(t) {
        const n = t.renderKey
          , r = t.route
          , i = {};
        for (const s in t.route)
            Object.defineProperty(i, s, {
                get: () => n === t.renderKey ? t.route[s] : r[s],
                enumerable: !0
            });
        return ns(Tu, Ts(i)),
        () => ar(t.vnode, {
            ref: t.vnodeRef
        })
    }
})
  , pk = py()
  , Ig = new WeakMap
  , gk = Mn({
    name: "NuxtPage",
    inheritAttrs: !1,
    props: {
        name: {
            type: String
        },
        transition: {
            type: [Boolean, Object],
            default: void 0
        },
        keepalive: {
            type: [Boolean, Object],
            default: void 0
        },
        route: {
            type: Object
        },
        pageKey: {
            type: [Function, String],
            default: null
        }
    },
    setup(e, {attrs: t, slots: n, expose: r}) {
        const i = Tr()
          , s = Ut()
          , o = pr(Tu, null);
        let l;
        r({
            pageRef: s
        });
        const u = pr(i0, null);
        let p;
        const h = i.deferHydration();
        if (i.isHydrating) {
            const m = i.hooks.hookOnce("app:error", h);
            rs().beforeEach(m)
        }
        e.pageKey && tr( () => e.pageKey, (m, w) => {
            m !== w && i.callHook("page:loading:start")
        }
        );
        let g = !1;
        {
            const m = rs().beforeResolve( () => {
                g = !1
            }
            );
            Io( () => {
                m()
            }
            )
        }
        return () => ar(I0, {
            name: e.name,
            route: e.route,
            ...t
        }, {
            default: m => {
                const w = mk(o, m.route, m.Component)
                  , E = o && o.matched.length === m.route.matched.length;
                if (!m.Component) {
                    if (p && !E)
                        return p;
                    h();
                    return
                }
                if (p && u && !u.isCurrent(m.route))
                    return p;
                if (w && o && (!u || u != null && u.isCurrent(o)))
                    return E ? p : null;
                const y = Ld(m, e.pageKey)
                  , R = yk(o, m.route, m.Component);
                !i.isHydrating && l === y && !R && Ci( () => {
                    g = !0,
                    i.callHook("page:loading:end")
                }
                ),
                l = y;
                const P = !!(e.transition ?? m.route.meta.pageTransition ?? Rp)
                  , x = P && _k([e.transition, m.route.meta.pageTransition, Rp, {
                    onBeforeLeave() {
                        i._runningTransition = !0
                    },
                    onAfterLeave() {
                        delete i._runningTransition,
                        i.callHook("page:transition:finish", m.Component)
                    }
                }])
                  , v = e.keepalive ?? m.route.meta.keepalive ?? qw;
                return p = N0(P && x, MC(v, ar(sf, {
                    suspensible: !0,
                    onPending: () => i.callHook("page:start", m.Component),
                    onResolve: () => {
                        Ci( () => i.callHook("page:finish", m.Component).then( () => {
                            if (!g && !R)
                                return g = !0,
                                i.callHook("page:loading:end")
                        }
                        ).finally(h))
                    }
                }, {
                    default: () => {
                        const k = {
                            key: y || void 0,
                            vnode: n.default ? vk(n.default, m) : m.Component,
                            route: m.route,
                            renderKey: y || void 0,
                            trackRootNodes: P,
                            vnodeRef: s
                        };
                        if (!v)
                            return ar(pk, k);
                        const S = m.Component.type
                          , W = S;
                        let K = Ig.get(W);
                        return K || (K = py(S.name || S.__name),
                        Ig.set(W, K)),
                        ar(K, k)
                    }
                }))).default(),
                p
            }
        })
    }
});
function _k(e) {
    const t = e.filter(Boolean).map(n => ({
        ...n,
        onAfterLeave: n.onAfterLeave ? Ah(n.onAfterLeave) : void 0
    }));
    return lf(...t)
}
function mk(e, t, n) {
    if (!e)
        return !1;
    const r = t.matched.findIndex(i => {
        var s;
        return ((s = i.components) == null ? void 0 : s.default) === (n == null ? void 0 : n.type)
    }
    );
    return !r || r === -1 ? !1 : t.matched.slice(0, r).some( (i, s) => {
        var o, l, u;
        return ((o = i.components) == null ? void 0 : o.default) !== ((u = (l = e.matched[s]) == null ? void 0 : l.components) == null ? void 0 : u.default)
    }
    ) || n && Ld({
        route: t,
        Component: n
    }) !== Ld({
        route: e,
        Component: n
    })
}
function yk(e, t, n) {
    return e ? t.matched.findIndex(i => {
        var s;
        return ((s = i.components) == null ? void 0 : s.default) === (n == null ? void 0 : n.type)
    }
    ) < t.matched.length - 1 : !1
}
function vk(e, t) {
    const n = e(t);
    return n.length === 1 ? ar(n[0]) : ar(er, void 0, n)
}
const bk = Mn({
    name: "LayoutLoader",
    inheritAttrs: !1,
    props: {
        name: String,
        layoutProps: Object
    },
    setup(e, t) {
        return () => ar(ea[e.name], e.layoutProps, t.slots)
    }
})
  , wk = {
    name: {
        type: [String, Boolean, Object],
        default: null
    },
    fallback: {
        type: [String, Object],
        default: null
    }
}
  , Dk = Mn({
    name: "NuxtLayout",
    inheritAttrs: !1,
    props: wk,
    setup(e, t) {
        const n = Tr()
          , r = pr(Tu)
          , i = r === Pu() ? PC() : r
          , s = zt( () => {
            let u = Re(e.name) ?? i.meta.layout ?? "default";
            return u && !(u in ea) && e.fallback && (u = Re(e.fallback)),
            u
        }
        )
          , o = Ut();
        t.expose({
            layoutRef: o
        });
        const l = n.deferHydration();
        if (n.isHydrating) {
            const u = n.hooks.hookOnce("app:error", l);
            rs().beforeEach(u)
        }
        return () => {
            const u = s.value && s.value in ea
              , p = i.meta.layoutTransition ?? Ww;
            return N0(u && p, {
                default: () => ar(sf, {
                    suspensible: !0,
                    onResolve: () => {
                        Ci(l)
                    }
                }, {
                    default: () => ar(Ek, {
                        layoutProps: oo(t.attrs, {
                            ref: o
                        }),
                        key: s.value || void 0,
                        name: s.value,
                        shouldProvide: !e.name,
                        hasTransition: !!p
                    }, t.slots)
                })
            }).default()
        }
    }
})
  , Ek = Mn({
    name: "NuxtLayoutProvider",
    inheritAttrs: !1,
    props: {
        name: {
            type: [String, Boolean]
        },
        layoutProps: {
            type: Object
        },
        hasTransition: {
            type: Boolean
        },
        shouldProvide: {
            type: Boolean
        }
    },
    setup(e, t) {
        const n = e.name;
        return e.shouldProvide && ns(i0, {
            isCurrent: r => n === (r.meta.layout ?? "default")
        }),
        () => {
            var r, i;
            return !n || typeof n == "string" && !(n in ea) ? (i = (r = t.slots).default) == null ? void 0 : i.call(r) : ar(bk, {
                key: n,
                layoutProps: e.layoutProps,
                name: n
            }, t.slots)
        }
    }
});
var Ck;
(e => {
    e.watcher = "watcher",
    e.instance = "instance",
    e.scope = "scope"
}
)(Ck || (Ck = {}));
var Fu = (e, t) => {
    const n = (t == null ? void 0 : t.unsafe) || !1
      , r = (t == null ? void 0 : t.forceMode) || !1
      , i = qr(null)
      , s = Lo()
      , o = h_()
      , l = Or();
    switch (r) {
    case "instance":
        {
            if (!l)
                throw "useSafeClient is called outside an instance";
            const u = Ss();
            l.isMounted ? i.value = u.run( () => e()) : xi( () => {
                i.value = u.run( () => e())
            }
            );
            break
        }
    case "scope":
        {
            if (!s)
                throw "useSafeClient is called outside a scope";
            const u = Ss();
            i.value = u.run( () => e());
            break
        }
    case "watcher":
        {
            if (!o)
                throw "useSafeClient is called outside a watcher";
            const u = Ss();
            Aa( () => {
                u.stop()
            }
            ),
            i.value = u.run( () => e());
            break
        }
    default:
        {
            if (!n && !s && !o && !l)
                throw "useSafeClient is called outside a scope or watcher";
            const u = Ss();
            o && Aa( () => {
                u.stop()
            }
            ),
            l && !l.isMounted && !o ? xi( () => {
                i.value = u.run( () => e())
            }
            ) : i.value = u.run( () => e())
        }
        return i
    }
}
;
function gf(e, t, n) {
    return Fu( () => {
        const r = Ou();
        r.add(e, t, n, !0),
        ds( () => {
            r.remove(e)
        }
        )
    }
    )
}
function xk(e, t) {
    const n = Ou()
      , r = Ut()
      , i = tr(r, o => {
        t(o)
    }
    , {
        flush: "sync"
    });
    return gf( () => {
        r.value = n.breakpoints.find(o => o.name === e).active
    }
    , -1, !0),
    i
}
function Sk(e) {
    const t = Ou()
      , n = Ss()
      , r = i => {
        e(i.matches)
    }
    ;
    typeof window < "u" && n.run( () => {
        t.pointerMatchMedia.addEventListener("change", r),
        e(t.pointerMatchMedia.matches),
        ds( () => {
            t.pointerMatchMedia.removeEventListener("change", r)
        }
        )
    }
    )
}
function Iu() {
    const e = Ut(!1);
    return xk("lg", t => {
        e.value = t
    }
    ),
    e
}
function Tk() {
    const e = Ut(!1);
    return Sk(t => {
        e.value = t
    }
    ),
    e
}
function $A() {
    const e = Tk()
      , t = Iu();
    return zt( () => !e.value || !t.value)
}
function _f(e, t) {
    return Fu( () => {
        const n = X0();
        n.add(e, t),
        ds( () => {
            n.remove(e)
        }
        )
    }
    )
}
var Pk = (e, t=!1, n) => Fu( () => {
    const r = In.gsap.context(i => e == null ? void 0 : e(i));
    return ds( () => {
        r.kill(t)
    }
    ),
    r
}
, {
    forceMode: n
})
  , BA = (e, t=!1) => {
    if (!Lo())
        throw new Error("useGSAPMatchMedia must be called within a scope");
    const n = Ou();
    return Fu( () => {
        const r = Ss()
          , i = In.gsap.matchMedia()
          , s = n.breakpoints.reduce( (o, l) => (o[`is${_l(l.name)}`] = `(min-width: ${l.size}px)`,
        o), {});
        return s.isPointerFine = "(hover: hover)",
        i.add(s, o => r.run( () => e == null ? void 0 : e(o))),
        ds( () => {
            i.kill(t)
        }
        ),
        i
    }
    )
}
  , HA = ({target: e=Ut(0), damped: t=Ut(0), lambda: n=Ut(8)}={}) => (e = ko(e),
n = ko(n),
t = ko(t),
_f( ({dt: r}) => {
    t.value = pl.Damp(t.value, e.value, n.value, r)
}
),
{
    target: e,
    damped: t
})
  , On = (e => (e[e.top = 0] = "top",
e[e.right = 1] = "right",
e[e.bottom = 2] = "bottom",
e[e.left = 3] = "left",
e))(On || {});
const di = e => Math.round(e * 100) / 100
  , Xf = (e, t) => ({
    x: e.x - t.x,
    y: e.y - t.y
})
  , kk = (e, t) => ({
    x: e.x + t.x,
    y: e.y + t.y
})
  , Ng = (e, t) => ({
    x: e.x * t,
    y: e.y * t
})
  , $g = e => {
    const t = Math.hypot(e.x, e.y);
    return t === 0 ? {
        x: 0,
        y: 0
    } : {
        x: e.x / t,
        y: e.y / t
    }
}
  , Bg = (e, t) => Math.hypot(t.x - e.x, t.y - e.y)
  , Hg = (e, t, n) => {
    const r = $g(Xf(e, t))
      , i = $g(Xf(n, e))
      , s = -(r.x * i.x + r.y * i.y)
      , o = Math.acos(Math.min(Math.max(s, -1), 1)) / 2
      , l = Bg(t, e)
      , u = Bg(e, n)
      , p = Math.min(l, u) / 2;
    let h = e.radius || 0;
    h > p && (h = p);
    const g = h * Math.tan(o)
      , m = Xf(e, Ng(r, h))
      , w = kk(e, Ng(i, h))
      , y = r.x * i.y - r.y * i.x < 0 ? 0 : 1;
    return {
        startPoint: m,
        endPoint: w,
        actualRadius: g,
        sweepFlag: y,
        isTooLarge: g >= 1e3
    }
}
  , Hc = e => {
    if (e.length < 2)
        return "";
    const t = e[0]
      , n = e[e.length - 1];
    let r = "";
    if (t.radius && e.length > 2) {
        const i = Hg(t, n, e[1]);
        r = `M ${di(i.startPoint.x)},${di(i.startPoint.y)}`,
        i.isTooLarge ? r += ` L ${di(i.endPoint.x)},${di(i.endPoint.y)}` : r += ` A ${di(i.actualRadius)},${di(i.actualRadius)} 0 0 ${i.sweepFlag} ${di(i.endPoint.x)},${di(i.endPoint.y)}`
    } else
        r = `M ${di(t.x)},${di(t.y)}`;
    for (let i = 1; i < e.length; i++) {
        const s = e[i];
        if (s.radius) {
            const o = e[i - 1]
              , l = i === e.length - 1 ? e[0] : e[i + 1]
              , u = Hg(s, o, l);
            u.isTooLarge ? r += ` L ${di(u.startPoint.x)},${di(u.startPoint.y)}` : r += ` L ${di(u.startPoint.x)},${di(u.startPoint.y)} A ${di(u.actualRadius)},${di(u.actualRadius)} 0 0 ${u.sweepFlag} ${di(u.endPoint.x)},${di(u.endPoint.y)}`
        } else
            r += ` L ${di(s.x)},${di(s.y)}`
    }
    return r
}
  , Ak = {
    class: "svg-mask"
}
  , Rk = ["width", "height", "viewBox"]
  , Ok = ["id"]
  , Mk = ["d"]
  , Lk = ["id"]
  , Fk = ["d"]
  , Uo = .5
  , Ik = Mn({
    __name: "SVGMask",
    props: {
        notches: {
            default: () => []
        },
        useClip: {
            type: Boolean,
            default: !0
        }
    },
    setup(e) {
        Sm(y => ({
            d27fb6da: Re(l),
            b18bdda2: Re(o)
        }));
        const t = e
          , n = Gr({
            width: 0,
            height: 0
        })
          , r = Ut(!1)
          , i = Un("el")
          , s = Zl()
          , o = zt( () => `url(#mask-${s})`)
          , l = zt( () => `url(#clip-${s})`)
          , u = zt( () => 1);
        zt( () => u.value * .5);
        const p = zt( () => ({
            [On.top]: t.notches.filter(y => y.direction === On.top).map(y => ({
                radius: y.radius ?? 8,
                notchWidth: y.notchWidth ?? .9,
                ...y
            })).sort( (y, R) => y.position - R.position),
            [On.right]: t.notches.filter(y => y.direction === On.right).map(y => ({
                radius: y.radius ?? 8,
                notchWidth: y.notchWidth ?? .9,
                ...y
            })).sort( (y, R) => y.position - R.position),
            [On.bottom]: t.notches.filter(y => y.direction === On.bottom).map(y => ({
                radius: y.radius ?? 8,
                notchWidth: y.notchWidth ?? .9,
                ...y
            })).sort( (y, R) => R.position - y.position),
            [On.left]: t.notches.filter(y => y.direction === On.left).map(y => ({
                radius: y.radius ?? 8,
                notchWidth: y.notchWidth ?? .9,
                ...y
            })).sort( (y, R) => R.position - y.position)
        }))
          , h = zt( () => ({
            [On.top]: w(On.top),
            [On.right]: w(On.right),
            [On.bottom]: w(On.bottom),
            [On.left]: w(On.left)
        }))
          , g = zt( () => {
            const y = Math.max(-.5, h.value[On.left] - Uo)
              , R = Math.max(-.5, h.value[On.top] - Uo)
              , P = Math.min(n.width + Uo, n.width - h.value[On.right] + Uo)
              , x = Math.min(n.height + Uo, n.height - h.value[On.bottom] + Uo);
            return [{
                x: y,
                y: R
            }, ...p.value[On.top].map(v => m(v)), {
                x: P,
                y: R
            }, ...p.value[On.right].map(v => m(v)), {
                x: P,
                y: x
            }, ...p.value[On.bottom].map(v => m(v)), {
                x: y,
                y: x
            }, ...p.value[On.left].map(v => m(v)), {
                x: y,
                y: R
            }].flat()
        }
        );
        xi( () => {
            r.value = !0
        }
        );
        function m(y) {
            const R = pl.Arr.create(4).map( () => ({
                x: 0,
                y: 0,
                radius: 40 / y.size * y.radius * .01
            }))
              , P = (1 - y.notchWidth) * n.width * .25;
            switch (y.direction) {
            case On.top:
                {
                    const x = h.value[On.top];
                    R[0].x = n.width * (y.position - y.size * .5) - P,
                    R[0].y = x,
                    R[1].x = n.width * (y.position - y.size * .5) + P,
                    R[1].y = x + u.value * y.offset,
                    R[2].x = n.width * (y.position + y.size * .5) - P,
                    R[2].y = x + u.value * y.offset,
                    R[3].x = n.width * (y.position + y.size * .5) + P,
                    R[3].y = x;
                    break
                }
            case On.right:
                {
                    const x = h.value[On.right];
                    R[0].x = n.width - x,
                    R[0].y = n.height * (y.position - y.size * .5) - P,
                    R[1].x = n.width - x - u.value * y.offset,
                    R[1].y = n.height * (y.position - y.size * .5) + P,
                    R[2].x = n.width - x - u.value * y.offset,
                    R[2].y = n.height * (y.position + y.size * .5) - P,
                    R[3].x = n.width - x,
                    R[3].y = n.height * (y.position + y.size * .5) + P;
                    break
                }
            case On.bottom:
                {
                    const x = h.value[On.bottom];
                    R[0].x = n.width * (y.position + y.size * .5) + P,
                    R[0].y = n.height - x,
                    R[1].x = n.width * (y.position + y.size * .5) - P,
                    R[1].y = n.height - x - u.value * y.offset,
                    R[2].x = n.width * (y.position - y.size * .5) + P,
                    R[2].y = n.height - x - u.value * y.offset,
                    R[3].x = n.width * (y.position - y.size * .5) - P,
                    R[3].y = n.height - x;
                    break
                }
            case On.left:
                {
                    const x = h.value[On.left];
                    R[0].x = x,
                    R[0].y = n.height * (y.position + y.size * .5) + P,
                    R[1].x = x + u.value * y.offset,
                    R[1].y = n.height * (y.position + y.size * .5) - P,
                    R[2].x = x + u.value * y.offset,
                    R[2].y = n.height * (y.position - y.size * .5) + P,
                    R[3].x = x,
                    R[3].y = n.height * (y.position - y.size * .5) - P;
                    break
                }
            }
            return R
        }
        function w(y) {
            return Math.abs(p.value[y].reduce( (R, P) => (y === On.bottom || y === On.top,
            Math.min(R, u.value * P.offset)), 0))
        }
        const E = qr("");
        return tr(g, () => {
            E.value = Hc(g.value)
        }
        , {
            immediate: !0
        }),
        _f( () => {}
        ),
        gf( () => {
            var y, R;
            n.width = ((y = i.value) == null ? void 0 : y.offsetWidth) || 1,
            n.height = ((R = i.value) == null ? void 0 : R.offsetHeight) || 1
        }
        , void 0, !0),
        (y, R) => (It(),
        Cn("div", Ak, [(It(),
        Cn("svg", {
            width: Re(n).width,
            height: Re(n).height,
            viewBox: `${-.5} ${-.5} ${Re(n).width + Uo * 2} ${Re(n).height + Uo * 2}`,
            class: "svg",
            "shape-rendering": "geometricPrecision"
        }, [kt("defs", null, [t.useClip ? (It(),
        Cn("clipPath", {
            key: 0,
            id: `clip-${Re(s)}`,
            clipPathUnits: "userSpaceOnUse"
        }, [kt("path", {
            d: Re(E)
        }, null, 8, Mk)], 8, Ok)) : (It(),
        Cn("mask", {
            key: 1,
            id: `mask-${Re(s)}`
        }, [kt("path", {
            d: Re(E),
            fill: "white"
        }, null, 8, Fk)], 8, Lk))])], 8, Rk)), kt("div", {
            ref_key: "el",
            ref: i,
            class: ks(["slot", {
                ssr: !Re(r),
                "use-clip": t.useClip
            }])
        }, [ys(y.$slots, "default", {}, void 0, !0)], 2)]))
    }
})
  , gy = ua(Ik, [["__scopeId", "data-v-ebd3c3c9"]])
  , Nk = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "1920",
    height: "1080",
    fill: "none",
    viewBox: "0 0 1920 1080"
};
function $k(e, t) {
    return It(),
    Cn("svg", Nk, t[0] || (t[0] = [gh('<path stroke="url(#a)" d="M-700.91 637.033c-35.991 0-65.09-29.072-65.09-65.03V243.03c0-35.958 29.099-65.03 65.09-65.03h443.989c17.306 0 33.846 6.885 46.099 19.126l333.719 333.258a53 53 0 0 0 4.135 4.132c10.261 9.333 23.739 15.301 38.748 15.913 35.071 1.377 63.711-29.99 63.711-65.03V243.03c0-35.958 29.099-65.03 65.09-65.03H696.5c38.66 0 70-31.34 70-70v-298" opacity=".15"></path><path stroke="url(#b)" d="M1243-383v495.474c0 35.957 29.1 65.029 65.09 65.029h275.35c35.99 0 65.09 29.072 65.09 65.03V436.5c0 33.137 26.87 60 60 60H2002" opacity=".15"></path><path stroke="#052424" d="m284 1160.5 252.476-251.616a26 26 0 0 0 2.91-2.908c9.802-10.557 15.928-24.481 16.54-39.782C557.152 831.46 525.602 803 490.837 803H-7M1270 1115V913.089c0-35.99 29.07-65.089 65.03-65.089h429.55a79.98 79.98 0 0 1 46.91 15.195L2082 1059" opacity=".15"></path><defs><linearGradient id="a" x1="384.5" x2="384.5" y1="53.5" y2="-181" gradientUnits="userSpaceOnUse"><stop stop-color="#052424"></stop><stop offset="1" stop-color="#052424" stop-opacity="0"></stop></linearGradient><linearGradient id="b" x1="1445.77" x2="1445.77" y1="-389.5" y2="726" gradientUnits="userSpaceOnUse"><stop stop-color="#052424" stop-opacity="0"></stop><stop offset=".25" stop-color="#052424"></stop><stop offset=".75" stop-color="#052424"></stop><stop offset="1" stop-color="#052424" stop-opacity="0"></stop></linearGradient></defs>', 4)]))
}
const Vg = {
    render: $k
}
  , Bk = {
    ref: "topMask",
    class: "top-mask"
}
  , Hk = {
    ref: "fullWrapperTop",
    class: "full-wrapper"
}
  , Vk = {
    ref: "backgroundWrapperTop",
    class: "background-wrapper"
}
  , jk = {
    ref: "bottomMask",
    class: "bottom-mask"
}
  , zk = {
    ref: "fullWrapperBottom",
    class: "full-wrapper"
}
  , Uk = {
    ref: "backgroundWrapperBottom",
    class: "background-wrapper"
}
  , Wk = Mn({
    __name: "AppTransition",
    setup(e, {expose: t}) {
        const n = Un("el")
          , r = Un("bgOverlayEl")
          , i = Un("overlayEl")
          , s = Un("loaderEl")
          , o = Un("topEl")
          , l = Un("bottomEl")
          , u = Un("fullWrapperTop")
          , p = Un("fullWrapperBottom");
        Un("backgroundWrapperTop"),
        Un("backgroundWrapperBottom");
        const h = Iu()
          , g = Gr([{
            direction: On.bottom,
            notchWidth: .95,
            offset: 0,
            position: .5,
            radius: 40,
            size: .75
        }])
          , m = Gr([{
            direction: On.top,
            notchWidth: .95,
            offset: 0,
            position: .5,
            radius: 40,
            size: .75
        }])
          , w = Ut(!1)
          , E = zt( () => h.value ? 40 : 20);
        return t({
            show: () => {
                w.value = !0;
                const P = In.gsap.timeline();
                return In.gsap.set(n.value, {
                    autoAlpha: 1
                }),
                In.gsap.set(s.value, {
                    opacity: 0
                }),
                P.to(i.value, {
                    opacity: 1,
                    ease: "power1.out",
                    duration: .4
                }),
                P
            }
            ,
            hide: () => {
                w.value = !1;
                const P = In.gsap.timeline();
                return In.gsap.set(i.value, {
                    opacity: 0
                }),
                In.gsap.set(s.value, {
                    opacity: 1
                }),
                P.fromTo(r.value, {
                    opacity: 1
                }, {
                    opacity: 0,
                    ease: "power1.in",
                    duration: .8
                }, 0),
                P.fromTo(o.value, {
                    yPercent: 0
                }, {
                    yPercent: -100,
                    ease: "expo.inOut",
                    duration: 1.2
                }, 0),
                P.fromTo(l.value, {
                    yPercent: 0
                }, {
                    yPercent: 100,
                    ease: "expo.inOut",
                    duration: 1.2
                }, "<"),
                P.fromTo(u.value, {
                    yPercent: 0
                }, {
                    yPercent: 50,
                    ease: "expo.inOut",
                    duration: 1.2
                }, "<"),
                P.fromTo(p.value, {
                    yPercent: 0
                }, {
                    yPercent: -50,
                    ease: "expo.inOut",
                    duration: 1.2
                }, "<"),
                P.fromTo([g, m], {
                    offset: 0,
                    size: .5
                }, {
                    offset: E.value,
                    size: .9,
                    ease: "custom.fastInOut",
                    duration: .6
                }, "<"),
                P.to([g, m], {
                    offset: -E.value,
                    ease: "expo.out",
                    duration: .6
                }, "<0.6"),
                P.set(n.value, {
                    autoAlpha: 0
                }),
                P
            }
        }),
        (P, x) => {
            const v = gy;
            return It(),
            Cn("div", {
                ref_key: "el",
                ref: n,
                class: ks(["app-transition", {
                    active: Re(w)
                }])
            }, [kt("div", {
                ref_key: "bgOverlayEl",
                ref: r,
                class: "bg-overlay"
            }, null, 512), kt("div", {
                ref_key: "loaderEl",
                ref: s,
                class: "loader"
            }, [kt("div", {
                ref_key: "topEl",
                ref: o,
                class: "top"
            }, [tn(v, {
                "use-clip": "",
                notches: Re(g)
            }, {
                default: Tn( () => [kt("div", Bk, [kt("div", Hk, [kt("div", Vk, [tn(Re(Vg))], 512)], 512)], 512)]),
                _: 1
            }, 8, ["notches"])], 512), kt("div", {
                ref_key: "bottomEl",
                ref: l,
                class: "bottom"
            }, [tn(v, {
                "use-clip": "",
                notches: Re(m)
            }, {
                default: Tn( () => [kt("div", jk, [kt("div", zk, [kt("div", Uk, [tn(Re(Vg))], 512)], 512)], 512)]),
                _: 1
            }, 8, ["notches"])], 512)], 512), kt("div", {
                ref_key: "overlayEl",
                ref: i,
                class: "overlay"
            }, null, 512)], 2)
        }
    }
})
  , _y = ua(Wk, [["__scopeId", "data-v-2a5cb2b0"]])
  , qk = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: _y
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Gk = ["viewBox"]
  , Yk = {
    id: "mask",
    x: "0",
    y: "0",
    width: "100",
    height: "100",
    maskUnits: "userSpaceOnUse",
    maskContentUnits: "userSpaceOnUse"
}
  , Kk = ["d"]
  , Xk = ["d"]
  , Qk = ["d"]
  , Jk = ["d"]
  , Wo = 10
  , Nl = 100
  , Qf = 100
  , ri = 100 / 3
  , Vi = 3
  , Wa = 2
  , Zk = Mn({
    __name: "Logo",
    setup(e, {expose: t}) {
        const n = Un("el")
          , r = Un("svgEl")
          , i = Un("textEl")
          , s = Un("maskEl")
          , o = Un("letterEl")
          , l = Un("charWrapperEls")
          , u = Un("charEls")
          , p = Gr([{
            x: 0,
            y: 0,
            radius: Vi
        }, {
            x: ri * 1,
            y: 0,
            radius: Vi
        }, {
            x: ri * 2,
            y: 0,
            radius: Vi
        }, {
            x: ri * 2,
            y: 0,
            radius: Vi
        }, {
            x: ri * 3,
            y: 0,
            radius: Vi
        }, {
            x: ri * 3,
            y: ri,
            radius: Vi
        }, {
            x: ri * 2,
            y: ri,
            radius: Vi
        }, {
            x: ri * 2,
            y: ri * 2,
            radius: Vi
        }, {
            x: ri * 2,
            y: ri * 3,
            radius: Vi
        }, {
            x: ri,
            y: ri * 3,
            radius: Vi
        }, {
            x: ri,
            y: ri,
            radius: Vi
        }, {
            x: 0,
            y: ri,
            radius: Vi
        }])
          , h = Gr([{
            x: Wo,
            y: 0,
            radius: Wa
        }, {
            x: 100,
            y: 0,
            radius: Wa
        }, {
            x: 100,
            y: 100 - Wo,
            radius: Wa
        }, {
            x: 100 - Wo,
            y: 100,
            radius: Wa
        }, {
            x: 0,
            y: 100,
            radius: Wa
        }, {
            x: 0,
            y: Wo,
            radius: Wa
        }])
          , g = zt( () => p.map(y => ({
            x: pl.map(y.x, 0, Nl, Wo, Nl - Wo),
            y: pl.map(y.y, 0, Qf, Wo, Nl - Wo),
            radius: y.radius
        })));
        fs( () => {}
        );
        const m = qr("")
          , w = qr("");
        return fs( () => {
            m.value = Hc(g.value)
        }
        ),
        fs( () => {
            w.value = Hc(h)
        }
        ),
        t({
            play: () => {
                const y = In.gsap.timeline();
                return y.set(n.value, {
                    autoAlpha: 1
                }, 0),
                y.set(r.value, {
                    x: () => (n.value.offsetWidth - r.value.clientWidth) * .5
                }),
                y.set(i.value, {
                    x: () => -(n.value.offsetWidth - i.value.offsetWidth) * .5
                }),
                y.fromTo(o.value, {
                    scale: 0,
                    transformOrigin: "center center"
                }, {
                    scale: 1,
                    ease: "custom.fastInOut",
                    duration: 1
                }, "<"),
                y.fromTo(p, {
                    radius: 0
                }, {
                    radius: Vi,
                    ease: "custom.fastInOut",
                    duration: 1.4
                }, "<0.1"),
                y.fromTo(p[2], {
                    y: 0
                }, {
                    y: ri - Vi,
                    ease: "custom.fastInOut",
                    duration: 1
                }, "<"),
                y.fromTo(p[3], {
                    x: ri * 2 + Vi
                }, {
                    x: ri * 2,
                    ease: "custom.fastInOut",
                    duration: 1
                }, "<"),
                y.to(p[6], {
                    x: ri + Vi,
                    ease: "custom.fastInOut",
                    duration: 1
                }, "<"),
                y.to([i.value, r.value], {
                    x: 0,
                    ease: "expo.inOut",
                    duration: 1.2
                }, "<0.8"),
                y.fromTo(s.value, {
                    scale: 0,
                    transformOrigin: "top right"
                }, {
                    scale: 1,
                    ease: "expo.inOut",
                    duration: 1.2
                }, "<"),
                y.fromTo(l.value, {
                    yPercent: 100
                }, {
                    yPercent: 0,
                    ease: "expo.out",
                    duration: 1,
                    stagger: {
                        each: .04,
                        from: "end"
                    }
                }, "<0.4"),
                y.fromTo(u.value, {
                    yPercent: -100
                }, {
                    yPercent: 0,
                    ease: "expo.out",
                    duration: 1,
                    stagger: {
                        each: .04,
                        from: "end"
                    }
                }, "<"),
                y
            }
        }),
        (y, R) => (It(),
        Cn("div", {
            ref_key: "el",
            ref: n,
            class: "animated-logo"
        }, [(It(),
        Cn("svg", {
            ref_key: "svgEl",
            ref: r,
            width: Nl,
            height: Qf,
            viewBox: `0 0 ${Nl} ${Qf}`,
            xmlns: "http://www.w3.org/2000/svg"
        }, [kt("defs", null, [kt("mask", Yk, [kt("path", {
            ref_key: "maskEl",
            ref: s,
            d: Re(w),
            fill: "white"
        }, null, 8, Kk)])]), kt("path", {
            mask: "url(#mask)",
            d: Re(w),
            fill: "var(--c-dark-green)"
        }, null, 8, Xk), kt("g", {
            ref_key: "letterEl",
            ref: o
        }, [kt("path", {
            d: Re(m),
            fill: "var(--c-dark-green)"
        }, null, 8, Qk), kt("path", {
            d: Re(m),
            fill: "#ededed",
            mask: "url(#mask)"
        }, null, 8, Jk)], 512)], 8, Gk)), kt("span", {
            ref_key: "textEl",
            ref: i,
            class: "text"
        }, [(It(),
        Cn(er, null, So("Terminal", (P, x) => kt("span", {
            key: x,
            ref_for: !0,
            ref_key: "charWrapperEls",
            ref: l,
            class: "char-wrapper"
        }, [kt("span", {
            ref_for: !0,
            ref_key: "charEls",
            ref: u,
            class: "char"
        }, Ji(P), 513)])), 64))], 512)], 512))
    }
})
  , eA = ua(Zk, [["__scopeId", "data-v-b5fe9da5"]])
  , tA = ["width", "height", "viewBox"]
  , nA = ["d", "stroke"]
  , rA = Mn({
    __name: "Background",
    props: {
        strokeColor: {
            default: void 0
        },
        shapeOpacity: {
            default: 1
        }
    },
    setup(e) {
        const t = e
          , n = Un("el")
          , r = Gr({
            width: 0,
            height: 0
        })
          , i = Iu()
          , s = zt( () => i.value ? [[{
            x: r.width * .4,
            y: 0,
            radius: 0
        }, {
            x: r.width * .4,
            y: r.height * .15,
            radius: 50
        }, {
            x: r.width * .25,
            y: r.height * .15,
            radius: 50
        }, {
            x: r.width * .1,
            y: r.height * .15,
            radius: 50
        }, {
            x: r.width * .1,
            y: r.height * .55,
            radius: 75
        }, {
            x: 0,
            y: r.height * .37,
            radius: 0
        }], [{
            x: r.width * .6,
            y: 0,
            radius: 0
        }, {
            x: r.width * .6,
            y: r.height * .23,
            radius: 50
        }, {
            x: r.width * .9,
            y: r.height * .23,
            radius: 50
        }, {
            x: r.width * .9,
            y: r.height * .45,
            radius: 50
        }, {
            x: r.width,
            y: r.height * .45,
            radius: 0
        }], [{
            x: r.width,
            y: r.height * .9,
            radius: 0
        }, {
            x: r.width * .95,
            y: r.height * .8,
            radius: 20
        }, {
            x: r.width * .7,
            y: r.height * .8,
            radius: 50
        }, {
            x: r.width * .7,
            y: r.height,
            radius: 0
        }], [{
            x: 0,
            y: r.height * .8,
            radius: 0
        }, {
            x: r.width * .25,
            y: r.height * .8,
            radius: 75
        }, {
            x: r.width * .15,
            y: r.height,
            radius: 0
        }]] : [[{
            x: 0,
            y: r.height * .05,
            radius: 0
        }, {
            x: r.width * .2,
            y: r.height * .05,
            radius: 20
        }, {
            x: r.width * .7,
            y: r.height * .3,
            radius: 60
        }, {
            x: r.width * .7,
            y: r.height * .05,
            radius: 30
        }, {
            x: r.width,
            y: r.height * .05,
            radius: 0
        }], [{
            x: r.width,
            y: r.height * .8,
            radius: 0
        }, {
            x: r.width * .7,
            y: r.height * .8,
            radius: 30
        }, {
            x: r.width * .7,
            y: r.height,
            radius: 0
        }], [{
            x: 0,
            y: r.height * .75,
            radius: 0
        }, {
            x: r.width * .3,
            y: r.height * .75,
            radius: 75
        }, {
            x: 0,
            y: r.height * .95,
            radius: 0
        }]])
          , o = zt( () => s.value.map(l => Hc(l)));
        return gf( () => {
            var l, u;
            r.width = ((l = n.value) == null ? void 0 : l.clientWidth) || 1,
            r.height = ((u = n.value) == null ? void 0 : u.clientHeight) || 1
        }
        , void 0, !0),
        (l, u) => (It(),
        Cn("svg", {
            ref_key: "el",
            ref: n,
            width: Re(r).width,
            height: Re(r).height,
            viewBox: `0 0 ${Re(r).width} ${Re(r).height}`,
            class: "svg"
        }, [(It(!0),
        Cn(er, null, So(Re(o), (p, h) => (It(),
        Cn("path", {
            key: h,
            ref_for: !0,
            ref: "fullPath",
            d: p,
            stroke: t.strokeColor || "#052424",
            fill: "none",
            "stroke-opacity": "0.15",
            "stroke-width": "1"
        }, null, 8, nA))), 128))], 8, tA))
    }
})
  , jg = ua(rA, [["__scopeId", "data-v-aaa1b985"]])
  , iA = {
    class: "app-loader"
}
  , sA = {
    ref: "loader",
    class: "loader"
}
  , oA = {
    ref: "topMask",
    class: "top-mask"
}
  , aA = {
    ref: "fullWrapperTop",
    class: "full-wrapper"
}
  , lA = {
    ref: "backgroundWrapperTop",
    class: "background-wrapper"
}
  , uA = {
    class: "logo-wrapper"
}
  , cA = {
    ref: "bottomMask",
    class: "bottom-mask"
}
  , fA = {
    ref: "fullWrapperBottom",
    class: "full-wrapper"
}
  , dA = {
    ref: "backgroundWrapperBottom",
    class: "background-wrapper"
}
  , hA = {
    class: "logo-wrapper"
}
  , pA = Mn({
    __name: "AppLoader",
    emits: ["loaded", "animate"],
    setup(e, {emit: t}) {
        const n = t
          , r = Un("overlayEl")
          , i = Un("topEl")
          , s = Un("bottomEl")
          , o = Un("fullWrapperTop")
          , l = Un("fullWrapperBottom")
          , u = Un("backgroundWrapperTop")
          , p = Un("backgroundWrapperBottom")
          , h = Un("svgLogoTop")
          , g = Un("svgLogoBottom")
          , m = Iu()
          , w = zt( () => m.value ? 40 : 20)
          , E = Gr([{
            direction: On.bottom,
            notchWidth: .95,
            offset: 0,
            position: .5,
            radius: 40,
            size: .75
        }])
          , y = Gr([{
            direction: On.top,
            notchWidth: .95,
            offset: 0,
            position: .5,
            radius: 40,
            size: .75
        }])
          , R = Ru();
        return xi( () => {
            var P;
            (P = R.value) == null || P.stop(),
            Pk( () => {
                const x = In.gsap.timeline({
                    delay: .2
                });
                x.add(h.value.play(), 0),
                x.add(g.value.play(), 0),
                x.fromTo([u.value, p.value], {
                    scale: 2,
                    opacity: 0,
                    rotate: 20
                }, {
                    scale: 1,
                    opacity: 1,
                    rotate: 0,
                    ease: "expo.out",
                    duration: 2
                }, "<"),
                x.fromTo(i.value, {
                    yPercent: 0
                }, {
                    yPercent: -100,
                    ease: "expo.inOut",
                    duration: 1.2
                }),
                x.fromTo(s.value, {
                    yPercent: 0
                }, {
                    yPercent: 100,
                    ease: "expo.inOut",
                    duration: 1.2
                }, "<"),
                x.fromTo(o.value, {
                    yPercent: 0
                }, {
                    yPercent: 50,
                    ease: "expo.inOut",
                    duration: 1.2
                }, "<"),
                x.to(r.value, {
                    opacity: 0,
                    ease: "power1.in",
                    duration: .8
                }, "<"),
                x.call( () => {
                    var v;
                    (v = R.value) == null || v.scrollTo(0, {
                        immediate: !0,
                        force: !0
                    })
                }
                , [], "<"),
                x.fromTo(l.value, {
                    yPercent: 0
                }, {
                    yPercent: -50,
                    ease: "expo.inOut",
                    duration: 1.2
                }, "<"),
                x.fromTo([E, y], {
                    offset: 0,
                    size: .5
                }, {
                    offset: w.value,
                    size: .9,
                    ease: "expo.out",
                    duration: .6
                }, "<"),
                x.to([E, y], {
                    offset: -w.value,
                    ease: "expo.out",
                    duration: .6
                }, "<0.6"),
                x.call( () => {
                    var v;
                    n("animate"),
                    (v = R.value) == null || v.start()
                }
                , [], "<"),
                x.call( () => {
                    n("loaded")
                }
                )
            }
            )
        }
        ),
        (P, x) => {
            const v = eA
              , k = gy;
            return It(),
            Cn("div", iA, [kt("div", {
                ref_key: "overlayEl",
                ref: r,
                class: "overlay"
            }, null, 512), kt("div", sA, [kt("div", {
                ref_key: "topEl",
                ref: i,
                class: "top"
            }, [tn(k, {
                "use-clip": "",
                notches: Re(E)
            }, {
                default: Tn( () => [kt("div", oA, [kt("div", aA, [kt("div", lA, [tn(Re(jg))], 512), kt("div", uA, [tn(v, {
                    ref_key: "svgLogoTop",
                    ref: h
                }, null, 512)])], 512)], 512)]),
                _: 1
            }, 8, ["notches"])], 512), kt("div", {
                ref_key: "bottomEl",
                ref: s,
                class: "bottom"
            }, [tn(k, {
                "use-clip": "",
                notches: Re(y)
            }, {
                default: Tn( () => [kt("div", cA, [kt("div", fA, [kt("div", dA, [tn(Re(jg))], 512), kt("div", hA, [tn(v, {
                    ref_key: "svgLogoBottom",
                    ref: g
                }, null, 512)])], 512)], 512)]),
                _: 1
            }, 8, ["notches"])], 512)], 512)])
        }
    }
})
  , my = ua(pA, [["__scopeId", "data-v-068da249"]])
  , gA = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: my
}, Symbol.toStringTag, {
    value: "Module"
}));
function yy(e) {
    const t = Symbol();
    return [i => {
        const s = e(i)
          , o = Object.assign(s, i);
        return ns(t, o),
        o
    }
    , i => pr(t, i), t]
}
const [_A,VA] = yy( () => {
    const e = Ut(1)
      , t = Ut(1)
      , n = zt( () => t.value / e.value)
      , r = Ut(0)
      , i = Ut(0)
      , s = Ut(void 0);
    return Fu( () => {
        const o = Iu();
        tr(o, l => s.value = l, {
            immediate: !0
        }),
        Ru(l => {
            r.value = l.animatedScroll,
            i.value = l.direction
        }
        )
    }
    ),
    gf(o => {
        t.value = document.documentElement.clientWidth,
        e.value = o.height,
        document.documentElement.style.setProperty("--svw", t.value / 100 + "px")
    }
    ),
    {
        vh: Ca(e),
        vw: Ca(t),
        isLg: Ca(s),
        aspectRatio: Ca(n),
        lenisScroll: Ca(r),
        lenisDirection: Ca(i)
    }
}
)
  , [mA,jA] = yy( () => {
    const e = Ut(!1)
      , t = Ts({
        x: 0,
        y: 0
    })
      , n = Ts({
        x: 0,
        y: 0
    });
    _f( ({dt: s}) => {
        n.x = pl.Damp(n.x, t.x, 6, s),
        n.y = pl.Damp(n.y, t.y, 6, s)
    }
    );
    const r = s => {
        t.x = s.clientX,
        t.y = s.clientY,
        e.value || (n.x = t.x,
        n.y = t.y,
        e.value = !0)
    }
      , i = s => {
        if (s.touches.length > 0) {
            const o = s.touches[0];
            o && (t.x = o.clientX,
            t.y = o.clientY,
            e.value || (n.x = t.x,
            n.y = t.y,
            e.value = !0))
        }
    }
    ;
    return xi( () => {
        document.addEventListener("mousemove", r),
        document.addEventListener("dragover", r),
        document.addEventListener("touchstart", i),
        document.addEventListener("touchmove", i)
    }
    ),
    Io( () => {
        document.removeEventListener("dragover", r),
        document.removeEventListener("mousemove", r),
        document.removeEventListener("touchstart", i),
        document.removeEventListener("touchmove", i)
    }
    ),
    {
        mouse: t,
        mouseDamp: n,
        hasMoved: e
    }
}
);
async function yA() {
    const e = yT()
      , {public: {storyblokVersion: t}} = qs()
      , {data: n} = await e.get("cdn/stories/config", {
        version: t,
        resolve_links: "url"
    });
    return n
}
const vA = DD("loader", () => {
    const t = !qs().public.IS_PRODUCTION
      , n = Ut(t)
      , r = Ut(t);
    return {
        loaded: n,
        animate: r
    }
}
)
  , bA = {
    id: "app"
}
  , wA = Mn({
    __name: "app",
    async setup(e) {
        let t, n;
        const r = Pu();
        _A({}),
        mA({});
        const i = zt( () => r.path.startsWith("/landing/"));
        [t,n] = F_( () => GC("config:storyblok", () => yA())),
        await t,
        n();
        const s = vA()
          , o = Un("lenisRef")
          , l = Un("appTransitionComp");
        fs( () => {
            _f( ({et: g}) => {
                var m, w;
                (w = (m = o.value) == null ? void 0 : m.lenis) == null || w.raf(g * 1e3)
            }
            , 9999)
        }
        ),
        xi( () => {
            Ci( () => {
                ka.refresh()
            }
            ),
            Ru( () => {
                ka.update()
            }
            )
        }
        );
        const u = () => {
            s.loaded = !0
        }
          , p = () => {
            s.animate = !0
        }
          , h = {
            mode: "out-in",
            onBeforeEnter: g => {
                var m;
                (m = o.value) == null || m.lenis.scrollTo(0, {
                    immediate: !0,
                    force: !0
                })
            }
            ,
            onLeave: (g, m) => {
                const w = In.gsap.timeline();
                w.add(l.value.show()),
                w.call(m)
            }
            ,
            onEnter: (g, m) => {
                const w = In.gsap.timeline();
                w.add(l.value.hide()),
                w.call(m)
            }
        };
        return v0({
            link: [{
                rel: "preload",
                href: "/static/fonts/SuisseIntl-Regular.woff2",
                crossorigin: "",
                as: "font",
                type: "font/woff2"
            }, {
                rel: "preload",
                href: "/static/fonts/SuisseIntl-Medium.woff2",
                crossorigin: "",
                as: "font",
                type: "font/woff2"
            }, {
                rel: "apple-touch-icon",
                sizes: "180x180",
                href: "/static/apple-touch-icon.png"
            }, {
                rel: "icon",
                type: "image/png",
                sizes: "96x96",
                href: "/static/favicon-96x96.png"
            }, {
                rel: "icon",
                type: "image/png",
                sizes: "192x192",
                href: "/static/favicon-192x192.png"
            }, {
                rel: "icon",
                type: "image/png",
                sizes: "512x512",
                href: "/static/favicon-512x512.png"
            }, {
                rel: "icon",
                type: "image/svg+xml",
                href: "/static/favicon.svg"
            }, {
                rel: "shortcut icon",
                href: "/static/favicon.ico"
            }, {
                rel: "manifest",
                href: "/static/site.webmanifest"
            }]
        }),
        (g, m) => {
            const w = hy
              , E = gk
              , y = Dk
              , R = _y
              , P = my;
            return It(),
            Cn("div", null, [tn(Re(q0), {
                ref_key: "lenisRef",
                ref: o,
                root: "",
                "auto-raf": !1
            }, {
                default: Tn( () => [kt("div", bA, [Re(i) ? ii("", !0) : (It(),
                Wn(w, {
                    key: 0
                })), tn(y, null, {
                    default: Tn( () => [tn(E, {
                        transition: h
                    })]),
                    _: 1
                })])]),
                _: 1
            }, 512), tn(R, {
                ref_key: "appTransitionComp",
                ref: l
            }, null, 512), Re(s).loaded ? ii("", !0) : (It(),
            Wn(P, {
                key: 0,
                onLoaded: u,
                onAnimate: p
            }))])
        }
    }
})
  , DA = {
    __name: "error",
    setup(e) {
        const t = TC();
        return xi( () => {
            t.push("/")
        }
        ),
        (n, r) => (It(),
        Cn("div"))
    }
}
  , EA = {
    key: 0
}
  , zg = {
    __name: "nuxt-root",
    setup(e) {
        const t = () => null
          , n = Tr()
          , r = n.deferHydration();
        if (n.isHydrating) {
            const u = n.hooks.hookOnce("app:error", r);
            rs().beforeEach(u)
        }
        const i = !1;
        ns(Tu, Pu()),
        n.hooks.callHookWith(u => u.map(p => p()), "vue:setup");
        const s = uf()
          , o = !1;
        lh( (u, p, h) => {
            if (n.hooks.callHook("vue:error", u, p, h).catch(g => console.error("[nuxt] Error in `vue:error` hook", g)),
            o0(u) && (u.fatal || u.unhandled))
                return n.runWithContext( () => xa(u)),
                !1
        }
        );
        const l = !1;
        return (u, p) => (It(),
        Wn(sf, {
            onResolve: Re(r)
        }, {
            default: Tn( () => [Re(o) ? (It(),
            Cn("div", EA)) : Re(s) ? (It(),
            Wn(Re(DA), {
                key: 1,
                error: Re(s)
            }, null, 8, ["error"])) : Re(l) ? (It(),
            Wn(Re(t), {
                key: 2,
                context: Re(l)
            }, null, 8, ["context"])) : Re(i) ? (It(),
            Wn(nl(Re(i)), {
                key: 3
            })) : (It(),
            Wn(Re(wA), {
                key: 4
            }))]),
            _: 1
        }, 8, ["onResolve"]))
    }
};
let Ug;
{
    let e;
    Ug = async function() {
        var o, l;
        if (e)
            return e;
        const r = !!(((o = window.__NUXT__) == null ? void 0 : o.serverRendered) ?? ((l = document.getElementById("__NUXT_DATA__")) == null ? void 0 : l.dataset.ssr) === "true") ? vh(zg) : Rc(zg)
          , i = Jw({
            vueApp: r
        });
        async function s(u) {
            var p;
            await i.callHook("app:error", u),
            (p = i.payload).error || (p.error = ra(u))
        }
        r.config.errorHandler = s,
        i.hook("app:suspense:resolve", () => {
            r.config.errorHandler === s && (r.config.errorHandler = void 0)
        }
        );
        try {
            await tD(i, C2)
        } catch (u) {
            s(u)
        }
        try {
            await i.hooks.callHook("app:created", r),
            await i.hooks.callHook("app:beforeMount", r),
            r.mount(Kw),
            await i.hooks.callHook("app:mounted", r),
            await Ci()
        } catch (u) {
            s(u)
        }
        return r
    }
    ,
    e = Ug().catch(t => {
        throw console.error("Error while mounting app:", t),
        t
    }
    )
}
export {oo as $, ks as A, xv as B, zv as C, PA as D, Un as E, er as F, Gr as G, gf as H, BA as I, yT as J, Pk as K, Fu as L, gy as M, On as N, To as O, V0 as P, pl as Q, Qr as R, ka as S, ml as T, nl as U, ys as V, Pg as W, In as X, t1 as Y, Tr as Z, ua as _, kt as a, Ac as a$, My as a0, Iu as a1, tr as a2, HA as a3, Ru as a4, _f as a5, Zl as a6, Hc as a7, ar as a8, _s as a9, bm as aA, sy as aB, RA as aC, Fh as aD, ol as aE, No as aF, J2 as aG, tP as aH, FA as aI, Lb as aJ, dP as aK, nP as aL, ay as aM, um as aN, Mo as aO, vi as aP, La as aQ, G2 as aR, D_ as aS, v1 as aT, n1 as aU, AA as aV, rs as aW, Sm as aX, $A as aY, Cm as aZ, Fm as a_, Ss as aa, Ci as ab, lf as ac, xA as ad, ao as ae, af, Gm as ag, fw as ah, vA as ai, jA as aj, VA as ak, Ou as al, oh as am, r1 as an, w1 as ao, Lo as ap, ds as aq, qr as ar, Qc as as, sr as at, Ca as au, Or as av, tf as aw, fs as ax, Nn as ay, xk as az, tn as b, Xt as b0, Vt as b1, gh as b2, yy as b3, Tk as b4, X0 as b5, MA as b6, NA as b7, ny as b8, Ma as b9, LA as ba, q2 as bb, IA as bc, sl as bd, OA as be, pP as bf, Lu as bg, Z2 as bh, Mg as bi, oy as bj, Z0 as bk, Rm as bl, Io as bm, pr as bn, J0 as bo, TA as bp, Cn as c, Wn as d, ii as e, Mn as f, Ut as g, zt as h, Tn as i, GC as j, So as k, qs as l, Pu as m, ra as n, It as o, fD as p, ns as q, wc as r, QC as s, Ji as t, Re as u, xi as v, F_ as w, YC as x, SA as y, bl as z};

/**
 * END of DtnJ4yNw.js
 */


/**
 * START of D0GSe9oA.js
 */
import {_ as V} from "./CKlxW_no.js";
import {f as D, g as w, a2 as B, c as y, o as h, F as O, k as M, d as A, u as s, _ as F, G as H, N as z, E as T, b4 as U, a5 as j, Q as $, b as v, M as W, i as G, a as l, T as K, t as L, O as Q, K as X, X as Y, b3 as Z, w as q, B as J, C as ee, e as E, A as te} from "./DtnJ4yNw.js";
import ae from "./BFfbkEzJ.js";
import oe from "./D_MGx2mw.js";
import {a as re, c as ne, d as se} from "./CrWOzmEA.js";
import {u as le} from "./CsgZCG33.js";
import {C as I} from "./BeUK2rGw.js";
import {c as ie} from "./Bj9BJCNz.js";
const ce = {
    class: "radio-button__wrapper"
}
  , de = D({
    __name: "RadioButtonWrapper",
    props: {
        props: {}
    },
    emits: ["change"],
    setup(i, {emit: t}) {
        const o = i
          , e = w(0)
          , r = w(o.props.map( (d, _) => _ === e.value));
        function m(d) {
            if (d === e.value)
                r.value[d] = !0;
            else {
                const _ = e.value;
                r.value[_] = !1,
                e.value = d
            }
        }
        B(e, d => {
            u("change", d)
        }
        );
        const u = t;
        return (d, _) => {
            const S = V;
            return h(),
            y("form", ce, [(h(!0),
            y(O, null, M(o.props, (g, b) => (h(),
            A(S, {
                key: b,
                checked: s(r)[b],
                "onUpdate:checked": n => s(r)[b] = n,
                type: "radio",
                label: g.label,
                name: g.name,
                onChange: n => m(b)
            }, null, 8, ["checked", "onUpdate:checked", "label", "name", "onChange"]))), 128))])
        }
    }
})
  , ue = F(de, [["__scopeId", "data-v-7d15cf4b"]])
  , _e = {
    class: "card-content__wrapper"
}
  , pe = {
    class: "top__wrapper"
}
  , me = {
    class: "type__wrapper"
}
  , be = {
    class: "title__wrapper"
}
  , ge = {
    class: "bottom__wrapper"
}
  , fe = {
    class: "date"
}
  , ve = 20
  , P = .3
  , he = D({
    __name: "SliderCard",
    props: {
        data: {}
    },
    setup(i) {
        const t = i
          , o = H([{
            direction: z.right,
            offset: 0,
            position: .6,
            size: P
        }])
          , e = T("wrapperRef")
          , r = T("media")
          , m = re(e)
          , {elementY: u, elementHeight: d} = ne(e)
          , _ = se(e)
          , S = U();
        let g = o[0].position;
        B([u], ([n]) => {
            m.value && (g = $.Lerp(P / 2 + .12, 1 - P / 2 - .12, $.Clamp(n / d.value, 0, 1)))
        }
        ),
        j( ({dt: n}) => {
            m.value && (o[0].position = $.Round($.Damp(o[0].position, g, 6, n), 4))
        }
        ),
        B(_, n => {
            S.value && X( () => {
                Y.gsap.to(o[0], {
                    offset: n ? ve : 0,
                    duration: .5,
                    ease: "power2.out"
                })
            }
            )
        }
        );
        function b(n) {
            const C = new Date(n)
              , x = {
                month: "short",
                day: "2-digit"
            };
            return new Intl.DateTimeFormat("en-US",x).format(C)
        }
        return (n, C) => {
            const x = ae
              , N = oe
              , c = W;
            return h(),
            y("div", {
                ref_key: "wrapperRef",
                ref: e,
                class: "slider-card__container"
            }, [v(c, {
                notches: s(o)
            }, {
                default: G( () => {
                    var a, p;
                    return [l("div", {
                        class: "slider-card__wrapper",
                        style: K({
                            color: ((a = n.data.background_color) == null ? void 0 : a.value) === "#052424" ? "var(--c-white)" : "var(--c-dark-green)",
                            backgroundColor: ((p = n.data.background_color) == null ? void 0 : p.value) ?? null
                        })
                    }, [l("div", {
                        ref_key: "media",
                        ref: r,
                        class: "rollover__wrapper"
                    }, [v(x, {
                        asset: n.data.background_image,
                        class: "image",
                        lazy: !1,
                        fit: "cover"
                    }, null, 8, ["asset"])], 512), l("div", _e, [l("div", pe, [l("div", me, L(n.data.category), 1), l("div", be, L(t.data.title), 1)]), l("div", ge, [l("div", fe, L(b(n.data.date)), 1), v(N, {
                        "aria-label": "More",
                        "base-color": "white",
                        class: "link-button",
                        to: n.data.link.cached_url
                    }, {
                        default: G( () => C[0] || (C[0] = [Q(" More ")])),
                        _: 1
                    }, 8, ["to"])])])], 4)]
                }
                ),
                _: 1
            }, 8, ["notches"])], 512)
        }
    }
})
  , ke = F(he, [["__scopeId", "data-v-b69b6221"]])
  , [ye,we] = Z(i => {
    const t = i.length
      , o = w(0)
      , e = w(0);
    function r() {
        o.value = $.Clamp(o.value + 1, 0, t - 1)
    }
    function m() {
        o.value = $.Clamp(o.value - 1, 0, t - 1)
    }
    const u = w(!0)
      , d = w(!0);
    return {
        index: o,
        progress: e,
        nextSlider: r,
        previousSlider: m,
        canScrollNext: u,
        canScrollPrev: d
    }
}
)
  , Se = {
    role: "region",
    "aria-label": "Featured Articles",
    "aria-roledescription": "carousel"
}
  , Ce = ["aria-label"]
  , xe = D({
    __name: "Slider",
    props: {
        cards: {}
    },
    setup(i) {
        const t = i
          , o = T("scrollHolder")
          , {index: e, canScrollNext: r, canScrollPrev: m} = we();
        return le({
            element: o,
            index: e,
            canScrollNext: r,
            canScrollPrev: m
        }, {
            mouseDrag: !0
        }),
        (u, d) => {
            const _ = ke;
            return h(),
            y("div", Se, [l("ul", {
                ref_key: "scrollHolder",
                ref: o,
                class: "slider__wrapper",
                tabindex: "0"
            }, [(h(!0),
            y(O, null, M(t.cards, (S, g) => (h(),
            y("li", {
                key: g,
                class: "slide",
                "aria-label": `Slide ${g + 1} of ${t.cards.length}`
            }, [v(_, {
                data: S
            }, null, 8, ["data"])], 8, Ce))), 128))], 512)])
        }
    }
})
  , $e = F(xe, [["__scopeId", "data-v-636eaed8"]]);
function Xe(i, t={}) {
    var o;
    return {
        _uid: `section-introduction-${i.toLowerCase().replace(/\s+/g, "-")}`,
        component: "SectionIntroduction",
        css: t.css || "",
        label: t.label || "",
        title: {
            type: "doc",
            content: [{
                type: "heading",
                attrs: {
                    level: t.titleLevel || 2
                },
                content: [{
                    text: i,
                    type: "text",
                    marks: [{
                        type: "textStyle",
                        attrs: {
                            color: t.titleColor || ""
                        }
                    }]
                }]
            }]
        },
        copy: t.copy ? {
            type: "doc",
            content: [{
                type: "paragraph",
                content: [{
                    text: t.copy,
                    type: "text",
                    marks: [{
                        type: "textStyle",
                        attrs: {
                            color: t.copyColor || ""
                        }
                    }]
                }]
            }]
        } : void 0,
        buttons: ((o = t.buttons) == null ? void 0 : o.map( (e, r) => ({
            _uid: `button-${r}`,
            component: "Button",
            label: e.label,
            link: {
                url: e.link.url || "",
                cached_url: e.link.cached_url || "",
                linktype: e.link.linktype || "url",
                fieldtype: "multilink",
                id: e.link.id || ""
            }
        }))) || [],
        multipleColumns: t.multipleColumns || !1,
        buttons_underlined: t.buttons_underlined || !1,
        background_type: t.background_type || "none",
        background_image: t.background_image,
        background_theme: t.background_theme || "white",
        isFollowingLogosGrid: t.isFollowingLogosGrid || !1,
        isFullscreen: t.isFullscreen || !1,
        subscribe_form: t.subscribe_form || !1,
        _editable: ""
    }
}
function Ne(i, t="News", o=!0) {
    return i != null && i.length ? {
        title: t,
        hide_sorting: o,
        _uid: `${t.toLowerCase().replace(/\\s+/g, "-")}-section`,
        items: i.map(e => {
            const r = e.content || {}
              , m = (e == null ? void 0 : e.first_published_at) || (e == null ? void 0 : e.published_at) || (e == null ? void 0 : e.created_at) || "";
            return {
                _uid: e.uuid,
                date: m,
                link: {
                    id: e.uuid,
                    url: "",
                    linktype: "story",
                    fieldtype: "multilink",
                    cached_url: e.full_slug ? "/" + e.full_slug : ""
                },
                title: r.title || "",
                category: r.category || "",
                component: "NewsSectionItem",
                background_color: r.background_color,
                background_image: r.cover_image ? {
                    id: String(r.cover_image.id || ""),
                    filename: r.cover_image.filename || ""
                } : {
                    id: "",
                    filename: ""
                },
                _editable: r._editable || ""
            }
        }
        ),
        component: "NewsSection",
        _editable: ""
    } : null
}
const Ie = {
    class: "latest-news"
}
  , Le = {
    class: "grid__wrapper"
}
  , Be = {
    class: "wrapper"
}
  , De = {
    key: 0,
    class: "slider-button__wrapper"
}
  , Fe = ["disabled"]
  , Pe = ["disabled"]
  , Te = {
    key: 0,
    class: "order__wrapper"
}
  , Ge = {
    class: "order-group"
}
  , Ee = {
    class: "slider-button__wrapper"
}
  , Oe = ["disabled"]
  , Me = ["disabled"]
  , Re = D({
    __name: "NewsSection",
    props: {
        blok: {}
    },
    async setup(i) {
        var N;
        let t, o;
        const e = i;
        let r = [...e.blok.items || []];
        if (e.blok.latest_news ?? !1) {
            const {data: c} = ([t,o] = q( () => ie()),
            t = await t,
            o(),
            t);
            if ((N = c.value) != null && N.length) {
                const a = Ne(c.value);
                if (a != null && a.items) {
                    const p = a.items.map(f => ({
                        title: f.title,
                        category: f.category,
                        date: f.date,
                        background_color: f.background_color,
                        background_image: {
                            id: f.background_image.id,
                            filename: f.background_image.filename
                        },
                        link: {
                            url: f.link.url,
                            cached_url: f.link.cached_url
                        }
                    }));
                    r = [...r, ...p]
                }
            }
        }
        const u = w(r)
          , d = ["Date", "Type of news"]
          , _ = w(d[0]);
        function S(c) {
            switch (c) {
            case "Date":
                u.value.sort( (a, p) => p.date.localeCompare(a.date));
                break;
            case "Type of news":
                u.value.sort( (a, p) => p.category.localeCompare(a.category));
                break;
            default:
                u.value.sort( (a, p) => p.date.localeCompare(a.date));
                break
            }
        }
        B(_, c => {
            S(c)
        }
        , {
            immediate: !0
        });
        const g = d.map(c => ({
            label: c,
            active: _.value == c,
            name: "Order",
            type: "radio"
        }))
          , {nextSlider: b, previousSlider: n, canScrollNext: C, canScrollPrev: x} = ye({
            length: u.value.length
        });
        return (c, a) => {
            const p = ue
              , f = $e
              , R = ee("editable");
            return J((h(),
            y("section", Ie, [l("div", Le, [l("div", Be, [l("div", {
                class: te(["heading__wrapper", {
                    "hide-sorting": c.blok.hide_sorting
                }])
            }, [l("h2", null, L(c.blok.title || "Latest News"), 1), c.blok.hide_sorting ? (h(),
            y("div", De, [l("button", {
                class: "slider-button",
                "aria-label": "Go to previous slide",
                disabled: !s(x),
                onClick: a[0] || (a[0] = (...k) => s(n) && s(n)(...k))
            }, [v(s(I))], 8, Fe), l("button", {
                class: "slider-button right",
                "aria-label": "Go to next slide",
                disabled: !s(C),
                onClick: a[1] || (a[1] = (...k) => s(b) && s(b)(...k))
            }, [v(s(I), {
                class: "right"
            })], 8, Pe)])) : E("", !0)], 2), c.blok.hide_sorting ? E("", !0) : (h(),
            y("div", Te, [l("fieldset", Ge, [a[5] || (a[5] = l("legend", null, "Order", -1)), v(p, {
                props: s(g),
                onChange: a[2] || (a[2] = k => _.value = d[k])
            }, null, 8, ["props"])]), l("div", Ee, [l("button", {
                class: "slider-button",
                "aria-label": "Go to previous slide",
                disabled: !s(x),
                onClick: a[3] || (a[3] = (...k) => s(n) && s(n)(...k))
            }, [v(s(I))], 8, Oe), l("button", {
                class: "slider-button right",
                "aria-label": "Go to next slide",
                disabled: !s(C),
                onClick: a[4] || (a[4] = (...k) => s(b) && s(b)(...k))
            }, [v(s(I), {
                class: "right"
            })], 8, Me)])]))])]), v(f, {
                cards: s(u)
            }, null, 8, ["cards"])])), [[R, c.blok]])
        }
    }
})
  , Ve = F(Re, [["__scopeId", "data-v-b3e5718b"]])
  , Ye = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Ve
}, Symbol.toStringTag, {
    value: "Module"
}));
export {Ye as N, Ve as _, Xe as a, Ne as c};


/**
 * END of D0GSe9oA.js
 */

/**
 * START of BeUK2rGw.js
 */
import {c as o, o as r, a as t} from "./DtnJ4yNw.js";
const n = {
    xmlns: "http://www.w3.org/2000/svg",
    width: "12",
    height: "13",
    fill: "none",
    viewBox: "0 0 12 13"
};
function s(i, e) {
    return r(),
    o("svg", n, e[0] || (e[0] = [t("path", {
        stroke: "currentColor",
        "stroke-linecap": "square",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        d: "m10.997 2.004-9.849-.142v9.85"
    }, null, -1)]))
}
const a = {
    render: s
};
export {a as C};

/**
 * END of BeUK2rGw.js
 */


/**
 * START of BFfbkEzJ.js
 */
import {_ as N} from "./CLvGjMNs.js";
import {a as h, g as u} from "./CrWOzmEA.js";
import {f as R, E as x, h as b, a2 as v, c as d, e as y, u as n, A as V, a as k, F as $, d as z, o as r, _ as T} from "./DtnJ4yNw.js";
import "./YYe3JQAg.js";
function w(l=null, a=null) {
    if (l || (l = a),
    a || (a = l),
    !l || !a)
        return "";
    const s = {
        xs: 390,
        sm: 480,
        md: 768,
        lg: 1024,
        xxl: 1680,
        "3xl": 1920,
        "4xl": 2560
    }
      , o = {
        xs: Math.round(l * (s.sm / s.xs)),
        sm: Math.round(l * (s.md / s.xs)),
        md: Math.round(l * (s.lg / s.xs)),
        lg: a,
        xl: Math.round(a * (s.xxl / s["3xl"])),
        xxl: Math.round(a * (s["3xl"] / s["3xl"])),
        "3xl": Math.round(a * (s["4xl"] / s["3xl"]))
    };
    return `xs:${o.xs}px sm:${o.sm}px md:${o.md}px lg:${o.lg}px xl:${o.xl}px xxl:${o.xxl}px 3xl:${o["3xl"]}px`
}
const A = ["src"]
  , D = {
    key: 0,
    class: "media-wrapper mb"
}
  , F = ["src"]
  , I = R({
    __name: "Media",
    props: {
        asset: {},
        assetMobile: {
            default: void 0
        }
    },
    setup(l, {expose: a}) {
        const s = x("element")
          , o = l
          , p = x("desktopVideo")
          , m = x("mobileVideo")
          , B = h(p)
          , E = h(m)
          , g = ["mp4", "webm", "ogg"]
          , f = b( () => {
            const e = (o.asset.filename || "").split(".").pop() || "";
            return g.includes(e)
        }
        )
          , _ = b( () => {
            var t;
            if (!((t = o.assetMobile) != null && t.filename))
                return !1;
            const e = o.assetMobile.filename.split(".").pop() || "";
            return g.includes(e)
        }
        )
          , M = b( () => {
            var e;
            return !!((e = o.assetMobile) != null && e.id)
        }
        );
        v(B, e => {
            var t, i;
            e ? (t = u(p)) == null || t.play().catch(c => {
                console.error(c)
            }
            ) : (i = u(p)) == null || i.pause()
        }
        ),
        v(E, e => {
            var t, i;
            e ? (t = u(m)) == null || t.play().catch(c => {
                console.error(c)
            }
            ) : (i = u(m)) == null || i.pause()
        }
        );
        function C() {
            _.value && (m.value.currentTime = 0),
            f.value && (p.value.currentTime = 0)
        }
        return a({
            element: s,
            startoverVideo: C
        }),
        (e, t) => {
            var c;
            const i = N;
            return r(),
            d("div", {
                ref_key: "element",
                ref: s,
                class: "media-el"
            }, [n(f) ? (r(),
            d("div", {
                key: 0,
                class: V(["media-wrapper lg", {
                    "has-mb-asset": n(M)
                }])
            }, [k("video", {
                ref: "desktopVideo",
                class: "video",
                src: e.asset.filename,
                preload: "auto",
                muted: "",
                loop: "",
                playsinline: ""
            }, null, 8, A)], 2)) : (r(),
            d($, {
                key: 1
            }, [n(f) ? y("", !0) : (r(),
            z(i, {
                key: 0,
                class: V(["media-wrapper lg", {
                    "has-mb-asset": n(M)
                }]),
                src: e.asset.filename,
                alt: e.asset.alt || "",
                decoding: "async",
                provider: "storyblok",
                sizes: n(w)(375, 1920),
                "img-attrs": {
                    draggable: !1
                }
            }, null, 8, ["src", "alt", "class", "sizes"]))], 64)), (c = e.assetMobile) != null && c.id ? (r(),
            d($, {
                key: 2
            }, [n(_) ? (r(),
            d("div", D, [k("video", {
                ref: "mobileVideo",
                class: "video",
                src: e.assetMobile.filename,
                preload: "auto",
                muted: "",
                loop: "",
                playsinline: ""
            }, null, 8, F)])) : (r(),
            z(i, {
                key: 1,
                class: "media-wrapper mb",
                src: e.assetMobile.filename,
                alt: e.assetMobile.alt || "",
                decoding: "async",
                provider: "storyblok",
                sizes: n(w)(375, 375),
                "img-attrs": {
                    draggable: !1
                }
            }, null, 8, ["src", "alt", "sizes"]))], 64)) : y("", !0)], 512)
        }
    }
})
  , G = T(I, [["__scopeId", "data-v-4abaf53f"]]);
export {G as default};


/**
 * END of BFfbkEzJ.js
 */


/**
 * START of Bj9BJCNz.js
 */
import {l as c, J as i, j as l} from "./DtnJ4yNw.js";
async function w() {
    const {public: {storyblokVersion: t}} = c()
      , s = i();
    return await l("latest-blog-stories", async () => (await s.get("cdn/stories", {
        version: t,
        starts_with: "blog/",
        content_type: "Post",
        per_page: 10,
        sort_by: "first_published_at:desc"
    })).data.stories)
}
async function m(t) {
    const {public: {storyblokVersion: s}} = c()
      , e = i();
    return await l(`related:${t.value.uuid}`, async () => {
        var g;
        const o = Array.isArray((g = t.value) == null ? void 0 : g.tag_list) ? t.value.tag_list : [];
        if (!o.length)
            return [];
        const n = o.map(r => e.get("cdn/stories", {
            version: s,
            starts_with: "blog/",
            content_type: "Post",
            per_page: 20,
            with_tag: r,
            sort_by: "first_published_at:desc"
        }));
        return (await Promise.all(n)).flatMap(r => r.data.stories).filter( (r, d, p) => d === p.findIndex(b => b.uuid === r.uuid)).filter(r => r.uuid !== t.value.uuid)
    }
    )
}
async function v(t) {
    const {public: {storyblokVersion: s}} = c()
      , e = i();
    return await l(`featured-blog-story:${t.join(",")}`, async () => {
        if (!(t != null && t.length))
            return [];
        const {data: o} = await e.get("cdn/stories", {
            version: s,
            by_uuids: t.join(",")
        });
        return o.stories
    }
    )
}
async function k() {
    const {public: {storyblokVersion: t}} = c()
      , s = i();
    return await l("all-tags", async () => (await s.get("cdn/tags", {
        version: t
    })).data.tags)
}
async function A() {
    const {public: {storyblokVersion: t}} = c();
    return await l("all-categories", async () => {
        const s = await y({
            version: t,
            datasource: "category"
        })
          , e = await _({
            version: t,
            starts_with: "blog/",
            content_type: "Post",
            excluding_fields: ["body", "seo_image", "cover_image", "excerpt", "link", "seo_description", "seo_title", "subtitle", "background_color", "author", "component", "tag_list", "title"].join(",")
        })
          , o = new Set(e.map(a => {
            var u;
            return (u = a.content) == null ? void 0 : u.category
        }
        ).filter(Boolean));
        return s.filter(a => o.has(a.value)).map(a => ({
            label: a.name,
            value: a.value
        }))
    }
    )
}
async function y(t) {
    const s = i()
      , e = [];
    let o = 1;
    for (; ; ) {
        const n = await s.get("cdn/datasource_entries", {
            ...t,
            page: o
        });
        e.push(...n.data.datasource_entries || []);
        const a = Number(n.headers.total ?? n.headers.total ?? 0);
        if (!a || e.length >= a)
            break;
        o += 1
    }
    return e
}
async function _(t) {
    const s = i()
      , e = [];
    let o = 1;
    for (; ; ) {
        const n = await s.get("cdn/stories", {
            ...t,
            page: o
        });
        e.push(...n.data.stories || []);
        const a = Number(n.headers.total ?? n.headers.total ?? 0);
        if (!a || e.length >= a)
            break;
        o += 1
    }
    return e
}
export {k as a, A as b, w as c, m as d, v as u};


/**
 * END of Bj9BJCNz.js
 */


/**
 * START of CrWOzmEA.js
 */

import {a2 as H, ap as ie, aq as ae, ar as w, as as ue, v as q, ab as ee, u as te, at as ce, au as fe, R as E, av as N, h as _, aw as de, G as B, ax as ve, ay as pe, g as me} from "./DtnJ4yNw.js";
function he(e, t) {
    let o, n, f;
    const s = w(!0)
      , u = () => {
        s.value = !0,
        f()
    }
    ;
    H(e, u, {
        flush: "sync"
    });
    const r = typeof t == "function" ? t : t.get
      , i = typeof t == "function" ? void 0 : t.set
      , a = ue( (c, d) => (n = c,
    f = d,
    {
        get() {
            return s.value && (o = r(o),
            s.value = !1),
            n(),
            o
        },
        set(p) {
            i == null || i(p)
        }
    }));
    return Object.isExtensible(a) && (a.trigger = u),
    a
}
function D(e) {
    return ie() ? (ae(e),
    !0) : !1
}
function Ye(e, t) {
    return te(e)
}
const V = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const ne = e => e != null
  , ge = Object.prototype.toString
  , we = e => ge.call(e) === "[object Object]"
  , x = () => {}
  , ye = be();
function be() {
    var e, t;
    return V && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent))
}
function oe(e, t) {
    function o(...n) {
        return new Promise( (f, s) => {
            Promise.resolve(e( () => t.apply(this, n), {
                fn: t,
                thisArg: this,
                args: n
            })).then(f).catch(s)
        }
        )
    }
    return o
}
function Oe(e, t={}) {
    let o, n, f = x;
    const s = i => {
        clearTimeout(i),
        f(),
        f = x
    }
    ;
    let u;
    return i => {
        const a = E(e)
          , c = E(t.maxWait);
        return o && s(o),
        a <= 0 || c !== void 0 && c <= 0 ? (n && (s(n),
        n = null),
        Promise.resolve(i())) : new Promise( (d, p) => {
            f = t.rejectOnCancel ? p : d,
            u = i,
            c && !n && (n = setTimeout( () => {
                o && s(o),
                n = null,
                d(u())
            }
            , c)),
            o = setTimeout( () => {
                n && s(n),
                n = null,
                d(i())
            }
            , a)
        }
        )
    }
}
function Ee(...e) {
    let t = 0, o, n = !0, f = x, s, u, r, i, a;
    !ce(e[0]) && typeof e[0] == "object" ? {delay: u, trailing: r=!0, leading: i=!0, rejectOnCancel: a=!1} = e[0] : [u,r=!0,i=!0,a=!1] = e;
    const c = () => {
        o && (clearTimeout(o),
        o = void 0,
        f(),
        f = x)
    }
    ;
    return p => {
        const g = E(u)
          , y = Date.now() - t
          , b = () => s = p();
        return c(),
        g <= 0 ? (t = Date.now(),
        b()) : (y > g && (i || !n) ? (t = Date.now(),
        b()) : r && (s = new Promise( (l, h) => {
            f = a ? h : l,
            o = setTimeout( () => {
                t = Date.now(),
                n = !0,
                l(b()),
                c()
            }
            , Math.max(0, g - y))
        }
        )),
        !i && !o && (o = setTimeout( () => n = !0, g)),
        n = !1,
        s)
    }
}
function Te(e) {
    let t;
    function o() {
        return t || (t = e()),
        t
    }
    return o.reset = async () => {
        const n = t;
        t = void 0,
        n && await n
    }
    ,
    o
}
function F(e) {
    return Array.isArray(e) ? e : [e]
}
function Se(e) {
    return N()
}
function xe(e, t=200, o={}) {
    return oe(Oe(t, o), e)
}
function ke(e, t=200, o=!1, n=!0, f=!1) {
    return oe(Ee(t, o, n, f), e)
}
function Fe(...e) {
    if (e.length === 2) {
        const [t,o] = e;
        t.value = o
    }
    if (e.length === 3) {
        const [t,o,n] = e;
        t[o] = n
    }
}
function re(e, t=!0, o) {
    Se() ? q(e, o) : t ? e() : ee(e)
}
function Re(e, t, o={}) {
    const {immediate: n=!0, immediateCallback: f=!1} = o
      , s = w(!1);
    let u = null;
    function r() {
        u && (clearTimeout(u),
        u = null)
    }
    function i() {
        s.value = !1,
        r()
    }
    function a(...c) {
        f && e(),
        r(),
        s.value = !0,
        u = setTimeout( () => {
            s.value = !1,
            u = null,
            e(...c)
        }
        , E(t))
    }
    return n && (s.value = !0,
    V && a()),
    D(i),
    {
        isPending: fe(s),
        start: a,
        stop: i
    }
}
function Me(e, t, o) {
    return H(e, t, {
        ...o,
        immediate: !0
    })
}
function Ae(e, t, o) {
    const n = H(e, (...f) => (ee( () => n()),
    t(...f)), o);
    return n
}
const R = V ? window : void 0
  , le = V ? window.navigator : void 0;
function S(e) {
    var t;
    const o = E(e);
    return (t = o == null ? void 0 : o.$el) != null ? t : o
}
function T(...e) {
    const t = []
      , o = () => {
        t.forEach(r => r()),
        t.length = 0
    }
      , n = (r, i, a, c) => (r.addEventListener(i, a, c),
    () => r.removeEventListener(i, a, c))
      , f = _( () => {
        const r = F(E(e[0])).filter(i => i != null);
        return r.every(i => typeof i != "string") ? r : void 0
    }
    )
      , s = Me( () => {
        var r, i;
        return [(i = (r = f.value) == null ? void 0 : r.map(a => S(a))) != null ? i : [R].filter(a => a != null), F(E(f.value ? e[1] : e[0])), F(te(f.value ? e[2] : e[1])), E(f.value ? e[3] : e[2])]
    }
    , ([r,i,a,c]) => {
        if (o(),
        !(r != null && r.length) || !(i != null && i.length) || !(a != null && a.length))
            return;
        const d = we(c) ? {
            ...c
        } : c;
        t.push(...r.flatMap(p => i.flatMap(g => a.map(y => n(p, g, y, d)))))
    }
    , {
        flush: "post"
    })
      , u = () => {
        s(),
        o()
    }
    ;
    return D(o),
    u
}
let K = !1;
function ze(e, t, o={}) {
    const {window: n=R, ignore: f=[], capture: s=!0, detectIframe: u=!1, controls: r=!1} = o;
    if (!n)
        return r ? {
            stop: x,
            cancel: x,
            trigger: x
        } : x;
    if (ye && !K) {
        K = !0;
        const l = {
            passive: !0
        };
        Array.from(n.document.body.children).forEach(h => T(h, "click", x, l)),
        T(n.document.documentElement, "click", x, l)
    }
    let i = !0;
    const a = l => E(f).some(h => {
        if (typeof h == "string")
            return Array.from(n.document.querySelectorAll(h)).some(m => m === l.target || l.composedPath().includes(m));
        {
            const m = S(h);
            return m && (l.target === m || l.composedPath().includes(m))
        }
    }
    );
    function c(l) {
        const h = E(l);
        return h && h.$.subTree.shapeFlag === 16
    }
    function d(l, h) {
        const m = E(l)
          , O = m.$.subTree && m.$.subTree.children;
        return O == null || !Array.isArray(O) ? !1 : O.some(k => k.el === h.target || h.composedPath().includes(k.el))
    }
    const p = l => {
        const h = S(e);
        if (l.target != null && !(!(h instanceof Element) && c(e) && d(e, l)) && !(!h || h === l.target || l.composedPath().includes(h))) {
            if ("detail"in l && l.detail === 0 && (i = !a(l)),
            !i) {
                i = !0;
                return
            }
            t(l)
        }
    }
    ;
    let g = !1;
    const y = [T(n, "click", l => {
        g || (g = !0,
        setTimeout( () => {
            g = !1
        }
        , 0),
        p(l))
    }
    , {
        passive: !0,
        capture: s
    }), T(n, "pointerdown", l => {
        const h = S(e);
        i = !a(l) && !!(h && !l.composedPath().includes(h))
    }
    , {
        passive: !0
    }), u && T(n, "blur", l => {
        setTimeout( () => {
            var h;
            const m = S(e);
            ((h = n.document.activeElement) == null ? void 0 : h.tagName) === "IFRAME" && !(m != null && m.contains(n.document.activeElement)) && t(l)
        }
        , 0)
    }
    , {
        passive: !0
    })].filter(Boolean)
      , b = () => y.forEach(l => l());
    return r ? {
        stop: b,
        cancel: () => {
            i = !1
        }
        ,
        trigger: l => {
            i = !0,
            p(l),
            i = !1
        }
    } : b
}
function _e() {
    const e = w(!1)
      , t = N();
    return t && q( () => {
        e.value = !0
    }
    , t),
    e
}
function L(e) {
    const t = _e();
    return _( () => (t.value,
    !!e()))
}
function se(e, t, o={}) {
    const {window: n=R, ...f} = o;
    let s;
    const u = L( () => n && "MutationObserver"in n)
      , r = () => {
        s && (s.disconnect(),
        s = void 0)
    }
      , i = _( () => {
        const p = E(e)
          , g = F(p).map(S).filter(ne);
        return new Set(g)
    }
    )
      , a = H( () => i.value, p => {
        r(),
        u.value && p.size && (s = new MutationObserver(t),
        p.forEach(g => s.observe(g, f)))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , c = () => s == null ? void 0 : s.takeRecords()
      , d = () => {
        a(),
        r()
    }
    ;
    return D(d),
    {
        isSupported: u,
        stop: d,
        takeRecords: c
    }
}
function Pe(e, t, o={}) {
    const {window: n=R, document: f=n == null ? void 0 : n.document, flush: s="sync"} = o;
    if (!n || !f)
        return x;
    let u;
    const r = c => {
        u == null || u(),
        u = c
    }
      , i = ve( () => {
        const c = S(e);
        if (c) {
            const {stop: d} = se(f, p => {
                p.map(y => [...y.removedNodes]).flat().some(y => y === c || y.contains(c)) && t(p)
            }
            , {
                window: n,
                childList: !0,
                subtree: !0
            });
            r(d)
        }
    }
    , {
        flush: s
    })
      , a = () => {
        i(),
        r()
    }
    ;
    return D(a),
    a
}
function Q(e, t={}) {
    const {controls: o=!1, navigator: n=le} = t
      , f = L( () => n && "permissions"in n)
      , s = w()
      , u = typeof e == "string" ? {
        name: e
    } : e
      , r = w()
      , i = () => {
        var c, d;
        r.value = (d = (c = s.value) == null ? void 0 : c.state) != null ? d : "prompt"
    }
    ;
    T(s, "change", i, {
        passive: !0
    });
    const a = Te(async () => {
        if (f.value) {
            if (!s.value)
                try {
                    s.value = await n.permissions.query(u)
                } catch {
                    s.value = void 0
                } finally {
                    i()
                }
            if (o)
                return pe(s.value)
        }
    }
    );
    return a(),
    o ? {
        state: r,
        isSupported: f,
        query: a
    } : r
}
function Be(e={}) {
    const {navigator: t=le, read: o=!1, source: n, copiedDuring: f=1500, legacy: s=!1} = e
      , u = L( () => t && "clipboard"in t)
      , r = Q("clipboard-read")
      , i = Q("clipboard-write")
      , a = _( () => u.value || s)
      , c = w("")
      , d = w(!1)
      , p = Re( () => d.value = !1, f, {
        immediate: !1
    });
    async function g() {
        let m = !(u.value && h(r.value));
        if (!m)
            try {
                c.value = await t.clipboard.readText()
            } catch {
                m = !0
            }
        m && (c.value = l())
    }
    a.value && o && T(["copy", "cut"], g, {
        passive: !0
    });
    async function y(m=E(n)) {
        if (a.value && m != null) {
            let O = !(u.value && h(i.value));
            if (!O)
                try {
                    await t.clipboard.writeText(m)
                } catch {
                    O = !0
                }
            O && b(m),
            c.value = m,
            d.value = !0,
            p.start()
        }
    }
    function b(m) {
        const O = document.createElement("textarea");
        O.value = m ?? "",
        O.style.position = "absolute",
        O.style.opacity = "0",
        document.body.appendChild(O),
        O.select(),
        document.execCommand("copy"),
        O.remove()
    }
    function l() {
        var m, O, k;
        return (k = (O = (m = document == null ? void 0 : document.getSelection) == null ? void 0 : m.call(document)) == null ? void 0 : O.toString()) != null ? k : ""
    }
    function h(m) {
        return m === "granted" || m === "prompt"
    }
    return {
        isSupported: a,
        text: c,
        copied: d,
        copy: y
    }
}
function Ve(e) {
    const t = N()
      , o = he( () => null, () => t.proxy.$el);
    return de(o.trigger),
    q(o.trigger),
    o
}
function Ce(e={}) {
    const {window: t=R} = e
      , o = L( () => t && "DeviceOrientationEvent"in t)
      , n = w(!1)
      , f = w(null)
      , s = w(null)
      , u = w(null);
    return t && o.value && T(t, "deviceorientation", r => {
        n.value = r.absolute,
        f.value = r.alpha,
        s.value = r.beta,
        u.value = r.gamma
    }
    , {
        passive: !0
    }),
    {
        isSupported: o,
        isAbsolute: n,
        alpha: f,
        beta: s,
        gamma: u
    }
}
function We(e, t, o={}) {
    const {window: n=R, ...f} = o;
    let s;
    const u = L( () => n && "ResizeObserver"in n)
      , r = () => {
        s && (s.disconnect(),
        s = void 0)
    }
      , i = _( () => {
        const d = E(e);
        return Array.isArray(d) ? d.map(p => S(p)) : [S(d)]
    }
    )
      , a = H(i, d => {
        if (r(),
        u.value && n) {
            s = new ResizeObserver(t);
            for (const p of d)
                p && s.observe(p, f)
        }
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , c = () => {
        r(),
        a()
    }
    ;
    return D(c),
    {
        isSupported: u,
        stop: c
    }
}
function qe(e, t={}) {
    const {reset: o=!0, windowResize: n=!0, windowScroll: f=!0, immediate: s=!0, updateTiming: u="sync"} = t
      , r = w(0)
      , i = w(0)
      , a = w(0)
      , c = w(0)
      , d = w(0)
      , p = w(0)
      , g = w(0)
      , y = w(0);
    function b() {
        const h = S(e);
        if (!h) {
            o && (r.value = 0,
            i.value = 0,
            a.value = 0,
            c.value = 0,
            d.value = 0,
            p.value = 0,
            g.value = 0,
            y.value = 0);
            return
        }
        const m = h.getBoundingClientRect();
        r.value = m.height,
        i.value = m.bottom,
        a.value = m.left,
        c.value = m.right,
        d.value = m.top,
        p.value = m.width,
        g.value = m.x,
        y.value = m.y
    }
    function l() {
        u === "sync" ? b() : u === "next-frame" && requestAnimationFrame( () => b())
    }
    return We(e, l),
    H( () => S(e), h => !h && l()),
    se(e, l, {
        attributeFilter: ["style", "class"]
    }),
    f && T("scroll", l, {
        capture: !0,
        passive: !0
    }),
    n && T("resize", l, {
        passive: !0
    }),
    re( () => {
        s && l()
    }
    ),
    {
        height: r,
        bottom: i,
        left: a,
        right: c,
        top: d,
        width: p,
        x: g,
        y,
        update: l
    }
}
function Ne(e, t={}) {
    const {delayEnter: o=0, delayLeave: n=0, triggerOnRemoval: f=!1, window: s=R} = t
      , u = w(!1);
    let r;
    const i = a => {
        const c = a ? o : n;
        r && (clearTimeout(r),
        r = void 0),
        c ? r = setTimeout( () => u.value = a, c) : u.value = a
    }
    ;
    return s && (T(e, "mouseenter", () => i(!0), {
        passive: !0
    }),
    T(e, "mouseleave", () => i(!1), {
        passive: !0
    }),
    f && Pe(_( () => S(e)), () => i(!1))),
    u
}
function Ie(e, t, o={}) {
    const {root: n, rootMargin: f="0px", threshold: s=0, window: u=R, immediate: r=!0} = o
      , i = L( () => u && "IntersectionObserver"in u)
      , a = _( () => {
        const y = E(e);
        return F(y).map(S).filter(ne)
    }
    );
    let c = x;
    const d = w(r)
      , p = i.value ? H( () => [a.value, S(n), d.value], ([y,b]) => {
        if (c(),
        !d.value || !y.length)
            return;
        const l = new IntersectionObserver(t,{
            root: S(b),
            rootMargin: f,
            threshold: s
        });
        y.forEach(h => h && l.observe(h)),
        c = () => {
            l.disconnect(),
            c = x
        }
    }
    , {
        immediate: r,
        flush: "post"
    }) : x
      , g = () => {
        c(),
        p(),
        d.value = !1
    }
    ;
    return D(g),
    {
        isSupported: i,
        isActive: d,
        pause() {
            c(),
            d.value = !1
        },
        resume() {
            d.value = !0
        },
        stop: g
    }
}
function $e(e, t={}) {
    const {window: o=R, scrollTarget: n, threshold: f=0, rootMargin: s, once: u=!1} = t
      , r = w(!1)
      , {stop: i} = Ie(e, a => {
        let c = r.value
          , d = 0;
        for (const p of a)
            p.time >= d && (d = p.time,
            c = p.isIntersecting);
        r.value = c,
        u && Ae(r, () => {
            i()
        }
        )
    }
    , {
        root: n,
        window: o,
        threshold: f,
        rootMargin: E(s)
    });
    return r
}
const Z = 1;
function Ge(e, t={}) {
    const {throttle: o=0, idle: n=200, onStop: f=x, onScroll: s=x, offset: u={
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    }, eventListenerOptions: r={
        capture: !1,
        passive: !0
    }, behavior: i="auto", window: a=R, onError: c=v => {
        console.error(v)
    }
    } = t
      , d = w(0)
      , p = w(0)
      , g = _({
        get() {
            return d.value
        },
        set(v) {
            b(v, void 0)
        }
    })
      , y = _({
        get() {
            return p.value
        },
        set(v) {
            b(void 0, v)
        }
    });
    function b(v, M) {
        var A, X, Y, z;
        if (!a)
            return;
        const P = E(e);
        if (!P)
            return;
        (Y = P instanceof Document ? a.document.body : P) == null || Y.scrollTo({
            top: (A = E(M)) != null ? A : y.value,
            left: (X = E(v)) != null ? X : g.value,
            behavior: E(i)
        });
        const I = ((z = P == null ? void 0 : P.document) == null ? void 0 : z.documentElement) || (P == null ? void 0 : P.documentElement) || P;
        g != null && (d.value = I.scrollLeft),
        y != null && (p.value = I.scrollTop)
    }
    const l = w(!1)
      , h = B({
        left: !0,
        right: !1,
        top: !0,
        bottom: !1
    })
      , m = B({
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
    })
      , O = v => {
        l.value && (l.value = !1,
        m.left = !1,
        m.right = !1,
        m.top = !1,
        m.bottom = !1,
        f(v))
    }
      , k = xe(O, o + n)
      , C = v => {
        var M;
        if (!a)
            return;
        const A = ((M = v == null ? void 0 : v.document) == null ? void 0 : M.documentElement) || (v == null ? void 0 : v.documentElement) || S(v)
          , {display: X, flexDirection: Y, direction: z} = getComputedStyle(A)
          , P = z === "rtl" ? -1 : 1
          , I = A.scrollLeft;
        m.left = I < d.value,
        m.right = I > d.value;
        const $ = Math.abs(I * P) <= (u.left || 0)
          , G = Math.abs(I * P) + A.clientWidth >= A.scrollWidth - (u.right || 0) - Z;
        X === "flex" && Y === "row-reverse" ? (h.left = G,
        h.right = $) : (h.left = $,
        h.right = G),
        d.value = I;
        let j = A.scrollTop;
        v === a.document && !j && (j = a.document.body.scrollTop),
        m.top = j < p.value,
        m.bottom = j > p.value;
        const U = Math.abs(j) <= (u.top || 0)
          , J = Math.abs(j) + A.clientHeight >= A.scrollHeight - (u.bottom || 0) - Z;
        X === "flex" && Y === "column-reverse" ? (h.top = J,
        h.bottom = U) : (h.top = U,
        h.bottom = J),
        p.value = j
    }
      , W = v => {
        var M;
        if (!a)
            return;
        const A = (M = v.target.documentElement) != null ? M : v.target;
        C(A),
        l.value = !0,
        k(v),
        s(v)
    }
    ;
    return T(e, "scroll", o ? ke(W, o, !0, !1) : W, r),
    re( () => {
        try {
            const v = E(e);
            if (!v)
                return;
            C(v)
        } catch (v) {
            c(v)
        }
    }
    ),
    T(e, "scrollend", O, r),
    {
        x: g,
        y,
        isScrolling: l,
        arrivedState: h,
        directions: m,
        measure() {
            const v = E(e);
            a && v && C(v)
        }
    }
}
const He = {
    page: e => [e.pageX, e.pageY],
    client: e => [e.clientX, e.clientY],
    screen: e => [e.screenX, e.screenY],
    movement: e => e instanceof MouseEvent ? [e.movementX, e.movementY] : null
};
function je(e={}) {
    const {type: t="page", touch: o=!0, resetOnTouchEnds: n=!1, initialValue: f={
        x: 0,
        y: 0
    }, window: s=R, target: u=s, scroll: r=!0, eventFilter: i} = e;
    let a = null
      , c = 0
      , d = 0;
    const p = w(f.x)
      , g = w(f.y)
      , y = w(null)
      , b = typeof t == "function" ? t : He[t]
      , l = v => {
        const M = b(v);
        a = v,
        M && ([p.value,g.value] = M,
        y.value = "mouse"),
        s && (c = s.scrollX,
        d = s.scrollY)
    }
      , h = v => {
        if (v.touches.length > 0) {
            const M = b(v.touches[0]);
            M && ([p.value,g.value] = M,
            y.value = "touch")
        }
    }
      , m = () => {
        if (!a || !s)
            return;
        const v = b(a);
        a instanceof MouseEvent && v && (p.value = v[0] + s.scrollX - c,
        g.value = v[1] + s.scrollY - d)
    }
      , O = () => {
        p.value = f.x,
        g.value = f.y
    }
      , k = i ? v => i( () => l(v), {}) : v => l(v)
      , C = i ? v => i( () => h(v), {}) : v => h(v)
      , W = i ? () => i( () => m(), {}) : () => m();
    if (u) {
        const v = {
            passive: !0
        };
        T(u, ["mousemove", "dragover"], k, v),
        o && t !== "movement" && (T(u, ["touchstart", "touchmove"], C, v),
        n && T(u, "touchend", O, v)),
        r && t === "page" && T(s, "scroll", W, v)
    }
    return {
        x: p,
        y: g,
        sourceType: y
    }
}
function Le(e, t={}) {
    const {handleOutside: o=!0, window: n=R} = t
      , f = t.type || "page"
      , {x: s, y: u, sourceType: r} = je(t)
      , i = w(e ?? (n == null ? void 0 : n.document.body))
      , a = w(0)
      , c = w(0)
      , d = w(0)
      , p = w(0)
      , g = w(0)
      , y = w(0)
      , b = w(!0);
    let l = () => {}
    ;
    return n && (l = H([i, s, u], () => {
        const h = S(i);
        if (!h || !(h instanceof Element))
            return;
        const {left: m, top: O, width: k, height: C} = h.getBoundingClientRect();
        d.value = m + (f === "page" ? n.pageXOffset : 0),
        p.value = O + (f === "page" ? n.pageYOffset : 0),
        g.value = C,
        y.value = k;
        const W = s.value - d.value
          , v = u.value - p.value;
        b.value = k === 0 || C === 0 || W < 0 || v < 0 || W > k || v > C,
        (o || !b.value) && (a.value = W,
        c.value = v)
    }
    , {
        immediate: !0
    }),
    T(document, "mouseleave", () => b.value = !0, {
        passive: !0
    })),
    {
        x: s,
        y: u,
        sourceType: r,
        elementX: a,
        elementY: c,
        elementPositionX: d,
        elementPositionY: p,
        elementHeight: g,
        elementWidth: y,
        isOutside: b,
        stop: l
    }
}
function De(e={}) {
    const {window: t=R} = e
      , o = L( () => t && "screen"in t && "orientation"in t.screen)
      , n = o.value ? t.screen.orientation : {}
      , f = me(n.type)
      , s = w(n.angle || 0);
    return o.value && T(t, "orientationchange", () => {
        f.value = n.type,
        s.value = n.angle
    }
    , {
        passive: !0
    }),
    {
        isSupported: o,
        orientation: f,
        angle: s,
        lockOrientation: i => o.value && typeof n.lock == "function" ? n.lock(i) : Promise.reject(new Error("Not supported")),
        unlockOrientation: () => {
            o.value && typeof n.unlock == "function" && n.unlock()
        }
    }
}
function Ue(e, t={}) {
    const {deviceOrientationTiltAdjust: o=l => l, deviceOrientationRollAdjust: n=l => l, mouseTiltAdjust: f=l => l, mouseRollAdjust: s=l => l, window: u=R} = t
      , r = B(Ce({
        window: u
    }))
      , i = B(De({
        window: u
    }))
      , {elementX: a, elementY: c, elementWidth: d, elementHeight: p} = Le(e, {
        handleOutside: !1,
        window: u
    })
      , g = _( () => r.isSupported && (r.alpha != null && r.alpha !== 0 || r.gamma != null && r.gamma !== 0) ? "deviceOrientation" : "mouse")
      , y = _( () => {
        if (g.value === "deviceOrientation") {
            let l;
            switch (i.orientation) {
            case "landscape-primary":
                l = r.gamma / 90;
                break;
            case "landscape-secondary":
                l = -r.gamma / 90;
                break;
            case "portrait-primary":
                l = -r.beta / 90;
                break;
            case "portrait-secondary":
                l = r.beta / 90;
                break;
            default:
                l = -r.beta / 90
            }
            return n(l)
        } else {
            const l = -(c.value - p.value / 2) / p.value;
            return s(l)
        }
    }
    )
      , b = _( () => {
        if (g.value === "deviceOrientation") {
            let l;
            switch (i.orientation) {
            case "landscape-primary":
                l = r.beta / 90;
                break;
            case "landscape-secondary":
                l = -r.beta / 90;
                break;
            case "portrait-primary":
                l = r.gamma / 90;
                break;
            case "portrait-secondary":
                l = -r.gamma / 90;
                break;
            default:
                l = r.gamma / 90
            }
            return o(l)
        } else {
            const l = (a.value - d.value / 2) / d.value;
            return f(l)
        }
    }
    );
    return {
        roll: y,
        tilt: b,
        source: g
    }
}
export {$e as a, Ve as b, Le as c, Ne as d, Ge as e, qe as f, Ye as g, Be as h, Ue as i, ze as o, Fe as s, T as u};

/**
 * END of CrWOzmEA.js
 */


/**
 * START of D_MGx2mw.js
 */
import {f as _, E as b, h as n, d, i as g, $ as i, u as r, U as c, o as f, a as h, V as k, Y as m, P as y, _ as B} from "./DtnJ4yNw.js";
const x = {
    class: "link-active"
}
  , C = _({
    __name: "DSButton",
    props: {
        tag: {
            default: null
        },
        underline: {
            type: Boolean
        },
        semiUnderline: {
            type: Boolean
        },
        to: {
            default: void 0
        },
        buttonType: {
            default: null
        },
        hoverBackground: {
            default: "rgba(5, 36, 36, 1)"
        },
        hoverColor: {
            default: "rgba(171, 255, 2, 1)"
        },
        baseColor: {
            default: "rgba(5, 36, 36, 1)"
        },
        underlined: {
            type: Boolean,
            default: !0
        },
        disabled: {
            type: Boolean,
            default: !1
        }
    },
    setup(p) {
        const l = b("el")
          , e = p
          , o = n( () => {
            if (!e.to)
                return !1;
            const t = typeof e.to == "string" ? e.to : e.to.path || "";
            return t.startsWith("http") || t.startsWith("//")
        }
        )
          , a = n( () => e.tag ? e.tag : e.to ? o.value ? "a" : "NuxtLink" : "button")
          , s = n( () => a.value === "NuxtLink" ? y : a.value)
          , v = n( () => {
            const t = a.value === "button" || a.value === "input";
            return {
                to: o.value ? void 0 : e.to,
                href: o.value ? e.to : void 0,
                target: o.value ? "_blank" : void 0,
                rel: o.value ? "noopener noreferrer" : void 0,
                disabled: t ? e.disabled : void 0,
                class: {
                    "button--underlined": e.buttonType === "underlined",
                    "link-active-full": e.buttonType === "underlined"
                },
                style: {
                    "--hover-bg": e.hoverBackground,
                    "--hover-color": e.hoverColor,
                    "--base-color": e.baseColor
                }
            }
        }
        )
          , u = n( () => ({
            ...v.value,
            ...m()
        }));
        return (t, L) => t.$slots.default ? (f(),
        d(c(r(s)), i({
            key: 0
        }, r(u), {
            ref_key: "el",
            ref: l,
            class: ["button label-4", {
                "no-underline": !e.underlined
            }]
        }), {
            default: g( () => [h("span", x, [k(t.$slots, "default", {}, void 0, !0)])]),
            _: 3
        }, 16, ["class"])) : (f(),
        d(c(r(s)), i({
            key: 1,
            ref_key: "el",
            ref: l
        }, r(u), {
            class: ["button", {
                "input-button": e.tag === "input"
            }]
        }), null, 16, ["class"]))
    }
})
  , N = B(C, [["__scopeId", "data-v-d8fa3fef"]]);
export {N as default};

 /**
 * END of D_MGx2mw.js
 */
